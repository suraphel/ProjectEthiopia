(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_chatroom_chatComponents_js"],{

/***/ "./components/chatroom/AblyReactEffect.js":
/*!************************************************!*\
  !*** ./components/chatroom/AblyReactEffect.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useChannel": function() { return /* binding */ useChannel; }
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();

//offer company name and logo
// textarea for his offer
// hidden and appear
// states for rendering the page
//WebSocket connections
//Ably
//add and Id
//add message storage and retrival
//


var ably = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime.Promise)({
  authUrl: "/api/createTokenRequest"
}); // console.log(ably);

function useChannel(channelName, callbackOnMessage) {
  _s();

  var channel = ably.channels.get(channelName);

  var onMount = function onMount() {
    channel.subscribe(function (msg) {
      callbackOnMessage(msg);
    });
  };

  var onUnMount = function onUnMount() {
    channel.unsubscribe();
  };

  var useEffectHook = function useEffectHook() {
    onMount();
    return function () {
      onUnMount();
    };
  };

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(useEffectHook);
  return [channel, ably];
}

_s(useChannel, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/chatroom/chatComponents.js":
/*!***********************************************!*\
  !*** ./components/chatroom/chatComponents.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactEffect */ "./components/chatroom/AblyReactEffect.js");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chatroom/chatComponents.module.css */ "./components/chatroom/chatComponents.module.css");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "A:\\Projects\\NextJs\\Balemoja_Next\\Balemoja\\components\\chatroom\\chatComponents.js",
    _this = undefined,
    _s = $RefreshSig$();






var ChatComponent = function ChatComponent() {
  _s();

  var inputBox = null;
  var messageEnd = null;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(""),
      messageText = _useState[0],
      setMessageText = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      receivedMessages = _useState2[0],
      setMessages = _useState2[1];

  var messageTextIsEmpty = messageText.trim().length === 0;

  var _useChannel = (0,_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel)("chat-demo", function (message) {
    var history = receivedMessages.slice(-199);
    setMessages([].concat((0,A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(history), [message]));
  }),
      _useChannel2 = (0,A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_useChannel, 2),
      channel = _useChannel2[0],
      ably = _useChannel2[1];

  var sendChatMessage = function sendChatMessage(messageText) {
    channel.publish({
      name: "chat-message",
      data: messageText
    });
    setMessageText("");
    inputBox.focus();
  };

  var handleFormSubmission = function handleFormSubmission(event) {
    event.preventDefault();
    sendChatMessage(messageText);
  };

  var handleKeyPress = function handleKeyPress(event) {
    if (event.charCode !== 13 || messageTextIsEmpty) {
      return;
    }

    sendChatMessage(messageText);
    event.preventDefault();
  };

  var messages = receivedMessages.map(function (message, index) {
    var author = message.connectionId === ably.connection.id ? "me" : "other";
    var milliseconds = new Date();
    var timeStamp = milliseconds.toDateString(); // function parseMillisecondsIntoReadableTime(milliseconds) {
    //   //Get hours from milliseconds
    //   var hours = milliseconds / (1000 * 60 * 60);
    //   var absoluteHours = Math.floor(hours);
    //   var h = absoluteHours > 9 ? absoluteHours : "0" + absoluteHours;
    //   //Get remainder from hours and convert to minutes
    //   var minutes = (hours - absoluteHours) * 60;
    //   var absoluteMinutes = Math.floor(minutes);
    //   var m = absoluteMinutes > 9 ? absoluteMinutes : "0" + absoluteMinutes;
    //   //Get remainder from minutes and convert to seconds
    //   var seconds = (minutes - absoluteMinutes) * 60;
    //   var absoluteSeconds = Math.floor(seconds);
    //   var s = absoluteSeconds > 9 ? absoluteSeconds : "0" + absoluteSeconds;
    //   return h + ":" + m + ":" + s;
    // }
    // var time = parseMillisecondsIntoReadableTime(milliseconds);
    // alert(time);
    // console.log(time);

    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().message) // time={new Date().toString()}
      ,
      "data-author": author,
      children: message.data
    }, index, false, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, _this);
  });
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    messageEnd.scrollIntoView({
      behaviour: "smooth"
    });
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatHolder),
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatText),
      children: [messages, new Date().toDateString(), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        ref: function ref(element) {
          messageEnd = element;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 88,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("form", {
      onSubmit: handleFormSubmission,
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().form),
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("textarea", {
        ref: function ref(element) {
          inputBox = element;
        },
        value: messageText,
        placeholder: "Type a message..." // time={new Date().toString()}
        ,
        onChange: function onChange(e) {
          return setMessageText(e.target.value);
        },
        onKeyPress: handleKeyPress,
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().textarea)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        type: "submit",
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().button),
        disabled: messageTextIsEmpty,
        children: "Send"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 106,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 84,
    columnNumber: 5
  }, _this);
};

_s(ChatComponent, "UHCFF9ns1jrEPUyCddaISRIBzu0=", false, function () {
  return [_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel];
});

_c = ChatComponent;
/* harmony default export */ __webpack_exports__["default"] = (ChatComponent);

var _c;

$RefreshReg$(_c, "ChatComponent");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/ably/browser/static/ably-commonjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/browser/static/ably-commonjs.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*!
 * @license Copyright 2021, Ably
 * 
 * Ably JavaScript Library v1.2.13
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.com
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_749__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_749__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_749__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_749__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_749__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_749__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_749__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_749__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_749__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_749__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_749__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_749__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_749__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_749__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_749__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_749__(__nested_webpack_require_749__.s = 50);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4226__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4226__(3);


var Logger = (function() {
	var consoleLogger, errorLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
		 (global.console && global.console.log && (typeof global.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
		errorLogger = console.warn ? function() { console.warn.apply(console, arguments); } : consoleLogger;
	} else if(global.console && global.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = errorLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = errorLogger = function() {};
	}

	function pad(str, three) {
		return ('000' + str).slice(-2-(three || 0));
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;

	function getHandler(logger) {
		return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logTimestamps ?
			function(msg) {
				var time = new Date();
				logger(pad(time.getHours()) + ':' + pad(time.getMinutes()) + ':' + pad(time.getSeconds()) + '.' + pad(time.getMilliseconds(), true) + ' ' + msg);
			} : logger;
	}

	var logHandler = getHandler(consoleLogger),
		logErrorHandler = getHandler(errorLogger);

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			(level === LOG_ERROR ? logErrorHandler : logHandler)('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
	}

	Logger.deprecatedWithMsg = function(funcName, msg) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = logErrorHandler = handler;
	};

	return Logger;
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_4226__(17)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_7545__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7545__(3);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7545__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_7545__(5);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var Utils = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function Utils() {}

	function randomPosn(arrOrStr) {
		return Math.floor(Math.random() * arrOrStr.length);
	}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target) {
		for(var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			if(!source) { break; }
			for(var key in source) {
				if(hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.forInOwnNonNullProps = function(ob, fn) {
		for (var prop in ob) {
			if (hasOwnProperty.call(ob, prop) && ob[prop]) {
				fn(prop);
			}
		}
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.allSame = function(arr, prop) {
		if(arr.length === 0) {
			return true;
		}
		var first = arr[0][prop];
		return Utils.arrEvery(arr, function(item) {
			return item[prop] === first;
		});
	};

	Utils.nextTick = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		var accept = contentTypes[format || 'json'];
		return {
			accept: accept,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.defaultPostHeaders = function(format) {
		var accept, contentType;
		accept = contentType = contentTypes[format || 'json'];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(randomPosn(arr), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect;

	Utils.isErrorInfo = function(err) {
		return err.constructor.name == 'ErrorInfo'
	};

	Utils.inspectError = function(x) {
		/* redundant, but node vmcontext issue makes instanceof unreliable, and
		 * can't use just constructor test as could be a TypeError constructor etc. */
		return (x && (Utils.isErrorInfo(x) ||
			x.constructor.name == 'Error' ||
			x instanceof Error)) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.inspectBody = function(body) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(body)) {
			return body.toString();
		} else if(typeof body === 'string') {
			return body;
		} else {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(body);
		}
	};

	/* Data is assumed to be either a string or a buffer. */
	Utils.dataSizeBytes = function(data) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].byteLength(data);
		}
		if(typeof data === 'string') {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringByteSize(data);
		}
		throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + (typeof data));
	};

	Utils.cheapRandStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Takes param the minimum number of bytes of entropy the string must
	 * include, not the length of the string. String length produced is not
	 * guaranteed. */
	Utils.randomString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(uIntArr);
		} : function(numBytes) {
			/* Old browser; fall back to Math.random. Could just use a
			 * CryptoJS version of the above, but want this to still work in nocrypto
			 * versions of the library */
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64CharSet;
			/* base64 has 33% overhead; round length up */
			var length = Math.round(numBytes * 4/3);
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	Utils.randomHexString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexEncode(uIntArr);
		} : function(numBytes) {
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexCharSet;
			var length = numBytes * 2;
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	Utils.promisify = function(ob, fnName, args) {
		return new Promise(function(resolve, reject) {
			ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
				err ? reject(err) : resolve(res);
			}));
		});
	};

	Utils.decodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));
	};

	Utils.encodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.encode(body, true) : JSON.stringify(body);
	};

	Utils.allToLowerCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toLowerCase();
		});
	};

	Utils.allToUpperCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toUpperCase();
		});
	};

	return Utils;
})();

/* harmony default export */ __webpack_exports__["a"] = (Utils);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_21941__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_21941__(1);


var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode, cause) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
		this.cause = cause;
		this.href = undefined;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		if(this.cause) result += '; cause=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(this.cause);
		if(this.href && !(this.message && this.message.indexOf('help.ably.io') > -1)) result += '; see ' + this.href + ' ';
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		if(result.code && !result.href) {
			result.href = 'https://help.ably.io/error/' + result.code;
		}
		return result;
	};

	return ErrorInfo;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorInfo);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_23403__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony import */ var _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_23403__(24);


if(typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

function allowComet() {
	/* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
	 * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
	 * So if websockets are supported, then just forget about comet transports and use that */
	var loc = global.location;
	return (!global.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1);
}

var userAgent = global.navigator && global.navigator.userAgent.toString();
var currentUrl = global.location && global.location.href;

var Platform = {
        agent: 'browser',
	logTimestamps: true,
	userAgent: userAgent,
	currentUrl: currentUrl,
	noUpgrade: userAgent && userAgent.match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: global.WebSocket || global.MozWebSocket,
	xhrSupported: global.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
	jsonpSupported: typeof(document) !== 'undefined',
	allowComet: allowComet(),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
	supportsBinary: !!global.TextDecoder,
	preferBinary: false,
	ArrayBuffer: global.ArrayBuffer,
	atob: global.atob,
	nextTick: typeof setImmediate !== 'undefined' ? global.setImmediate.bind(global) : function(f) { setTimeout(f, 0); },
	addEventListener: global.addEventListener,
	inspect: JSON.stringify,
	stringByteSize: function(str) {
		/* str.length will be an underestimate for non-ascii strings. But if we're
		 * in a browser too old to support TextDecoder, not much we can do. Better
		 * to underestimate, so if we do go over-size, the server will reject the
		 * message */
		return global.TextDecoder &&
			(new global.TextEncoder().encode(str)).length ||
			str.length;
	},
	TextEncoder: global.TextEncoder,
	TextDecoder: global.TextDecoder,
	Promise: global.Promise,
	getRandomValues: (function(crypto) {
		if (crypto === undefined) {
			return undefined;
		}
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			if(callback) {
				callback(null);
			}
		};
	})(global.crypto || global.msCrypto) // mscrypto for IE11
};

/* harmony default export */ __webpack_exports__["a"] = (Platform);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_23403__(17), __nested_webpack_require_23403__(42).setImmediate))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_26250__) {

"use strict";

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_26250__(3);

// CONCATENATED MODULE: ./browser/lib/util/defaults.js


var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket']
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(platform_browser["a" /* default */].noUpgrade) {
	Defaults.upgradeTransports = [];
}

/* harmony default export */ var defaults = (Defaults);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_26250__(1);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_26250__(5);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_26250__(0);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_26250__(2);

// CONCATENATED MODULE: ./common/lib/util/defaults.js







defaults.ENVIRONMENT              = '';
defaults.REST_HOST                = 'rest.ably.io';
defaults.REALTIME_HOST            = 'realtime.ably.io';
defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
defaults.PORT                     = 80;
defaults.TLS_PORT                 = 443;
defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	/* Undocumented, but part of the api and can be used by customers: */
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	fallbackRetryTimeout       : 600000,
	/* For internal / test use only: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 6000
};
defaults.httpMaxRetryCount = 3;
defaults.maxMessageSize    = 65536;

defaults.errorReportingUrl = 'https://errors.ably.io/api/15/store/';
defaults.errorReportingHeaders = {
	"X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
	"Content-Type": "application/json"
};

defaults.version          = '1.2.13';
defaults.apiVersion       = '1.2';

var agent = 'ably-js/' + defaults.version;
if (platform_browser["a" /* default */].agent) {
	agent += ' ' + platform_browser["a" /* default */].agent;
} 
defaults.agent = agent;

defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

// construct environment fallback hosts as per RSC15i
defaults.environmentFallbackHosts = function(environment) {
	return [
		environment + '-a-fallback.ably-realtime.com',
		environment + '-b-fallback.ably-realtime.com',
		environment + '-c-fallback.ably-realtime.com',
		environment + '-d-fallback.ably-realtime.com',
		environment + '-e-fallback.ably-realtime.com'
	];
};

defaults.getFallbackHosts = function(options) {
	var fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : defaults.httpMaxRetryCount;

	return fallbackHosts ? utils["a" /* default */].arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
};

defaults.getHosts = function(options) {
	return [options.restHost].concat(defaults.getFallbackHosts(options));
};

function checkHost(host) {
	if(typeof host !== 'string') {
		throw new errorinfo["a" /* default */]('host must be a string; was a ' + typeof host, 40000, 400);
	};
	if(!host.length) {
		throw new errorinfo["a" /* default */]('host must not be zero-length', 40000, 400);
	};
}

defaults.objectifyOptions = function(options) {
	if(typeof options == 'string') {
		return (options.indexOf(':') == -1) ? {token: options} : {key: options};
	}
	return options;
};

defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		logger["a" /* default */].deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		logger["a" /* default */].deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		logger["a" /* default */].deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.fallbackHostsUseDefault) {
		/* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
		if(options.fallbackHosts) {
			var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* default fallbacks can't be used with custom ports */
		if(options.port || options.tlsPort) {
			var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* emit an appropriate deprecation warning */
		if(options.environment) {
			logger["a" /* default */].deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
		} else {
			logger["a" /* default */].deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
		}

		/* use the default fallback hosts as requested */
		options.fallbackHosts = defaults.FALLBACK_HOSTS;
	}

	if(options.recover === true) {
		logger["a" /* default */].deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(!('closeOnUnload' in options)) {
		/* Have closeOnUnload default to true unless we have any indication that
		 * the user may want to recover the connection */
		options.closeOnUnload = !options.recover;
	}

	if(options.transports && utils["a" /* default */].arrIn(options.transports, 'xhr')) {
		logger["a" /* default */].deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		utils["a" /* default */].arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	/* infer hosts and fallbacks based on the configured environment */
	var environment = (options.environment && String(options.environment).toLowerCase()) || defaults.ENVIRONMENT;
	var production = !environment || (environment === 'production');

	if(!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
		options.fallbackHosts = production ? defaults.FALLBACK_HOSTS : defaults.environmentFallbackHosts(environment);
	}

	if(!options.realtimeHost) {
		/* prefer setting realtimeHost to restHost as a custom restHost typically indicates
		 * a development environment is being used that can't be inferred by the library */
		if(options.restHost) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_WARN, 'Defaults.normaliseOptions', 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
			options.realtimeHost = options.restHost
		} else {
			options.realtimeHost = production ? defaults.REALTIME_HOST : environment + '-' + defaults.REALTIME_HOST;
		}
	}

	if(!options.restHost) {
		options.restHost = production ? defaults.REST_HOST : environment + '-' + defaults.REST_HOST;
	}

	utils["a" /* default */].arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);

	options.port = options.port || defaults.PORT;
	options.tlsPort = options.tlsPort || defaults.TLS_PORT;
	options.maxMessageSize = options.maxMessageSize || defaults.maxMessageSize;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = platform_browser["a" /* default */].supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = platform_browser["a" /* default */].preferBinary;
	}

	if(options.clientId) {
		var headers = options.headers = options.headers || {};
		headers['X-Ably-ClientId'] = bufferutils["a" /* default */].base64Encode(bufferutils["a" /* default */].utf8Encode(options.clientId));
	}

	if(!('idempotentRestPublishing' in options)) {
		options.idempotentRestPublishing = true;
	}

	if(options.promises && !platform_browser["a" /* default */].Promise) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
		options.promises = false;
	}

        if(options.agents) {
          for(var key in options.agents) {
            defaults.agent += ' ' + key + '/' + options.agents[key];
          }
        }

	return options;
};

/* harmony default export */ var util_defaults = __webpack_exports__["a"] = (defaults);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_37334__) {

"use strict";
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_37334__(32);
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_37334__(33);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_37334__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_37334__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_37334__(3);






var BufferUtils = (function() {
	var ArrayBuffer = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].ArrayBuffer;
	var atob = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].atob;
	var TextEncoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextEncoder;
	var TextDecoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextDecoder;
	var base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var hexCharSet = '0123456789abcdef';

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }
	function isTypedArray(ob) { return ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob); }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function uint8ViewToBase64(bytes) {
		var base64    = ''
		var encodings = base64CharSet;

		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	/* Most BufferUtils methods that return a binary object return an ArrayBuffer
	 * if supported, else a CryptoJS WordArray. The exception is toBuffer, which
	 * returns a Uint8Array (and won't work on browsers too old to support it) */
	function BufferUtils() {}

	BufferUtils.base64CharSet = base64CharSet;
	BufferUtils.hexCharSet = hexCharSet;

	var isBuffer = BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf) || isTypedArray(buf); };

	/* In browsers, returns a Uint8Array */
	var toBuffer = BufferUtils.toBuffer = function(buf) {
		if(!ArrayBuffer) {
			throw new Error("Can't convert to Buffer: browser does not support the necessary types");
		}

		if(isArrayBuffer(buf)) {
			return new Uint8Array(buf);
		}

		if(isTypedArray(buf)) {
			return new Uint8Array(buf.buffer);
		}

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return uint8View;
		};

		throw new Error("BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray");
	};

	BufferUtils.toArrayBuffer = function(buf) {
		if(isArrayBuffer(buf)) {
			return buf;
		}
		return toBuffer(buf).buffer;
	};

	BufferUtils.toWordArray = function(buf) {
		if(isTypedArray(buf)) {
			buf = buf.buffer;
		}
		return isWordArray(buf) ? buf : crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default.a.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isWordArray(buf)) {
			return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["stringify"])(buf);
		}
		return uint8ViewToBase64(toBuffer(buf));
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob) {
			return base64ToArrayBuffer(str);
		}
		return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["parse"])(str);
	};

	BufferUtils.hexEncode = function(buf) {
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["stringify"])(buf);
	};

	BufferUtils.hexDecode = function(string) {
		var wordArray = Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["parse"])(string);
		return ArrayBuffer ? BufferUtils.toArrayBuffer(wordArray) : wordArray;
	};

	BufferUtils.utf8Encode = function(string) {
		if(TextEncoder) {
			return (new TextEncoder()).encode(string).buffer;
		}
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["parse"])(string);
	};

	/* For utf8 decoding we apply slightly stricter input validation than to
	 * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
	 * can take (in particular allowing strings, which are just interpreted as
	 * binary); here we ensure that the input is actually a buffer since trying
	 * to utf8-decode a string to another string is almost certainly a mistake */
	BufferUtils.utf8Decode = function(buf) {
		if(!isBuffer(buf)) {
			throw new Error("Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray");
		}
		if(TextDecoder && !isWordArray(buf)) {
			return (new TextDecoder()).decode(buf);
		}
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["stringify"])(buf);
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	BufferUtils.byteLength = function(buf) {
		if(isArrayBuffer(buf) || isTypedArray(buf)) {
			return buf.byteLength
		} else if(isWordArray(buf)) {
			return buf.sigBytes;
		}
	};

	/* Returns ArrayBuffer on browser and Buffer on Node.js */
	BufferUtils.typedArrayToBuffer = function(typedArray) {
		return typedArray.buffer;
	};

	return BufferUtils;
})();

/* harmony default export */ __webpack_exports__["a"] = (BufferUtils);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_45867__) {

"use strict";
/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_45867__(1);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_45867__(4);



var Http = (function() {
	var noop = function() {};

	function Http() {}

	var now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	function getHosts(client) {
		/* If we're a connected realtime client, try the endpoint we're connected
		 * to first -- but still have fallbacks, being connected is not an absolute
		 * guarantee that a datacenter has free capacity to service REST requests. */
		var connection = client.connection,
			connectionHost = connection && connection.connectionManager.host;

		if(connectionHost) {
			return [connectionHost].concat(_common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getFallbackHosts(client.options));
		}

		return _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getHosts(client.options);
	}
	Http._getHosts = getHosts;

	Http.methods = ['get', 'delete', 'post', 'put', 'patch'];
	Http.methodsWithoutBody = ['get', 'delete'];
	Http.methodsWithBody = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrSubtract(Http.methods, Http.methodsWithoutBody);

	/* - Http.get, Http.post, Http.put, ...
	 * Perform an HTTP request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 *
	 * - Http.getUri, Http.postUri, Http.putUri, ...
	 * Perform an HTTP request for a given full URI
	 * @param rest
	 * @param uri the full URI
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithoutBody, function(method) {
		Http[method] = function(rest, path, headers, params, callback) {
			Http['do'](method, rest, path, headers, null, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, params, callback) {
			Http.doUri(method, rest, uri, headers, null, params, callback);
		};
	});

	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithBody, function(method) {
		Http[method] = function(rest, path, headers, body, params, callback) {
			Http['do'](method, rest, path, headers, body, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, body, params, callback) {
			Http.doUri(method, rest, uri, headers, body, params, callback);
		};
	});

	/* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
	Http['do'] = function(method, rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uriFromHost = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');
		var doArgs = arguments;

		var currentFallback = rest._currentFallback;
		if(currentFallback) {
			if(currentFallback.validUntil > now()) {
				/* Use stored fallback */
				Http.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function(err) {
					if(err && shouldFallback(err)) {
						/* unstore the fallback and start from the top with the default sequence */
						rest._currentFallback = null;
						Http['do'].apply(Http, doArgs);
						return;
					}
					callback.apply(null, arguments);
				});
				return;
			} else {
				/* Fallback expired; remove it and fallthrough to normal sequence */
				rest._currentFallback = null;
			}
		}

		var hosts = getHosts(rest);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts, persistOnSuccess) {
			var host = candidateHosts.shift();
			Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts, true);
					return;
				}
				if(persistOnSuccess) {
					/* RSC15f */
					rest._currentFallback = {
						host: host,
						validUntil: now() + rest.options.timeouts.fallbackRetryTimeout
					};
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	Http.doUri = function(method, rest, uri, headers, body, params, callback) {
		Http.Request(method, rest, uri, headers, params, body, callback);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/* harmony default export */ __webpack_exports__["a"] = (Http);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_51456__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_51456__(1);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_51456__(0);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_51456__(3);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = Object.create(null);
		this.anyOnce = [];
		this.eventsOnce = Object.create(null);
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners)) {
				while ((idx = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (hasOwnProperty.call(listeners, eventName) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.any.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(listener))) {
			this.any = [];
			this.events = Object.create(null);
			this.anyOnce = [];
			this.eventsOnce = Object.create(null);
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		var argCount = arguments.length, self = this;
		if((argCount === 0 || (argCount === 1 && typeof event !== 'function')) && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				self.once(event, resolve);
			});
		}
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)){
			var listenerWrapper = function() {
				var args = Array.prototype.slice.call(arguments);
				_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
					self.off(ev, listenerWrapper);
				});
				listener.apply(this, args);
			};
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listenerWrapper);
			});
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
			self = this,
			listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string')) {
			throw("whenState requires a valid event String argument");
		}
		if(typeof listener !== 'function' && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				EventEmitter.prototype.whenState.apply(self, [targetState, currentState, resolve].concat(listenerArgs));
			});
		}
		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_60569__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60569__(1);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60569__(2);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_60569__(9);
/* harmony import */ var _presencemessage__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_60569__(11);





var ProtocolMessage = (function() {

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
		this.params = undefined;
	}

	var actions = ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.channelModes = [ 'PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE' ];

	ProtocolMessage.ActionName = [];
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[actions[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'TRANSIENT':          1 << 4,
		'ATTACH_RESUME':      1 << 5,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(modes, function(mode) {
			self.setFlag(mode);
		});
	};

	ProtocolMessage.prototype.decodeModesFromFlags = function() {
		var modes = [],
			self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(ProtocolMessage.channelModes, function(mode) {
			if(self.hasFlag(mode)) {
				modes.push(mode);
			}
		});
		return modes.length > 0 ? modes : undefined;
	};

	ProtocolMessage.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].encodeBody;

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].decodeBody(serialized, format);
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = _message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = _presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(presence[i], true);
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(_message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(_presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');
		if(msg.params) {
			var stringifiedParams = '';
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].forInOwnNonNullProps(msg.params, function(prop) {
				if (stringifiedParams.length > 0) {
					stringifiedParams += '; ';
				}
				stringifiedParams += prop + '=' + msg.params[prop];
			});
			if (stringifiedParams.length > 0) {
				result += '; params=[' + stringifiedParams + ']';
			}
		}
		result += ']';
		return result;
	};

	/* Only valid for channel messages */
	ProtocolMessage.isDuplicate = function(a, b) {
		if (a && b) {
			if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) &&
				(a.action === b.action) &&
				(a.channel === b.channel) &&
				(a.id === b.id)) {
				if (a.action === actions.PRESENCE) {
					return true;
				} else if (a.messages.length === b.messages.length) {
					for (var i = 0; i < a.messages.length; i++) {
						var aMessage = a.messages[i];
						var bMessage = b.messages[i];
						if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !==
							(bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
							return false;
						}
					}

					return true;
				}
			}
		}

		return false;
	};

	return ProtocolMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (ProtocolMessage);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_67773__) {

"use strict";
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_67773__(5);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_67773__(1);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_67773__(0);
/* harmony import */ var platform_crypto__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_67773__(19);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_67773__(2);






var Message = (function() {

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
		this.size = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			id: this.id,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		if(this.extras)
			result += '; extras=' + JSON.stringify(this.extras);
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isObject(data) || _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].encodeBody;

	Message.decode = function(message, context) {
		/* The second argument could be either EncodingDecodingContext that contains ChannelOptions or ChannelOptions */
		if(!context || !context.channelOptions) {
			var channelOptions = context;
			context = {
				channelOptions: channelOptions,
				plugins: { },
				baseEncodedPreviousPayload: undefined
			};
		}

		var lastPayload = message.data;
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				lastProcessedEncodingIndex, encodingsToProcess = xforms.length,
				data = message.data;

			try {
				while((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
					var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Decode(String(data));
							if(lastProcessedEncodingIndex == xforms.length) {
								lastPayload = data;
							}
							continue;
						case 'utf-8':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(context.channelOptions != null && context.channelOptions.cipher) {
								var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						case 'vcdiff':
							if(!context.plugins || !context.plugins.vcdiff) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
							}
							if(typeof Uint8Array === 'undefined') {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
							}
							try {
								var deltaBase = context.baseEncodedPreviousPayload;
								if(typeof deltaBase === 'string') {
									deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(deltaBase);
								}

								/* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
								 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
								 * to process it into a buffer anyway) */
								deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(deltaBase);
								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);

								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
								lastPayload = data;
							} catch(e) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Vcdiff delta decode failed with ' + e, 40018, 400);
							}
							continue;
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Error processing the ' + xform + ' encoding, decoder returned ' + e.message + '', e.code || 40013, 400);
			} finally {
				message.encoding = (lastProcessedEncodingIndex <= 0) ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
				message.data = data;
			}
		}
		context.baseEncodedPreviousPayload = lastPayload;
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	function normalizeCipherOptions(options) {
		if(options && options.cipher && !options.cipher.channelCipher) {
			if(!platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		}
	}

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		normalizeCipherOptions(options);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		normalizeCipherOptions(options);
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	function getMessageSize(msg) {
		var size = 0;
		if(msg.name) {
			size += msg.name.length;
		}
		if(msg.clientId) {
			size += msg.clientId.length;
		}
		if(msg.extras) {
			size += JSON.stringify(msg.extras).length;
		}
		if(msg.data) {
			size += _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].dataSizeBytes(msg.data);
		}
		return size;
	};

	/* This should be called on encode()d (and encrypt()d) Messages (as it
	 * assumes the data is a string or buffer) */
	Message.getMessagesSize = function(messages) {
		var msg, total = 0;
		for(var i=0; i<messages.length; i++) {
			msg = messages[i];
			total += (msg.size || (msg.size = getMessageSize(msg)))
		}
		return total;
	};

	return Message;
})();

/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_79596__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_79596__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_81748__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_81748__(3);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_81748__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_81748__(5);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_81748__(9);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_81748__(1);






var PresenceMessage = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function toActionValue(actionString) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.size = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].encode;
	PresenceMessage.decode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	PresenceMessage.getMessagesSize = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getMessagesSize;

	return PresenceMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (PresenceMessage);


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_87981__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87981__(45);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87981__(17)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_111360__) {

"use strict";
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_111360__(2);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_111360__(1);



var ConnectionError = {
	disconnected: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

ConnectionError.isRetriable = function(err) {
	if (!err.statusCode || !err.code || err.statusCode >= 500) {
		return true;
	}
	var retriable = false;
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].valuesArray(ConnectionError).forEach(function(connErr) {
		if (connErr.code && connErr.code == err.code) {
			retriable = true;
		}
	});
	return retriable;
};

/* harmony default export */ __webpack_exports__["a"] = (ConnectionError);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_113345__) {

"use strict";

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_113345__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_113345__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_113345__(1);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_113345__(6);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var multicaster = __nested_webpack_require_113345__(22);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_113345__(5);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_113345__(2);

// CONCATENATED MODULE: ./browser/lib/util/base64.js
/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

/* harmony default export */ var base64 = (Base64);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/hmac-sha256.js
var hmac_sha256 = __nested_webpack_require_113345__(38);
var hmac_sha256_default = /*#__PURE__*/__nested_webpack_require_113345__.n(hmac_sha256);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/enc-base64.js
var enc_base64 = __nested_webpack_require_113345__(18);

// CONCATENATED MODULE: ./common/lib/client/auth.js











var auth_Auth = (function() {
	var MAX_TOKEN_LENGTH = Math.pow(2, 17);
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }
	function normaliseAuthcallbackError(err) {
		/* A client auth callback may give errors in any number of formats; normalise to an errorinfo */
		if(!utils["a" /* default */].isErrorInfo(err)) {
			return new errorinfo["a" /* default */](utils["a" /* default */].inspectError(err), err.code || 40170, err.statusCode || 401);
		}
		/* network errors will not have an inherent error code */
		if(!err.code) {
			if(err.statusCode === 403) {
				err.code = 40300;
			} else {
				err.code = 40170;
				/* normalise statusCode to 401 per RSA4e */
				err.statusCode = 401;
			}
		}
		return err;
	}

	var hmac, toBase64;
	if(platform_browser["a" /* default */].createHmac) {
		toBase64 = function(str) { return (Buffer.from(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = platform_browser["a" /* default */].createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = base64.encode;
		hmac = function(text, key) {
			return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = Object.create(null);
		var keys = utils["a" /* default */].keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	/* RSA4a */
	function noWayToRenew(options) {
		return !options.key &&
			!options.authCallback &&
			!options.authUrl;
	}

	var trId = 0;
	function getTokenRequestId() {
		return trId++;
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};
		/* The id of the current token request if one is in progress, else null */
		this.currentTokenRequestId = null;
		this.waitingForTokenRequest = null;

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			if(noWayToRenew(options)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(!options.key) {
				var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new errorinfo["a" /* default */](msg, 40160, 401);
			}
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback) {
			if(this.client.options.promises) {
				return utils["a" /* default */].promisify(this, 'authorize', arguments);
			}
			callback = noop;
		}
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.authOptions.key !== authOptions.key)) {
			throw new errorinfo["a" /* default */]('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(utils["a" /* default */].isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				if(self.client.connection) {
					/* We interpret RSA4d as including requests made by a client lib to
					 * authenticate triggered by an explicit authorize() or an AUTH received from
					 * ably, not just connect-sequence-triggered token fetches */
					self.client.connection.connectionManager.actOnErrorFromAuthorize(err);
				}
				callback(err);
				return;
			}

			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		logger["a" /* default */].deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'requestToken', arguments);
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);
		callback = callback || noop;

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			tokenRequestCallback = function(params, cb) {
				var authHeaders = utils["a" /* default */].mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
					usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
				if(!usePost) {
					/* Combine authParams with any qs params given in the authUrl */
					var queryIdx = authOptions.authUrl.indexOf('?');
					if(queryIdx > -1) {
						var providedQsParams = utils["a" /* default */].parseQueryString(authOptions.authUrl.slice(queryIdx));
						authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
						/* In case of conflict, authParams take precedence over qs params in the authUrl */
						authOptions.authParams = utils["a" /* default */].mixin(providedQsParams, authOptions.authParams);
					}
				}
				/* RSA8c2 */
				var authParams = utils["a" /* default */].mixin({}, authOptions.authParams || {}, params);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					var contentType;
					if (err) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + utils["a" /* default */].inspectError(err));
					} else {
						contentType = headers['content-type'];
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + utils["a" /* default */].inspectBody(body));
					}
					if(err || unpacked) return cb(err, body);
					if(bufferutils["a" /* default */].isBuffer(body)) body = body.toString();
					if(!contentType) {
						cb(new errorinfo["a" /* default */]('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
					if(!json && !text) {
						cb(new errorinfo["a" /* default */]('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain, application/jwt or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKEN_LENGTH) {
							cb(new errorinfo["a" /* default */]('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new errorinfo["a" /* default */]('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body, contentType);
				};
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams) + '; method: ' + (usePost ? 'POST' : 'GET'));
				if(usePost) {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = utils["a" /* default */].toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					http["a" /* default */].postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					http["a" /* default */].getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			callback(new errorinfo["a" /* default */](msg, 40171, 403));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				path = '/keys/' + keyName + '/requestToken',
				tokenUri = function(host) { return client.baseUri(host) + path; };

			var requestHeaders = utils["a" /* default */].defaultPostHeaders();
			if(authOptions.requestHeaders) utils["a" /* default */].mixin(requestHeaders, authOptions.requestHeaders);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = JSON.stringify(signedTokenParams);
			http["a" /* default */].post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + utils["a" /* default */].inspectError(err));
				callback(normaliseAuthcallbackError(err));
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length === 0) {
					callback(new errorinfo["a" /* default */]('Token string is empty', 40170, 401));
				} else if(tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
					callback(new errorinfo["a" /* default */]('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else if(tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
					/* common failure mode with poorly-implemented authCallbacks */
					callback(new errorinfo["a" /* default */]('Token string was literal null/undefined', 40170, 401));
				} else if((tokenRequestOrDetails[0] === '{') && !(contentType && contentType.indexOf('application/jwt') > -1)) {
					callback(new errorinfo["a" /* default */]('Token was double-encoded; make sure you\'re not JSON-encoding an already encoded token request or details', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
				callback(new errorinfo["a" /* default */]('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + utils["a" /* default */].inspectError(err));
					callback(normaliseAuthcallbackError(err));
					return;
				}
				if(!unpacked) tokenResponse = JSON.parse(tokenResponse);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'createTokenRequest', arguments);
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new errorinfo["a" /* default */]('No key specified', 40101, 403));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new errorinfo["a" /* default */]('Invalid key specified', 40101, 403));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new errorinfo["a" /* default */]('clientId cant be an empty string', 40012, 400));
			return;
		}

		if('capability' in tokenParams) {
			tokenParams.capability = c14n(tokenParams.capability);
		}

		var request = utils["a" /* default */].mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability || '',
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
			this.client.time(callback);
		} else {
			callback(null, this.getTimestampUsingOffset());
		}
	};

	Auth.prototype.getTimestampUsingOffset = function() {
		return utils["a" /* default */].now() + (this.client.serverTimeOffset || 0);
	};

	Auth.prototype.isTimeOffsetSet = function() {
		return this.client.serverTimeOffset !== null;
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	/* @param forceSupersede: force a new token request even if there's one in
	 * progress, making all pending callbacks wait for the new one */
	Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
		var self = this,
			token = this.tokenDetails;

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				/* 403 to trigger a permanently failed client - RSA15c */
				callback(new errorinfo["a" /* default */]('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
				return;
			}
			/* RSA4b1 -- if we have a server time offset set already, we can
			 * autoremove expired tokens. Else just use the cached token. If it is
			 * expired Ably will tell us and we'll discard it then. */
			if(!this.isTimeOffsetSet() || !token.expires || (token.expires >= this.getTimestampUsingOffset())) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
				callback(null, token);
				return;
			}
			/* expired, so remove and fallthrough to getting a new one */
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
			this.tokenDetails = null;
		}

		(this.waitingForTokenRequest || (this.waitingForTokenRequest = Object(multicaster["a" /* default */])())).push(callback);
		if(this.currentTokenRequestId !== null && !forceSupersede) {
			return;
		}

		/* Request a new token */
		var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
		this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
			if(self.currentTokenRequestId > tokenRequestId) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
				return;
			}
			self.currentTokenRequestId = null;
			var callbacks = self.waitingForTokenRequest || noop;
			self.waitingForTokenRequest = null;
			if(err) {
				callbacks(err);
				return;
			}
			callbacks(null, (self.tokenDetails = tokenResponse));
		});
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new errorinfo["a" /* default */](msg, 40102, 401);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			(this.clientId !== '*') &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

/* harmony default export */ var auth = __webpack_exports__["a"] = (auth_Auth);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_154733__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_154733__(1);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_154733__(8);
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_154733__(20);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_154733__(0);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_154733__(4);
/* harmony import */ var _connectionerror__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_154733__(13);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_154733__(14);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_154733__(2);









var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(_client_auth__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].isTokenErr(err)) return false;
			if(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.ERROR, error: err})];
		} else {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(CometTransport, _transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'starting');
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getHost(options, params.host);
		var port = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			if(self.isDisposed) {
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]('Request cancelled', 80003, 400);
				}
				self.recvRequest = null;
				/* Connect request may complete without a emitting 'data' event since that is not
				 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
				if(!preconnected && !err) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onActivity();
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.isDisposed) {
			this.isDisposed = true;
			if(this.recvRequest) {
				_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', _connectionerror__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].disconnected);
			var self = this;
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.isDisposed) {
			return;
		}

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) _util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
			self.sendRequest = null;

			/* the result of the request, even if a nack, is usually a protocol response
			 * contained in the data. An err is anomolous, and indicates some issue with the
			 * network,transport, or connection */
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}

			if(data) {
				self.onData(data);
			}

			if(self.pendingItems) {
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			/* A request completing must be considered activity, as realtime sends
			 * heartbeats every 15s since a request began, not every 15s absolutely */
			self.onActivity();
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromDeserialized(items[i]));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

/* harmony default export */ __webpack_exports__["a"] = (CometTransport);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_169550__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_169550__(1);


var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no global object,
	 * will throw on accessing a property of undefined) */
	try {
		global.sessionStorage.setItem(test, test);
		global.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		global.localStorage.setItem(test, test);
		global.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? global.sessionStorage : global.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

/* harmony default export */ __webpack_exports__["a"] = (WebStorage);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_169550__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_172673__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_172673__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_176709__) {

"use strict";
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_176709__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_176709__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_176709__(28);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_176709__(3);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_176709__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_176709__(5);







var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray) {
		generateRandom = platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray;
	} else if(typeof Uint32Array !== 'undefined' && platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues(nativeArray, function(err) {
				callback(err, platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505,0x05000000], 5),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606,0x06060000], 6),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707,0x07070700], 7),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808,0x08080808], 8),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909,0x09090909,0x09000000], 9),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
		} else {
			key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key);
		if(iv) {
			this.iv = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(plaintext);
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(ciphertext);
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

/* harmony default export */ __webpack_exports__["a"] = (Crypto);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_191402__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_191402__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_191402__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_191402__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_191402__(0);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_191402__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_191402__(2);







var Transport = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var closeMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.CLOSE});
	var disconnectMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionSerial, connectionId, connectionDetails
	 * sync             connectionSerial, connectionId
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.isDisposed = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Transport, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(message) + '; connectionId = ' + this.connectionManager.connectionId);
		}
		this.onActivity();

		switch(message.action) {
		case actions.HEARTBEAT:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionId, message);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' + this.connectionManager.connectionId + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.onActivity();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onFatalError()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onClose()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.dispose()', '');
		this.isDisposed = true;
		this.off();
	};

	Transport.prototype.onActivity = function() {
		if(!this.maxIdleInterval) { return; }
		this.lastActivity = this.connectionManager.lastActivity = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
		this.setIdleTimer(this.maxIdleInterval + 100);
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"](msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 100);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

/* harmony default export */ __webpack_exports__["a"] = (Transport);


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionStateChange);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_202483__) {

"use strict";
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_202483__(0);


var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

/* harmony default export */ __webpack_exports__["a"] = (Multicaster);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_203423__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_203423__(1);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_203423__(3);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_203423__(4);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_203423__(0);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_203423__(6);






var ErrorReporter = (function() {
	function ErrorReporter() {}

	var levels = ErrorReporter.levels = [
		'fatal',
		'error',
		'warning',
		'info',
		'debug'
	];

	/* (level: typeof ErrorReporter.levels[number], message: string, fingerprint?: string, tags?: {[key: string]: string}): void */
	ErrorReporter.report = function(level, message, fingerprint, tags) {
		var eventId = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].randomHexString(16);

		var event = {
			event_id: eventId,
			tags: _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin({
				ablyAgent: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].agent
			}, tags),
			platform: 'javascript',
			level: level,
			release: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].version,
			fingerprint: fingerprint && [ fingerprint ],
			message: message,
			request: {
				headers: {
					'User-Agent': platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].userAgent
				},
				url: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].currentUrl
			}
		};

		_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter: ' + message);
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].postUri(null, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingUrl, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
			_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter resulted in: ' +
				(err ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err) : _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectBody(res))
			);
		});
	};

	return ErrorReporter;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorReporter);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		var keys = []; // TODO: use Object.keys when we are able to transpile to ES3
		for (var key in value) {
			if (!value.hasOwnProperty(key)) continue;
			keys.push(key);
		}
		return keys.filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

/* harmony default export */ __webpack_exports__["a"] = (msgpack);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_225303__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_225303__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_225303__(1);
/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_225303__(34);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_225303__(4);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_225303__(3);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_225303__(7);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_225303__(26);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_225303__(0);
/* harmony import */ var _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_225303__(21);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_225303__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_225303__(2);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_225303__(14);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_225303__(6);
/* harmony import */ var _types_message__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_225303__(9);
/* harmony import */ var _util_multicaster__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_225303__(22);
/* harmony import */ var _util_errorreporter__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_225303__(23);
/* harmony import */ var platform_webstorage__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_225303__(16);
/* harmony import */ var platform_transports__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_225303__(41);
/* harmony import */ var _websockettransport__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_225303__(40);




















var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get);
	var haveSessionStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession);
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var PendingMessage = _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, a.shortName) >
		   _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';

		this.connectionSerial = undefined;
		this.timeSerial = undefined;
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.timeSerial !== undefined) {
					params.timeSerial = this.timeSerial;
				} else if(this.connectionSerial !== undefined) {
					params.connectionSerial = this.connectionSerial;
				}
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					var recoverSerial = match[1];
					if(isNaN(recoverSerial)) {
						params.timeSerial = recoverSerial;
					} else {
						params.connectionSerial = recoverSerial;
					}
				}
				break;
			default:
		}
		if(options.clientId !== undefined) {
			params.clientId = options.clientId;
		}
		if(options.echoMessages === false) {
			params.echo = 'false';
		}
		if(this.format !== undefined) {
			params.format = this.format;
		}
		if(this.stream !== undefined) {
			params.stream = this.stream;
		}
		if(this.heartbeats !== undefined) {
			params.heartbeats = this.heartbeats;
		}
		params.v = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].apiVersion;
		params.agent = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].agent;
		if(options.transportParams !== undefined) {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(params, options.transportParams);
		}
		return params;
	};

	TransportParams.prototype.toString = function() {
		var result = '[mode=' + this.mode;
		if(this.host) { result += (',host=' + this.host); }
		if(this.connectionKey) { result += (',connectionKey=' + this.connectionKey); }
		if(this.connectionSerial !== undefined) { result += (',connectionSerial=' + this.connectionSerial); }
		if(this.timeSerial) { result += (',timeSerial=' + this.timeSerial); }
		if(this.format) { result += (',format=' + this.format); }
		result += ']';

		return result;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new _messagequeue__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]();
		this.msgSerial = 0;
		this.connectionDetails = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.timeSerial = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect((options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseTransportOrder, this.transports)[0];
		this.upgradeTransports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(this.transports, _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports);
		this.transportPreference = null;

		this.httpHosts = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;
		this.mostRecentMsg = null;
		this.forceFallbackHost = false;
		this.connectCounter = 0;

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports) + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
					self.requestState({state: 'closing'});
				});
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser online event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser offline event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(ConnectionManager, _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	Object(_websockettransport__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(ConnectionManager);
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(platform_transports__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], function (initFn) {
		initFn(ConnectionManager);
	});

	ConnectionManager.prototype.createTransportParams = function(host, mode) {
		var params = new TransportParams(this.options, host, mode, this.connectionKey);
		if(this.timeSerial) {
			params.timeSerial = this.timeSerial;
		} else if(this.connectionSerial !== undefined) {
			params.connectionSerial = this.connectionSerial;
		}
		return params;
	};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			var transportParams = self.createTransportParams(null, mode);
			if(mode === 'recover') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + self.options.recover);
				var match = self.options.recover.split(':');
				if(match && match[2]) {
					self.msgSerial = match[2];
				}
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
			}
			callback(transportParams);
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(_client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(wrappedErr.error) && !(self.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(self.errorReason))) {
					self.errorReason = wrappedErr.error;
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					if(!_transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].isRetriable(wrappedErr.error)) {
						/* Error received from the server that does not call for trying a fallback host, eg a rate limit */
						self.notifyState({state: self.states.connecting.failState, error: wrappedErr.error});
						callback(true);
					} else {
						/* Error with that transport only; continue trying other fallback hosts */
						callback(false);
					}
				}
				return;
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionId, connectionDetails, connectionPosition) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
				}
			} else {
				self.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param error
	 * @param transport
	 * @param connectionId
	 * @param connectionDetails
	 * @param connectedMessage
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connection position. (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				syncPosition = connectionReset ? upgradeConnectionPosition : self;

			if(connectionReset) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connection position from ' + (self.timeSerial || self.connectionSerial) + ' to ' + (syncPosition.timeSerial || syncPosition.connectionSerial) + '; upgrade error was ' + error);
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, syncPosition, function(syncErr, connectionId, postSyncPosition) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionId, connectionDetails, postSyncPosition);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionId the id of the new active connection
	 * @param connectionDetails the details of the new active connection
	 * @param connectionPosition the position at the point activation; either {connectionSerial: <serial>} or {timeSerial: <serial>}
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionId) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		}
		if(connectionDetails) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
		}
		if(connectionPosition) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'serial =  ' + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
		}

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](transport);
		this.host = transport.params.host;

		var connectionKey = connectionDetails.connectionKey;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			if(existingActiveProtocol.transport === transport) {
				var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-previously-active');
			} else {
				existingActiveProtocol.finish();
			}
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(pendingTransport) {
			if(pendingTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-pending');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			} else {
				pendingTransport.disconnect();
			}
		});
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(proposedTransport) {
			if(proposedTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-proposed');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.proposedTransports, transport);
			} else {
				proposedTransport.dispose();
			}
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport),
			wasProposed = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
			clearTimeout(this.channelResumeCheckTimer);
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {

			/* If we're disconnected with a 5xx we need to try fallback hosts
			 * (RTN14d), but (a) due to how the upgrade sequence works, the
			 * host/transport selection sequence only cares about getting to
			 * `preconnect` (eg establishing a websocket) getting a `disconnected`
			 * protocol message afterwards is too late; and (b) host retry only
			 * applies to connectBase unless the stored preference transport doesn't
			 * work. We solve this by unpersisting the transport preference and
			 * setting an instance variable to force fallback hosts to be used (if
			 * any) here. Bit of a kludge, but no real better alternatives without
			 * rewriting the entire thing */
			if(state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
				this.unpersistTransportPreference();
				this.forceFallbackHost = true;
				/* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
				this.notifyState({state: state, error: error, retryImmediately: true});
				return;
			}

			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			var newConnectionState = (state === 'failed' && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(error)) ? 'disconnected' : state;
			this.notifyState({state: newConnectionState, error: error});
			return;
		}

		if(wasActive && (state === 'disconnected') && (this.state !== this.states.synchronizing)) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens). (If we were in the
			* synchronizing state, then that's fine, the old transport just got its
			* disconnected before the new one got the sync -- ignore it and keep
			* waiting for the sync. If it fails we have a separate sync timer that
			* will expire). */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey
		});

		if(requestedSyncPosition.timeSerial) {
			syncMessage.timeSerial = requestedSyncPosition.timeSerial;
		} else if(requestedSyncPosition.connectionSerial !== undefined) {
			syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
		}
		transport.send(syncMessage);

		transport.once('sync', function(connectionId, syncPosition) {
			clearTimeout(timeout);
			callback(null, connectionId, syncPosition);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state,
		 * and resetting the connectionSerial position */
		var self = this;
		/* If no previous connectionId, don't reset the msgSerial as it may have
		 * been set by recover data (unless the recover failed) */
		var prevConnId = this.connectionid,
			connIdChanged = prevConnId && (prevConnId !== connectionId),
			recoverFailure = !prevConnId && hasConnectionError;
		if(connIdChanged || recoverFailure)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
			this.msgSerial = 0;
		}
		/* but do need to reattach channels, for channels that were previously in
		 * the attached state even though the connection mode was 'clean' due to a
		 * freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else if(this.options.checkChannelsOnResume) {
			/* For attached channels, set the attached msg indicator variable to false,
			 * wait 30s, and check we got an attached for each one.
			 * 30s was chosen to be 5s longer than the transport idle timeout expire
			 * time, in an attempt to avoid false positives due to a transport
			 * silently failing immediately after a resume */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Same connectionId; checkChannelsOnResume is enabled');
			clearTimeout(this.channelResumeCheckTimer);
			this.realtime.channels.resetAttachedMsgIndicators();
			this.channelResumeCheckTimer = setTimeout(function() {
				self.realtime.channels.checkAttachedMsgIndicators(connectionId);
			}, 30000);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
		var forceResetMessageSerial = connIdChanged || !prevConnId;
		this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.clearConnectionSerial();
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	/* force: set the connectionSerial even if it's less than the current
	 * connectionSerial. Used for new connections.
	 * Returns true iff the message was rejected as a duplicate. */
	ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
		var timeSerial = connectionPosition.timeSerial,
			connectionSerial = connectionPosition.connectionSerial;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.setConnectionSerial()', 'Updating connection serial; serial = ' + connectionSerial + '; timeSerial = ' + timeSerial + '; force = ' + force + '; previous = ' + this.connectionSerial);
		if(timeSerial !== undefined) {
			if(timeSerial <= this.timeSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with timeSerial ' + timeSerial + ', but current timeSerial is ' + this.timeSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
			this.setRecoveryKey();
			return;
		}
		if(connectionSerial !== undefined) {
			if(connectionSerial <= this.connectionSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.serial = this.connectionSerial = connectionSerial;
			this.setRecoveryKey();
		}
	};

	ConnectionManager.prototype.clearConnectionSerial = function() {
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.timeSerial = this.timeSerial = undefined;
		this.clearRecoveryKey();
	};

	ConnectionManager.prototype.setRecoveryKey = function() {
		this.realtime.connection.recoveryKey = this.connectionKey + ':' + (this.timeSerial || this.connectionSerial) + ':' + this.msgSerial;
	};

	ConnectionManager.prototype.clearRecoveryKey = function() {
		this.realtime.connection.recoveryKey = null;
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage) {
			var recoveryKey = this.realtime.connection.recoveryKey;
			if(recoveryKey) {
				setSessionRecoverData({
					recoveryKey: recoveryKey,
					disconnectedAt: _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
					location: global.location,
					clientId: this.realtime.auth.clientId
				}, this.connectionStateTtl);
			}
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getError = function() {
		return this.errorReason || this.getStateError();
	};

	ConnectionManager.prototype.getStateError = function() {
		return _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR : _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason) : ''));
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced
		 *   authorize). If this.errorReason is already set (to a token error),
		 *   then there has been at least one previous attempt to connect that also
		 *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
		 *   before trying again */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
			 indicated.retryImmediately               ||
				(this.state === this.states.connecting &&
					indicated.error && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(indicated.error) &&
					!(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)))));

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, newState.retryDelay, (indicated.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, null, (request.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		/* The point of the connectCounter mechanism is to ensure that the
		 * connection procedure can be cancelled. We want disconnectAllTransports
		 * to be able to stop any in-progress connection, even before it gets to
		 * the stage of having a pending (or even a proposed) transport that it can
		 * dispose() of. So we check that it's still current after any async stage,
		 * up until the stage that is synchronous with instantiating a transport */
		var connectCount = ++this.connectCounter;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				self.connectImpl(transportParams, connectCount);
			});
		};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(false, authCb);
			}
		}
	};

	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams, connectCount);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (no available host)', 80003, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (and no more fallback hosts to try)', 80003, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			platform_http__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].checkConnectivity(function(err, connectivity) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (network unreachable)', 80003, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		if(this.forceFallbackHost && candidateHosts.length) {
			this.forceFallbackHost = false;
			tryFallbackHosts();
			return;
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = self.createTransportParams(transportParams.host, 'upgrade');
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		/* This will prevent any connection procedure in an async part of one of its early stages from continuing */
		this.connectCounter++;

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](err, 90000, 400));
			return;
		}
		if(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
			this.setRecoveryKey();
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	function bundleWith(dest, src, maxSize) {
		var action;
		if(dest.channel !== src.channel) {
			/* RTL6d3 */
			return false;
		}
		if((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
			/* RTL6d - can only bundle messages or presence */
			return false;
		}
		if(action !== src.action) {
			/* RTL6d4 */
			return false;
		}
		var kind = (action === actions.PRESENCE) ? 'presence' : 'messages',
			proposed = dest[kind].concat(src[kind]),
			size = _types_message__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].getMessagesSize(proposed);
		if(size > maxSize) {
			/* RTL6d1 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].allSame(proposed, 'clientId')) {
			/* RTL6d2 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrEvery(proposed, function(msg) {
			return !msg.id;
		})) {
			/* RTL6d7 */
			return false;
		}
		/* we're good to go! */
		dest[kind] = proposed;
		return true;
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		var maxSize = this.options.maxMessageSize;
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Object(_util_multicaster__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		var numQueued = this.queuedMessages.count();
		if(numQueued > 0) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
			this.queuedMessages.completeAllMessages(err);
		}
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing,
			notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			if(notControlMsg) {
				var suppressed = this.setConnectionSerial(message);
				if(suppressed) {
					return;
				}
				if(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isDuplicate(message, this.mostRecentMsg)) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onChannelMessage()', 'received message with different connectionSerial, but same message id as a previous; discarding; id = ' + message.id);
					return;
				}
				this.mostRecentMsg = message;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
				id = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].cheapRandStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					transport.off('heartbeat', onHeartbeat);
					clearTimeout(timer);
					var responseTime = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.on('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].remove(transportPreferenceName);
		}
	};

	/* This method is only used during connection attempts, so implements RSA4c1,
	 * RSA4c2, and RSA4d. In particular it is not invoked for
	 * serverside-triggered reauths or manual reauths, so RSA4c3 does not apply */
	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40171) {
			/* No way to reauth */
			this.notifyState({state: 'failed', error: err});
		} else if(err.statusCode === 403) {
			var msg = 'Client configured authentication provider returned 403; failing the connection';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
			this.notifyState({state: 'failed', error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 403, err)});
		} else {
			var msg = 'Client configured authentication provider request failed';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
			this.notifyState({state: this.state.failState, error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 401, err)});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		this.connectionDetails = connectionDetails;
		if(connectionDetails.maxMessageSize) {
			this.options.maxMessageSize = connectionDetails.maxMessageSize;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionManager);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_225303__(17)))

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_321878__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_321878__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_321878__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_321878__(0);




var MessageQueue = (function() {
	function MessageQueue() {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		this.messages = [];
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(MessageQueue, _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

/* harmony default export */ __webpack_exports__["a"] = (MessageQueue);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_324635__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_324635__(1);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_324635__(7);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_324635__(3);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_324635__(2);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_324635__(6);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_324635__(0);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_324635__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_324635__(5);
/* harmony import */ var _util_domevent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_324635__(35);










var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof global !== 'undefined' && global.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
	 * it is 'chunked'. So instead, decide that it is chunked when
	 * transfer-encoding is present or content-length is absent.  ('or' because
	 * when using http2 streaming, there's no transfer-encoding header, but can
	 * still deduce streaming from lack of content-length) */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& (xhr.getResponseHeader('transfer-encoding')
			|| !xhr.getResponseHeader('content-length'));
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrMap(headerPairs[i].split(':'), _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		params = params || {};
		params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.method = method ? method.toUpperCase() : (_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(body) ? 'GET' : 'POST');
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(XHRRequest, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new XHRRequest(uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(!err && body) {
				this.emit('data', body);
			}
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = this.method,
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/x-msgpack') === 0) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}

		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = true;
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					responseBody,
					/* Be liberal in what we accept; buggy auth servers may respond
					 * without the correct contenttype, but assume they're still
					 * responding with json */
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				if(json) {
					/* If we requested msgpack but server responded with json, then since
					 * we set the responseType expecting msgpack, the response will be
					 * an ArrayBuffer containing json */
					responseBody = (xhr.responseType === 'arraybuffer') ? platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].utf8Decode(xhr.response) : String(xhr.responseText);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				} else {
					responseBody = xhr.response;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error && _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(responseBody.error);
			if(!err) {
				err = new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Error response received from server: ' + statusCode + ' body was: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(responseBody), null, statusCode);
			}
			self.complete(err, responseBody, headers, unpacked, statusCode);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].xhrSupported) {
		if(typeof _util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"] === 'object') {
			_util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].addUnloadListener(clearPendingRequests);
		}
		if(typeof(platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]) !== 'undefined') {
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].supportsAuthHeaders = true;
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts, method);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
				var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].internetUpUrl;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getUri(null, upUrl, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

/* harmony default export */ __webpack_exports__["a"] = (XHRRequest);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_324635__(17)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_338023__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338023__(12), __nested_webpack_require_338023__(10), __nested_webpack_require_338023__(46), __nested_webpack_require_338023__(18), __nested_webpack_require_338023__(37), __nested_webpack_require_338023__(36), __nested_webpack_require_338023__(29), __nested_webpack_require_338023__(30), __nested_webpack_require_338023__(31), __nested_webpack_require_338023__(47), __nested_webpack_require_338023__(48));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_338536__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338536__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_342432__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_342432__(12), __nested_webpack_require_342432__(37), __nested_webpack_require_342432__(29));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_346322__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_346322__(12), __nested_webpack_require_346322__(30));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_375869__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_375869__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_376140__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_376140__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_376424__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_376424__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_376424__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_376424__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_376424__(0);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_376424__(26);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_376424__(2);







var Protocol = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;

	function Protocol(transport) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.transport = transport;
		this.messageQueue = new _messagequeue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Protocol, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Protocol.prototype.onAck = function(serial, count) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		if(!err) {
			err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.send()', 'sending msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

/* harmony default export */ __webpack_exports__["a"] = (Protocol);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_380416__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(global, 'unload', listener);
	};

	return DomEvent;
})();

/* harmony default export */ __webpack_exports__["a"] = (DomEvent);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_380416__(17)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_381626__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_381626__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_387076__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_387076__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_391051__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_391051__(12), __nested_webpack_require_391051__(36), __nested_webpack_require_391051__(29));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_391387__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_391387__(1);
/* harmony import */ var _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_391387__(15);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_391387__(3);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_391387__(7);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_391387__(6);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_391387__(2);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_391387__(4);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_391387__(0);









var JSONPTransport = function(connectionManager) {
	var noop = function() {};
	/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
	var _ = global._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var head = null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		_common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(JSONPTransport, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	JSONPTransport.isAvailable = function() {
		return platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].allowComet;
	};
	if(JSONPTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = JSONPTransport;
	}
	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported) {
		head = document.getElementsByTagName('head')[0];
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	global.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new Request(undefined, uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['Ably-Agent']) this.params.agent = headers['Ably-Agent'];
		}
		this.body = body;
		this.method = method;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(Request, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			method = this.method,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body) {
			params.body = body;
		}
		if(method && method !== 'get') {
			params.method = method;
		}

		var script = this.script = document.createElement('script');
		var src = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('JSONP script error (event: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && !platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request) {
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, rest && rest.options.timeouts, method);
			req.once('complete', callback);
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
			return req;
		};

		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
			var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (JSONPTransport);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_391387__(17)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_402742__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_402742__(3);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_402742__(1);
/* harmony import */ var _transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_402742__(20);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_402742__(4);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_402742__(0);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_402742__(8);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_402742__(2);








var WebSocketTransport = function(connectionManager) {
	var WebSocket = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].useProtocolHeartbeats;
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.wsHost = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHost(params.options, params.host, true);
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(WebSocketTransport, _transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		connectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		this.uri = uri + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].toQueryString(connectParams)
		return new WebSocket(this.uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getPort(options) + '/';
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(self.isDisposed) {
				return;
			}
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.onActivity(); });
				}
			} catch(e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		try {
			wsConnection.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].serialize(message, this.params.format));
		} catch (e) {
			var msg = 'Exception from ws connection when trying to send: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(e);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', msg);
			/* Don't try to request a disconnect, that'll just involve sending data
			 * down the websocket again. Just finish the transport. */
			this.finish('disconnected', new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 50000, 500));
		}
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].deserialize(data, this.format));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 80003, 400);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.dispose()', '');
		this.isDisposed = true;
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (WebSocketTransport);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_413003__) {

"use strict";

// EXTERNAL MODULE: ./browser/lib/transport/jsonptransport.js
var jsonptransport = __nested_webpack_require_413003__(39);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_413003__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_413003__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_413003__(3);

// EXTERNAL MODULE: ./common/lib/transport/comettransport.js
var comettransport = __nested_webpack_require_413003__(15);

// EXTERNAL MODULE: ./browser/lib/transport/xhrrequest.js
var xhrrequest = __nested_webpack_require_413003__(27);

// CONCATENATED MODULE: ./browser/lib/transport/xhrpollingtransport.js






var xhrpollingtransport_XHRPollingTransport = function(connectionManager) {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRPollingTransport, comettransport["a" /* default */]);

	XHRPollingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/xhrstreamingtransport.js






var xhrstreamingtransport_XHRStreamingTransport = function(connectionManager) {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRStreamingTransport, comettransport["a" /* default */]);

	XHRStreamingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].streamingSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/index.js




/* harmony default export */ var lib_transport = __webpack_exports__["a"] = ([
  jsonptransport["a" /* default */],
  xhrpollingtransport,
  xhrstreamingtransport
]);


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_417833__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__nested_webpack_require_417833__(43);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_417833__(17)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_420045__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_420045__(17), __nested_webpack_require_420045__(44)))

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 45 */
/***/ (function(module, exports) {



/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_432274__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_432274__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_436272__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_436272__(12), __nested_webpack_require_436272__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_437981__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437981__(12), __nested_webpack_require_437981__(18), __nested_webpack_require_437981__(49), __nested_webpack_require_437981__(30), __nested_webpack_require_437981__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_446491__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_446491__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_455833__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_455833__.r(__webpack_exports__);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_455833__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_455833__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_455833__(0);

// EXTERNAL MODULE: ./common/lib/util/defaults.js + 1 modules
var defaults = __nested_webpack_require_455833__(4);

// EXTERNAL MODULE: ./common/lib/client/auth.js + 1 modules
var auth = __nested_webpack_require_455833__(14);

// CONCATENATED MODULE: ./common/lib/types/devicedetails.js


var devicedetails_DeviceDetails = (function() {

	function DeviceDetails() {
		this.id = undefined;
		this.deviceSecret = undefined;
		this.platform = undefined;
		this.formFactor = undefined;
		this.clientId = undefined;
		this.metadata = undefined;
		this.deviceIdentityToken = undefined;
		this.push = {
			recipient: undefined,
			state: undefined,
			error: undefined
		};
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	DeviceDetails.prototype.toJSON = function() {
		return {
			id: this.id,
			deviceSecret: this.deviceSecret,
			platform: this.platform,
			formFactor: this.formFactor,
			clientId: this.clientId,
			metadata: this.metadata,
			deviceIdentityToken: this.deviceIdentityToken,
			push: {
				recipient: this.push.recipient,
				state: this.push.state,
				error: this.push.error
			}
		};
	};

	DeviceDetails.prototype.toString = function() {
		var result = '[DeviceDetails';
		if(this.id)
			result += '; id=' + this.id;
		if(this.platform)
			result += '; platform=' + this.platform;
		if(this.formFactor)
			result += '; formFactor=' + this.formFactor;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.metadata)
			result += '; metadata=' + this.metadata;
		if(this.deviceIdentityToken)
			result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
		if(this.push.recipient)
			result += '; push.recipient=' + JSON.stringify(this.push.recipient);
		if(this.push.state)
			result += '; push.state=' + this.push.state;
		if(this.push.error)
			result += '; push.error=' + JSON.stringify(this.push.error);
		if(this.push.metadata)
			result += '; push.metadata=' + this.push.metadata;
		result += ']';
		return result;
	};

	DeviceDetails.toRequestBody = utils["a" /* default */].encodeBody;

	DeviceDetails.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return DeviceDetails.fromValuesArray(body);
		} else {
			return DeviceDetails.fromValues(body);
		}
	};

	DeviceDetails.fromValues = function(values) {
		values.error = values.error && ErrorInfo.fromValues(values.error); 
		return utils["a" /* default */].mixin(new DeviceDetails(), values);
	};

	DeviceDetails.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);
		return result;
	};

	return DeviceDetails;
})();

/* harmony default export */ var devicedetails = (devicedetails_DeviceDetails);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_455833__(6);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_455833__(5);

// CONCATENATED MODULE: ./common/lib/client/resource.js







var resource_Resource = (function() {
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (http["a" /* default */].supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(utils["a" /* default */].mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, utils["a" /* default */].mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, outerHeaders, unpacked, outerStatusCode) {
			if(err && !body) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = utils["a" /* default */].decodeBody(body, format);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, outerHeaders, true, outerStatusCode);
				return;
			}

			var wrappedStatusCode = body.statusCode,
				response = body.response,
				wrappedHeaders = body.headers;

			if(wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
				/* handle wrapped errors */
				var wrappedErr = (response && response.error) || err;
				if(!wrappedErr) {
					wrappedErr = new Error("Error in unenveloping " + body);
					wrappedErr.statusCode = wrappedStatusCode;
				}
				callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
				return;
			}

			callback(err, response, wrappedHeaders, true, wrappedStatusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, method, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + utils["a" /* default */].inspectError(err));
			} else {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (bufferutils["a" /* default */].isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, null, origheaders, origparams, envelope, callback);
		};
	});

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, body, origheaders, origparams, envelope, callback);
		};
	});

	Resource['do'] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
		if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
			callback = logResponseHandler(callback, method, path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doRequest(headers, params) {
			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			var args = [rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && auth["a" /* default */].isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doRequest);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			}];
			if (!body) {
				args.splice(3, 1);
			}

			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						decodedBody = msgpack.decode(body);
					} catch (decodeErr) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + utils["a" /* default */].inspectError(decodeErr));
					}
				}
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}
			http["a" /* default */][method].apply(this, args);
		}

		withAuthDetails(rest, origheaders, origparams, callback, doRequest);
	};

	return Resource;
})();

/* harmony default export */ var client_resource = (resource_Resource);

// CONCATENATED MODULE: ./common/lib/client/paginatedresource.js





var paginatedresource_PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && utils["a" /* default */].parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		PaginatedResource.prototype[method] = function(params, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
				self.handlePage(err, body, headers, unpacked, statusCode, callback);
			});
		};
	})

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		PaginatedResource.prototype[method] = function(params, body, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
				if(callback) {
					self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
				}
			});
		};
	});

	function returnErrOnly(err, body, useHPR) {
		/* If using httpPaginatedResponse, errors from Ably are returned as part of
		 * the HPR, only do callback(err) for network errors etc. which don't
		 * return a body and/or have no ably-originated error code (non-numeric
		 * error codes originate from node) */
		return !(useHPR && (body || typeof err.code === 'number'));
	}

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + utils["a" /* default */].inspectError(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			/* If we got an error, the failure to parse the body is almost certainly
			 * due to that, so cb with that in preference to the parse error */
			callback(err || e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams) {
				this.first = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'first', []);
					}
					self.get(relParams.first, cb);
				};
			}
			if('current' in relParams) {
				this.current = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'current', []);
					}
					self.get(relParams.current, cb);
				};
			}
			this.next = function(cb) {
				if(!cb && self.resource.rest.options.promises) {
					return utils["a" /* default */].promisify(self, 'next', []);
				}
				if('next' in relParams) {
					self.get(relParams.next, cb);
				} else {
					cb(null, null);
				}
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		this.errorCode = err && err.code;
		this.errorMessage = err && err.message;
	}
	utils["a" /* default */].inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

/* harmony default export */ var paginatedresource = (paginatedresource_PaginatedResource);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_455833__(2);

// CONCATENATED MODULE: ./common/lib/types/pushchannelsubscription.js


var pushchannelsubscription_PushChannelSubscription = (function() {

	function PushChannelSubscription() {
		this.channel = undefined;
		this.deviceId = undefined;
		this.clientId = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PushChannelSubscription.prototype.toJSON = function() {
		return {
			channel: this.channel,
			deviceId: this.deviceId,
			clientId: this.clientId
		};
	};

	PushChannelSubscription.prototype.toString = function() {
		var result = '[PushChannelSubscription';
		if(this.channel)
			result += '; channel=' + this.channel;
		if(this.deviceId)
			result += '; deviceId=' + this.deviceId;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		result += ']';
		return result;
	};

	PushChannelSubscription.toRequestBody = utils["a" /* default */].encodeBody;

	PushChannelSubscription.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return PushChannelSubscription.fromValuesArray(body);
		} else {
			return PushChannelSubscription.fromValues(body);
		}
	};

	PushChannelSubscription.fromValues = function(values) {
		return utils["a" /* default */].mixin(new PushChannelSubscription(), values);
	};

	PushChannelSubscription.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);
		return result;
	};

	return PushChannelSubscription;
})();

/* harmony default export */ var pushchannelsubscription = (pushchannelsubscription_PushChannelSubscription);

// CONCATENATED MODULE: ./common/lib/client/push.js








var push_Push = (function() {
	var noop = function() {};

	function Push(rest) {
		this.rest = rest;
		this.admin = new Admin(rest);
	}

	function Admin(rest) {
		this.rest = rest;
		this.deviceRegistrations = new DeviceRegistrations(rest);
		this.channelSubscriptions = new ChannelSubscriptions(rest);
	}

	Admin.prototype.publish = function(recipient, payload, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = utils["a" /* default */].mixin({recipient: recipient}, payload),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/publish', requestBody, headers, params, false, function(err) { callback(err); });
	};

	function DeviceRegistrations(rest) {
		this.rest = rest;
	}

	DeviceRegistrations.prototype.save = function(device, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = devicedetails.fromValues(device),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		client_resource.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/deviceRegistrations', headers, envelope, function(body, headers, unpacked) {
			return devicedetails.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			params = {},
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'remove', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, false, function(err) { callback(err); });
	};

	DeviceRegistrations.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations', headers, params, false, function(err) { callback(err); });
	};

	function ChannelSubscriptions(rest) {
		this.rest = rest;
	}

	ChannelSubscriptions.prototype.save = function(subscription, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = pushchannelsubscription.fromValues(subscription),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/channelSubscriptions', requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
		});
	};

	ChannelSubscriptions.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/channelSubscriptions', headers, envelope, function(body, headers, unpacked) {
			return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/channelSubscriptions', headers, params, false, function(err) { callback(err); });
	};

	/* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
	ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;

	ChannelSubscriptions.prototype.listChannels = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'listChannels', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		(new paginatedresource(rest, '/push/channels', headers, envelope, function(body, headers, unpacked) {
			var f = !unpacked && format;

			if(f) {
				body = utils["a" /* default */].decodeBody(body, format);
			}

			for(var i = 0; i < body.length; i++) {
				body[i] = String(body[i]);
			}
			return body;
		})).get(params, callback);
	};

	return Push;
})();

/* harmony default export */ var push = (push_Push);

// EXTERNAL MODULE: ./common/lib/util/eventemitter.js
var eventemitter = __nested_webpack_require_455833__(7);

// EXTERNAL MODULE: ./common/lib/types/presencemessage.js
var presencemessage = __nested_webpack_require_455833__(11);

// CONCATENATED MODULE: ./common/lib/client/presence.js







var presence_Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	utils["a" /* default */].inherits(Presence, eventemitter["a" /* default */]);

	Presence.prototype.get = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'get', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, '_history', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this.channel;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

/* harmony default export */ var client_presence = (presence_Presence);

// EXTERNAL MODULE: ./browser/lib/util/crypto.js
var util_crypto = __nested_webpack_require_455833__(19);

// EXTERNAL MODULE: ./common/lib/types/message.js
var types_message = __nested_webpack_require_455833__(9);

// CONCATENATED MODULE: ./common/lib/client/channel.js











var channel_Channel = (function() {
	function noop() {}
	var MSG_ID_ENTROPY_BYTES = 9;

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Channel()', 'started; name = ' + name);
		eventemitter["a" /* default */].call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new client_presence(this);
		this.setOptions(channelOptions);
	}
	utils["a" /* default */].inherits(Channel, eventemitter["a" /* default */]);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!util_crypto["a" /* default */]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = util_crypto["a" /* default */].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new paginatedresource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return types_message["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	function allEmptyIds(messages) {
		return utils["a" /* default */].arrEvery(messages, function(message) {
			return !message.id;
		});
	}

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			first = arguments[0],
			second = arguments[1],
			callback = arguments[argCount - 1],
			messages,
			params,
			self = this;

		if(typeof(callback) !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(typeof first === 'string' || first === null) {
			/* (name, data, ...) */
			messages = [types_message["a" /* default */].fromValues({name: first, data: second})];
			params = arguments[2];
		} else if(utils["a" /* default */].isObject(first)) {
			messages = [types_message["a" /* default */].fromValues(first)];
			params = arguments[1];
		} else if(utils["a" /* default */].isArray(first)) {
			messages = types_message["a" /* default */].fromValuesArray(first);
			params = arguments[1];
		} else {
			throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		}

		if(typeof params !== 'object' || !params) {
			/* No params supplied (so after-message argument is just the callback or undefined) */
			params = {};
		}

		var rest = this.rest,
			options = rest.options,
			format = options.useBinaryProtocol ? 'msgpack' : 'json',
			idempotentRestPublishing = rest.options.idempotentRestPublishing,
			headers = utils["a" /* default */].defaultPostHeaders(format);

		if(options.headers)
			utils["a" /* default */].mixin(headers, options.headers);

		if(idempotentRestPublishing && allEmptyIds(messages)) {
			var msgIdBase = utils["a" /* default */].randomString(MSG_ID_ENTROPY_BYTES);
			utils["a" /* default */].arrForEach(messages, function(message, index) {
				message.id = msgIdBase + ':' + index.toString();
			});
		}

		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if(err) {
				callback(err);
				return;
			}

			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages),
				maxMessageSize = options.maxMessageSize;
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}

			self._publish(types_message["a" /* default */].serialize(messages, format), headers, params, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, params, callback) {
		client_resource.post(this.rest, this.basePath + '/messages', requestBody, headers, params, false, callback);
	};

	return Channel;
})();

/* harmony default export */ var client_channel = (channel_Channel);

// CONCATENATED MODULE: ./common/lib/types/stats.js


var stats_Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.uncompressedData = (values && values.uncompressedData) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function MessageCategory(values) {
		var self = this;
		MessageCount.call(this, values);
		this.category = undefined;
		if (values && values.category) {
			this.category = { };
			utils["a" /* default */].forInOwnNonNullProps(values.category, function(prop) {
				self.category[prop] = new MessageCount(values.category[prop]);
			});
		}
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCategory(values && values.messages);
		this.presence = new MessageCategory(values && values.presence);
		this.all = new MessageCategory(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.httpEvent = new MessageTypes(values && values.httpEvent);
		this.push = new MessageTypes(values && values.push);
		this.all = new MessageTypes(values && values.all);
	}

	function MessageDirections(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
	}

	function XchgMessages(values) {
		this.all           = new MessageTypes(values && values.all);
		this.producerPaid  = new MessageDirections(values && values.producerPaid);
		this.consumerPaid  = new MessageDirections(values && values.consumerPaid);
	}

	function PushStats(values) {
		this.messages = (values && values.messages) || 0;
		var notifications = values && values.notifications;
		this.notifications = {
			invalid: notifications && notifications.invalid || 0,
			attempted: notifications && notifications.attempted || 0,
			successful: notifications && notifications.successful || 0,
			failed: notifications && notifications.failed || 0
		};
		this.directPublishes = (values && values.directPublishes) || 0;
	}

	function ProcessedCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.skipped = (values && values.skipped) || 0;
		this.failed = (values && values.failed) || 0;
	}

	function ProcessedMessages(values) {
		var self = this;
		this.delta = undefined;
		if (values && values.delta) {
			this.delta = { };
			utils["a" /* default */].forInOwnNonNullProps(values.delta, function(prop) {
				self.delta[prop] = new ProcessedCount(values.delta[prop]);
			});
		}
	}

	function Stats(values) {
		MessageDirections.call(this, values);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.xchgProducer  = new XchgMessages(values && values.xchgProducer);
		this.xchgConsumer  = new XchgMessages(values && values.xchgConsumer);
		this.push          = new PushStats(values && values.pushStats);
		this.processed     = new ProcessedMessages(values && values.processed);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

/* harmony default export */ var stats = (stats_Stats);

// CONCATENATED MODULE: ./common/lib/client/rest.js












var rest_Rest = (function() {
	var noop = function() {};
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		options = defaults["a" /* default */].objectifyOptions(options);

		if(options.log) {
			logger["a" /* default */].setLog(options.log.level, options.log.handler);
		}
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + utils["a" /* default */].inspect(options));

		this.options = defaults["a" /* default */].normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Rest()', 'started; version = ' + defaults["a" /* default */].libstring);

		this.baseUri = this.authority = function(host) { return defaults["a" /* default */].getHttpScheme(options) + host + ':' + defaults["a" /* default */].getPort(options, false); };
		this._currentFallback = null;

		this.serverTimeOffset = null;
		this.auth = new auth["a" /* default */](this, options);
		this.channels = new Channels(this);
		this.push = new push(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'stats', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders(),
			format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;

		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);

		(new paginatedresource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'time', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders();
		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		http["a" /* default */].get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - utils["a" /* default */].now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var useBinary = this.options.useBinaryProtocol,
			encoder = useBinary ? msgpack.encode: JSON.stringify,
			decoder = useBinary ? msgpack.decode : JSON.parse,
			format = useBinary ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;
		params = params || {};
		method = method.toLowerCase();
		var headers = method == 'get' ? utils["a" /* default */].defaultGetHeaders(format) : utils["a" /* default */].defaultPostHeaders(format);

		if(callback === undefined) {
			if(this.options.promises) {
				return utils["a" /* default */].promisify(this, 'request', [method, path, params, body, customHeaders]);
			}
			callback = noop;
		}

		if(typeof body !== 'string') {
			body = encoder(body);
		}
		if(this.options.headers) {
			utils["a" /* default */].mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			utils["a" /* default */].mixin(headers, customHeaders);
		}
		var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return utils["a" /* default */].ensureArray(unpacked ? resbody : decoder(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		if(!utils["a" /* default */].arrIn(http["a" /* default */].methods, method)) {
			throw new errorinfo["a" /* default */]('Unsupported method ' + method, 40500, 405);
		}

		if(utils["a" /* default */].arrIn(http["a" /* default */].methodsWithBody, method)) {
			paginatedResource[method](params, body, callback);
		} else {
			paginatedResource[method](params, callback);
		}
	};

	Rest.prototype.setLog = function(logOptions) {
		logger["a" /* default */].setLog(logOptions.level, logOptions.handler);
	};

	function Channels(rest) {
		this.rest = rest;
		this.all = Object.create(null);
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		delete this.all[String(name)];
	};

	return Rest;
})();

rest_Rest.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new rest_Rest(options);
};

rest_Rest.Callbacks = rest_Rest;

/* harmony default export */ var client_rest = (rest_Rest);

// EXTERNAL MODULE: ./common/lib/transport/connectionmanager.js
var connectionmanager = __nested_webpack_require_455833__(25);

// EXTERNAL MODULE: ./common/lib/client/connectionstatechange.js
var connectionstatechange = __nested_webpack_require_455833__(21);

// CONCATENATED MODULE: ./common/lib/client/connection.js






var connection_Connection = (function() {
	function noop() {}

	/* public constructor */
	function Connection(ably, options) {
		eventemitter["a" /* default */].call(this);
		this.ably = ably;
		this.connectionManager = new connectionmanager["a" /* default */](ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.timeSerial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			utils["a" /* default */].nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			utils["a" /* default */].nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	utils["a" /* default */].inherits(Connection, eventemitter["a" /* default */]);

	Connection.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener, new connectionstatechange["a" /* default */](undefined, state));
	}

	Connection.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.ping()', '');
		if(!callback) {
			if(this.ably.options.promises) {
				return utils["a" /* default */].promisify(this, 'ping', arguments);
			}
			callback = noop;
		}
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

/* harmony default export */ var connection = (connection_Connection);

// EXTERNAL MODULE: ./common/lib/types/protocolmessage.js
var protocolmessage = __nested_webpack_require_455833__(8);

// EXTERNAL MODULE: ./common/lib/transport/connectionerror.js
var connectionerror = __nested_webpack_require_455833__(13);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var util_multicaster = __nested_webpack_require_455833__(22);

// CONCATENATED MODULE: ./common/lib/client/channelstatechange.js
var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

/* harmony default export */ var channelstatechange = (ChannelStateChange);

// CONCATENATED MODULE: ./common/lib/client/realtimepresence.js











var realtimepresence_RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymousOrWildcard(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		var clientId = realtime.auth.clientId;
		return (!clientId || (clientId === '*')) && realtime.connection.state === 'connected';
	}

	/* Callback is called only in the event of an error */
	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		client_presence.call(this, channel);
		this.syncComplete = false;
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new eventemitter["a" /* default */]();
		this.pendingPresence = [];
	}
	utils["a" /* default */].inherits(RealtimePresence, client_presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to enter a presence channel', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'enter', callback);
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to update presence data', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'update', callback);
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'enter', callback);
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'update', callback);
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, '_enterOrUpdateClient', [clientId, data, action]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  'channel = ' + channel.name + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));

		var presence = presencemessage["a" /* default */].fromValues({
			action : action,
			data   : data
		});
		if (clientId) {
			presence.clientId = clientId;
		}

		var self = this;
		presencemessage["a" /* default */].encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.attach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					err = new errorinfo["a" /* default */]('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		}
		return this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'leaveClient', [clientId, data]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = presencemessage["a" /* default */].fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new errorinfo["a" /* default */]('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(connectionerror["a" /* default */].failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1],
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', args);
			}
			callback = noop;
		}

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(errorinfo["a" /* default */].fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.properties.attachSerial;
			} else {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		client_presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = presencemessage["a" /* default */].fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized()) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(realtimechannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Object(util_multicaster["a" /* default */])();
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + utils["a" /* default */].inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new errorinfo["a" /* default */](msg, 91004, 400);
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new channelstatechange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, 'enter', reenterCb);
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		utils["a" /* default */].arrForEach(items, function(item) {
			var presence = presencemessage["a" /* default */].fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: utils["a" /* default */].now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		logger["a" /* default */].deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		logger["a" /* default */].deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var channel = this.channel;
		var self = this;

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(channel.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);
		channel.attach(callback);
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	function PresenceMap(presence) {
		eventemitter["a" /* default */].call(this);
		this.presence = presence;
		this.map = Object.create(null);
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	utils["a" /* default */].inherits(PresenceMap, eventemitter["a" /* default */]);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = utils["a" /* default */].copy(map);
			this.setInProgress(true);
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(utils["a" /* default */].valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.setInProgress(false);
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.setInProgress(false);
		this.residualMembers = null;
	};

	PresenceMap.prototype.setInProgress = function(inProgress) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
		this.syncInProgress = inProgress;
		this.presence.syncComplete = !inProgress;
	};

	return RealtimePresence;
})();

/* harmony default export */ var realtimepresence = (realtimepresence_RealtimePresence);

// CONCATENATED MODULE: ./common/lib/client/realtimechannel.js












var realtimechannel_RealtimeChannel = (function() {
	var actions = protocolmessage["a" /* default */].Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		client_channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new realtimepresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new eventemitter["a" /* default */]();
		this.syncChannelSerial = undefined;
		this.properties = {
			attachSerial: undefined
		};
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
		/* Temporary; only used for the checkChannelsOnResume option */
		this._attachedMsgIndicator = false;
		this._attachResume = false;
		this._decodingContext = {
			channelOptions: this.channelOptions,
			plugins: realtime.options.plugins || { },
			baseEncodedPreviousPayload: undefined
		};
		this._lastPayload = {
			messageId: null,
			protocolMessageChannelSerial: null,
			decodeFailureRecoveryInProgress: null
		};
		/* Only differences between this and the public event emitter is that this emits an
		 * update event for all ATTACHEDs, whether resumed or not */
		this._allChannelChanges = new eventemitter["a" /* default */]();
	}
	utils["a" /* default */].inherits(RealtimeChannel, client_channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		args = Array.prototype.slice.call(args);
		if(typeof args[0] === 'function') {
			args.unshift(null);
		}
		if(args[args.length - 1] == undefined) {
			args.pop();
		}
		return args;
	};

	RealtimeChannel.prototype.setOptions = function(options, callback) {
		if(!callback) {
			if (this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'setOptions', arguments);
			}

			callback = function(err){
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
				}
			};
		}
		var err = validateChannelOptions(options);
		if(err) {
			callback(err);
			return;
		}
		client_channel.prototype.setOptions.call(this, options);
		if (this._decodingContext)
			this._decodingContext.channelOptions = this.channelOptions;
		if(this._shouldReattachToSetOptions(options)) {
			/* This does not just do _attach(true, null, callback) because that would put us
			 * into the 'attaching' state until we receive the new attached, which is
			 * conceptually incorrect: we are still attached, we just have a pending request to
			 * change some channel params. Per RTL17 going into the attaching state would mean
			 * rejecting messages until we have confirmation that the options have changed,
			 * which would unnecessarily lose message continuity. */
			this.attachImpl();
			this._allChannelChanges.once(function(stateChange) {
				switch(this.event) {
					case 'update':
					case 'attached':
						callback(null);
						return;
					default:
						callback(stateChange.reason);
						return;
				}
			});
		} else {
			callback();
		}
	};

	function validateChannelOptions(options) {
		if(options && 'params' in options && !utils["a" /* default */].isObject(options.params)) {
			return new errorinfo["a" /* default */]('options.params must be an object', 40000, 400);
		}
		if(options && 'modes' in options){
			if(!utils["a" /* default */].isArray(options.modes)){
				return new errorinfo["a" /* default */]('options.modes must be an array', 40000, 400);
			}
			for(var i = 0; i < options.modes.length; i++){
				var currentMode = options.modes[i];
				if(!currentMode || typeof currentMode !== 'string' || !utils["a" /* default */].arrIn(protocolmessage["a" /* default */].channelModes, String.prototype.toUpperCase.call(currentMode))){
					return new errorinfo["a" /* default */]('Invalid channel mode: ' + currentMode, 40000, 400);
				}
			}
		}
	}

	RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
		return (this.state === 'attached' || this.state === 'attaching') && (options.params || options.modes);
	};

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getError());
			return;
		}
		if(argCount == 2) {
			if(utils["a" /* default */].isObject(messages))
				messages = [types_message["a" /* default */].fromValues(messages)];
			else if(utils["a" /* default */].isArray(messages))
				messages = types_message["a" /* default */].fromValuesArray(messages);
			else
				throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [types_message["a" /* default */].fromValues({name: arguments[0], data: arguments[1]})];
		}
		var self = this,
			maxMessageSize = this.realtime.options.maxMessageSize;
		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages);
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		var state = this.state;
		switch(state) {
			case 'failed':
			case 'suspended':
				callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError(state)));
				break;
			default:
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
				var msg = new protocolmessage["a" /* default */]();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'attach', arguments);
			}
			callback = function(err) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}
		if(flags) {
			logger["a" /* default */].deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
			/* If flags requested, always do a re-attach. TODO only do this if
			 * current mode differs from requested mode */
			this._requestedFlags = flags;
		} else if (this.state === 'attached') {
			callback();
			return;
		}

		this._attach(false, null, callback);
	};

	RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
		if(!callback) {
			callback = function(err) {
				if (err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}

		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}

		if (this.state !== 'attaching' || forceReattach) {
			this.requestState('attaching', attachReason);
		}

		this.once(function(stateChange) {
			switch(this.event) {
				case 'attached':
					callback();
					break;
				case 'detached':
				case 'suspended':
				case 'failed':
					callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
					break;
				case 'detaching':
					callback(new errorinfo["a" /* default */]('Attach request superseded by a subsequent detach request', 90000, 409));
					break;
			}
		});
	};

	RealtimeChannel.prototype.attachImpl = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = protocolmessage["a" /* default */].fromValues({action: actions.ATTACH, channel: this.name, params: this.channelOptions.params});
		if(this._requestedFlags) {
			attachMsg.encodeModesToFlags(this._requestedFlags);
		} else if(this.channelOptions.modes) {
			attachMsg.encodeModesToFlags(utils["a" /* default */].allToUpperCase(this.channelOptions.modes));
		}
		if(this._attachResume) {
			attachMsg.setFlag('ATTACH_RESUME');
		}
		if(this._lastPayload.decodeFailureRecoveryInProgress) {
			attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'detach', arguments);
			}
			callback = noop;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}
		switch(this.state) {
                        case 'suspended':
                                this.notifyState('detached');
                                callback();
                                break;
			case 'detached':
				callback();
				break;
			case 'failed':
				callback(new errorinfo["a" /* default */]('Unable to detach; channel state = failed', 90001, 400));
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'attached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
							break;
						case 'attaching':
							callback(new errorinfo["a" /* default */]('Detach request superseded by a subsequent attach request', 90000, 409));
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = protocolmessage["a" /* default */].fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(this.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);

		return this.attach(callback);
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new errorinfo["a" /* default */]("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getError();
		}

		/* send sync request */
		var syncMessage = protocolmessage["a" /* default */].fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = protocolmessage["a" /* default */].fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (utils["a" /* default */].isArray(presence) ?
				presencemessage["a" /* default */].fromValuesArray(presence) :
				[presencemessage["a" /* default */].fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this._attachedMsgIndicator = true;
			this.properties.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			this.params = message.params || {};
			var modesFromFlags = message.decodeModesFromFlags();
			this.modes = (modesFromFlags && utils["a" /* default */].allToLowerCase(modesFromFlags)) || undefined;
			var resumed = message.hasFlag('RESUMED');
			var hasPresence = message.hasFlag('HAS_PRESENCE');
			if(this.state === 'attached') {
				/* attached operations to change options set the inprogress mutex, but leave
				 * channel in the attached state */
				this.setInProgress(statechangeOp, false);
				if(!resumed) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(hasPresence);
				}
				var change = new channelstatechange(this.state, this.state, resumed, message.error);
				this._allChannelChanges.emit('update', change);
				if(!resumed || this.channelOptions.updateOnAttached) {
					this.emit('update', change);
				}
			} else if(this.state === 'detaching') {
				/* RTL5i: re-send DETACH and remain in the 'detaching' state */
				this.checkPendingState();
			} else {
				this.notifyState('attached', message.error, resumed, hasPresence);
			}
			break;

		case actions.DETACHED:
			var err = message.error ? errorinfo["a" /* default */].fromValues(message.error) : new errorinfo["a" /* default */]('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					presencemessage["a" /* default */].decode(presenceMsg, options);
				} catch (e) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:

			//RTL17
			if(this.state !== 'attached') {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
				return;
			}

			var messages = message.messages,
				firstMessage = messages[0],
				lastMessage = messages[messages.length - 1],
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			if(firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
				var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
				this._startDecodeFailureRecovery(new errorinfo["a" /* default */](msg, 40018, 400));
				break;
			}

			for(var i = 0; i < messages.length; i++) {
				var msg = messages[i];
				try {
					types_message["a" /* default */].decode(msg, this._decodingContext);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
					switch(e.code) {
						case 40018:
							/* decode failure */
							this._startDecodeFailureRecovery(e);
							return;
						case 40019:
							/* No vcdiff plugin passed in - no point recovering, give up */
						case 40021:
							/* Browser does not support deltas, similarly no point recovering */
							this.notifyState('failed', e);
							return;
					}
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this._lastPayload.messageId = lastMessage.id;
			this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', errorinfo["a" /* default */].fromValues(err));
			}
			break;

		default:
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(connectionerror["a" /* default */].unknownChannelErr);
		}
	};

	RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
		var self = this;
		if(!this._lastPayload.decodeFailureRecoveryInProgress) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
			this._lastPayload.decodeFailureRecoveryInProgress = true;
			this._attach(true, reason, function() {
				self._lastPayload.decodeFailureRecoveryInProgress = false;
			});
		}
	};

	RealtimeChannel.prototype.onAttached = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new channelstatechange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? logger["a" /* default */].LOG_ERROR : logger["a" /* default */].LOG_MAJOR;
		logger["a" /* default */].logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		if(state === 'attached') {
			this._attachResume = true;
		} else if(state === 'detaching' || state === 'failed') {
			this._attachResume = false;
		}

		this.state = state;
		this._allChannelChanges.emit(state, change);
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new errorinfo["a" /* default */]('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new errorinfo["a" /* default */]('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.properties.attachSerial) {
				callback(new errorinfo["a" /* default */]("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.properties.attachSerial;
		}

		client_channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener);
	}

	/* @returns null (if can safely be released) | ErrorInfo (if cannot) */
	RealtimeChannel.prototype.getReleaseErr = function() {
		var s = this.state;
		if(s === 'initialized' || s === 'detached' || s === 'failed') {
			return null;
		}
		return new errorinfo["a" /* default */]('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' + s, 90001, 400);
	}

	return RealtimeChannel;
})();

/* harmony default export */ var realtimechannel = (realtimechannel_RealtimeChannel);

// EXTERNAL MODULE: ./common/lib/util/errorreporter.js
var errorreporter = __nested_webpack_require_455833__(23);

// CONCATENATED MODULE: ./common/lib/client/realtime.js










var realtime_Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime()', '');
		client_rest.call(this, options);
		this.connection = new connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	utils["a" /* default */].inherits(Realtime, client_rest);

	Realtime.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		eventemitter["a" /* default */].call(this);
		this.realtime = realtime;
		this.all = Object.create(null);
		this.inProgress = Object.create(null);
		var self = this;
		realtime.connection.connectionManager.on('transport.active', function() {
			self.onTransportActive();
		});
	}
	utils["a" /* default */].inherits(Channels, eventemitter["a" /* default */]);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.attach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	Channels.prototype.resetAttachedMsgIndicators = function() {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached') {
			channel._attachedMsgIndicator = false;
			}
		}
	};

	Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached' && channel._attachedMsgIndicator === false) {
				var msg = '30s after a resume, found channel which has not received an attached; channelId = ' + channelId + '; connectionId = ' + connectionId;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.checkAttachedMsgIndicators()', msg);
				errorreporter["a" /* default */].report('error', msg, 'channel-no-attached-after-resume');
				channel.requestState('attaching');
			};
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(utils["a" /* default */].arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			if (channel._shouldReattachToSetOptions(channelOptions)) {
				throw new errorinfo["a" /* default */]("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 40000, 400);
			}
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			return;
		}
		var releaseErr = channel.getReleaseErr();
		if(releaseErr) {
			throw releaseErr;
		}
		delete this.all[name];
		delete this.inProgress[name];
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return utils["a" /* default */].arrEvery(utils["a" /* default */].valuesArray(this.inProgress, true), function(operations) {
			return !utils["a" /* default */].containsValue(operations, true);
		});
	};

	return Realtime;
})();

realtime_Realtime.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new realtime_Realtime(options);
};

realtime_Realtime.Callbacks = realtime_Realtime;

/* harmony default export */ var client_realtime = (realtime_Realtime);

// EXTERNAL MODULE: ./browser/lib/util/msgpack.js
var util_msgpack = __nested_webpack_require_455833__(24);

// CONCATENATED MODULE: ./common/lib/index.js














client_rest.Utils = utils["a" /* default */];
client_rest.BufferUtils = bufferutils["a" /* default */];
client_rest.Crypto = util_crypto["a" /* default */];
client_rest.Defaults = defaults["a" /* default */];
client_rest.Http = http["a" /* default */];
client_rest.Resource = client_resource;
client_rest.Message = types_message["a" /* default */];
client_rest.PresenceMessage = presencemessage["a" /* default */];

client_realtime.Utils = utils["a" /* default */];
client_realtime.BufferUtils = bufferutils["a" /* default */];
client_realtime.Crypto = util_crypto["a" /* default */];
client_realtime.Defaults = defaults["a" /* default */];
client_realtime.Http = http["a" /* default */];
client_realtime.Message = types_message["a" /* default */];
client_realtime.PresenceMessage = presencemessage["a" /* default */];
client_realtime.ProtocolMessage = protocolmessage["a" /* default */];
client_realtime.ConnectionManager = connectionmanager["a" /* default */];

/* harmony default export */ var lib = __webpack_exports__["default"] = ({
  Rest: client_rest,
  Realtime: client_realtime,
  msgpack: util_msgpack["a" /* default */]
});


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

function promisifyOptions(options) {
  if(typeof options == 'string') {
    options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running 
 * the build task. */
var Ably = __webpack_require__(/*! ./browser/static/ably-node */ "./node_modules/ably/browser/static/ably-commonjs.js");

var RestPromise = function(options) {
  return new Ably.Rest(promisifyOptions(options));
}
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function(options) {
  return new Ably.Realtime(promisifyOptions(options));
}
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./components/chatroom/chatComponents.module.css":
/*!*******************************************************!*\
  !*** ./components/chatroom/chatComponents.module.css ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element) {
                // These elements should always exist. If they do not,
                // this code should fail.
                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                var parentNode = anchorElement.parentNode// Normally <head>
                ;
                // Each style tag should be placed right before our
                // anchor. By inserting before and not after, we do not
                // need to track the last inserted element.
                parentNode.insertBefore(element, anchorElement);
            };
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    let p;
    for(p in a){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css",
      function () {
        content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".chatComponents_chatHolder__2E1AX {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatComponents_chatText__3MREs {\r\n  display: -moz-box;\r\n  display: flex;\r\n  -moz-box-orient: vertical;\r\n  -moz-box-direction: normal;\r\n       flex-direction: column;\r\n  -moz-box-align: start;\r\n       align-items: flex-start;\r\n  grid-gap: 1em;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: -webkit-calc(100vh - 40px - 100px - 100px - 100px);\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.chatComponents_form__3rFIK {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.chatComponents_textarea__2UuLy {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.chatComponents_button__3eZyM {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.chatComponents_button__3eZyM:hover {\r\n  background: -webkit-gradient(\r\n    linear,\r\n    left top, right top,\r\n    from(rgba(54, 55, 149, 1)),\r\n    color-stop(62%, rgba(0, 92, 151, 1)),\r\n    to(rgba(0, 125, 205, 1))\r\n  );\r\n  background: -webkit-linear-gradient(\r\n    left,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.chatComponents_button__3eZyM:disabled,\r\n.chatComponents_button__3eZyM:hover:disabled {\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.chatComponents_message__1dnoB {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  -moz-box-flex: 0;\r\n       flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n", "",{"version":3,"sources":["webpack://components/chatroom/chatComponents.module.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,6BAA6B;AAC/B;;AAEA;EACE,iBAAa;EAAb,aAAa;EACb,yBAAsB;EAAtB,0BAAsB;OAAtB,sBAAsB;EACtB,qBAAuB;OAAvB,uBAAuB;EACvB,aAAQ;EAAR,QAAQ;EACR,YAAY;EACZ,0DAAkD;EAAlD,kDAAkD;EAClD,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,gCAAgC;EAChC,0BAA0B;AAC5B;;AAEA;EACE,YAAY;EACZ,SAAS;EACT;wEACsE;EACtE,gBAAgB;AAClB;;AAEA;EACE,SAAS;EACT,YAAY;EACZ,iBAAiB;EACjB,gBAAgB;EAChB,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;AACzD;;AAEA;EACE;;;;;;GAKC;EALD;;;;;GAKC;EALD;;;;;GAKC;AACH;;AAEA;;EAEE,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;EACvD,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,YAAY;EACZ,mBAAmB;EACnB,gBAAY;OAAZ,YAAY;EACZ,4BAA4B;AAC9B","sourcesContent":[".chatHolder {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatText {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.form {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.textarea {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.button {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.button:hover {\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.button:disabled,\r\n.button:hover:disabled {\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.message {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"chatHolder": "chatComponents_chatHolder__2E1AX",
	"chatText": "chatComponents_chatText__3MREs",
	"form": "chatComponents_form__3rFIK",
	"textarea": "chatComponents_textarea__2UuLy",
	"button": "chatComponents_button__3eZyM",
	"message": "chatComponents_message__1dnoB"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9jb21wb25lbnRzX2NoYXRyb29tX2NoYXRDb21wb25lbnRzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBLElBQU1FLElBQUksR0FBRyxJQUFJRix1RUFBSixDQUEwQjtBQUFFSyxFQUFBQSxPQUFPLEVBQUU7QUFBWCxDQUExQixDQUFiLEVBRUE7O0FBRU8sU0FBU0MsVUFBVCxDQUFvQkMsV0FBcEIsRUFBaUNDLGlCQUFqQyxFQUFvRDtBQUFBOztBQUN6RCxNQUFNQyxPQUFPLEdBQUdQLElBQUksQ0FBQ1EsUUFBTCxDQUFjQyxHQUFkLENBQWtCSixXQUFsQixDQUFoQjs7QUFFQSxNQUFNSyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCSCxJQUFBQSxPQUFPLENBQUNJLFNBQVIsQ0FBa0IsVUFBQ0MsR0FBRCxFQUFTO0FBQ3pCTixNQUFBQSxpQkFBaUIsQ0FBQ00sR0FBRCxDQUFqQjtBQUNELEtBRkQ7QUFHRCxHQUpEOztBQUtBLE1BQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDdEJOLElBQUFBLE9BQU8sQ0FBQ08sV0FBUjtBQUNELEdBRkQ7O0FBSUEsTUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFNO0FBQzFCTCxJQUFBQSxPQUFPO0FBQ1AsV0FBTyxZQUFNO0FBQ1hHLE1BQUFBLFNBQVM7QUFDVixLQUZEO0FBR0QsR0FMRDs7QUFPQWQsRUFBQUEsZ0RBQVMsQ0FBQ2dCLGFBQUQsQ0FBVDtBQUVBLFNBQU8sQ0FBQ1IsT0FBRCxFQUFVUCxJQUFWLENBQVA7QUFDRDs7R0F0QmVJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJoQjtBQUNBO0FBQ0E7OztBQUVBLElB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnSUFBZ0ksYUFBYTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxTkFBcU47QUFDck47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2TEFBNkw7QUFDN0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrUkFBa1IsWUFBWTtBQUM5UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa1FBQWtRO0FBQ2xRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEIsWUFBWSxpQ0FBbUIsTUFBTSxpQ0FBbUI7O0FBRXBGLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQjtBQUN4RDtBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNktBQTZLO0FBQzdLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdILGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsOEhBQThIO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTTtBQUNyTTs7QUFFQTtBQUNBLENBQUM7O0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY2hhdHJvb20vQWJseVJlYWN0RWZmZWN0LmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9icm93c2VyL3N0YXRpYy9hYmx5LWNvbW1vbmpzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9wcm9taXNlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY2hhdHJvb20vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzcz9hYzI4Iiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL29mZmVyIGNvbXBhbnkgbmFtZSBhbmQgbG9nb1xyXG4vLyB0ZXh0YXJlYSBmb3IgaGlzIG9mZmVyXHJcbi8vIGhpZGRlbiBhbmQgYXBwZWFyXHJcbi8vIHN0YXRlcyBmb3IgcmVuZGVyaW5nIHRoZSBwYWdlXHJcbi8vV2ViU29ja2V0IGNvbm5lY3Rpb25zXHJcbi8vQWJseVxyXG4vL2FkZCBhbmQgSWRcclxuLy9hZGQgbWVzc2FnZSBzdG9yYWdlIGFuZCByZXRyaXZhbFxyXG4vL1xyXG5cclxuaW1wb3J0IEFibHkgZnJvbSBcImFibHkvcHJvbWlzZXNcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5jb25zdCBhYmx5ID0gbmV3IEFibHkuUmVhbHRpbWUuUHJvbWlzZSh7IGF1dGhVcmw6IFwiL2FwaS9jcmVhdGVUb2tlblJlcXVlc3RcIiB9KTtcclxuXHJcbi8vIGNvbnNvbGUubG9nKGFibHkpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYW5uZWwoY2hhbm5lbE5hbWUsIGNhbGxiYWNrT25NZXNzYWdlKSB7XHJcbiAgY29uc3QgY2hhbm5lbCA9IGFibHkuY2hhbm5lbHMuZ2V0KGNoYW5uZWxOYW1lKTtcclxuXHJcbiAgY29uc3Qgb25Nb3VudCA9ICgpID0+IHtcclxuICAgIGNoYW5uZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcclxuICAgICAgY2FsbGJhY2tPbk1lc3NhZ2UobXNnKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgY29uc3Qgb25Vbk1vdW50ID0gKCkgPT4ge1xyXG4gICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVzZUVmZmVjdEhvb2sgPSAoKSA9PiB7XHJcbiAgICBvbk1vdW50KCk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBvblVuTW91bnQoKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KHVzZUVmZmVjdEhvb2spO1xyXG5cclxuICByZXR1cm4gW2NoYW5uZWwsIGFibHldO1xyXG59XHJcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNoYW5uZWwgfSBmcm9tIFwiLi9BYmx5UmVhY3RFZmZlY3RcIjtcclxuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi4vY2hhdHJvb20vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiO1xyXG5cclxuY29uc3QgQ2hhdENvbXBvbmVudCA9ICgpID0+IHtcclxuICBsZXQgaW5wdXRCb3ggPSBudWxsO1xyXG4gIGxldCBtZXNzYWdlRW5kID0gbnVsbDtcclxuXHJcbiAgY29uc3QgW21lc3NhZ2VUZXh0LCBzZXRNZXNzYWdlVGV4dF0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICBjb25zdCBbcmVjZWl2ZWRNZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGUoW10pO1xyXG4gIGNvbnN0IG1lc3NhZ2VUZXh0SXNFbXB0eSA9IG1lc3NhZ2VUZXh0LnRyaW0oKS5sZW5ndGggPT09IDA7XHJcblxyXG4gIGNvbnN0IFtjaGFubmVsLCBhYmx5XSA9IHVzZUNoYW5uZWwoXCJjaGF0LWRlbW9cIiwgKG1lc3NhZ2UpID0+IHtcclxuICAgIGNvbnN0IGhpc3RvcnkgPSByZWNlaXZlZE1lc3NhZ2VzLnNsaWNlKC0xOTkpO1xyXG4gICAgc2V0TWVzc2FnZXMoWy4uLmhpc3RvcnksIG1lc3NhZ2VdKTtcclxuICB9KTtcclxuXHJcbiAgY29uc3Qgc2VuZENoYXRNZXNzYWdlID0gKG1lc3NhZ2VUZXh0KSA9PiB7XHJcbiAgICBjaGFubmVsLnB1Ymxpc2goeyBuYW1lOiBcImNoYXQtbWVzc2FnZVwiLCBkYXRhOiBtZXNzYWdlVGV4dCB9KTtcclxuICAgIHNldE1lc3NhZ2VUZXh0KFwiXCIpO1xyXG4gICAgaW5wdXRCb3guZm9jdXMoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVGb3JtU3VibWlzc2lvbiA9IChldmVudCkgPT4ge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHNlbmRDaGF0TWVzc2FnZShtZXNzYWdlVGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgIGlmIChldmVudC5jaGFyQ29kZSAhPT0gMTMgfHwgbWVzc2FnZVRleHRJc0VtcHR5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNlbmRDaGF0TWVzc2FnZShtZXNzYWdlVGV4dCk7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG1lc3NhZ2VzID0gcmVjZWl2ZWRNZXNzYWdlcy5tYXAoKG1lc3NhZ2UsIGluZGV4KSA9PiB7XHJcbiAgICBjb25zdCBhdXRob3IgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCA9PT0gYWJseS5jb25uZWN0aW9uLmlkID8gXCJtZVwiIDogXCJvdGhlclwiO1xyXG5cclxuICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IG5ldyBEYXRlKCk7XHJcbiAgICBjb25zdCB0aW1lU3RhbXAgPSBtaWxsaXNlY29uZHMudG9EYXRlU3RyaW5nKCk7XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHNJbnRvUmVhZGFibGVUaW1lKG1pbGxpc2Vjb25kcykge1xyXG4gICAgLy8gICAvL0dldCBob3VycyBmcm9tIG1pbGxpc2Vjb25kc1xyXG4gICAgLy8gICB2YXIgaG91cnMgPSBtaWxsaXNlY29uZHMgLyAoMTAwMCAqIDYwICogNjApO1xyXG4gICAgLy8gICB2YXIgYWJzb2x1dGVIb3VycyA9IE1hdGguZmxvb3IoaG91cnMpO1xyXG4gICAgLy8gICB2YXIgaCA9IGFic29sdXRlSG91cnMgPiA5ID8gYWJzb2x1dGVIb3VycyA6IFwiMFwiICsgYWJzb2x1dGVIb3VycztcclxuXHJcbiAgICAvLyAgIC8vR2V0IHJlbWFpbmRlciBmcm9tIGhvdXJzIGFuZCBjb252ZXJ0IHRvIG1pbnV0ZXNcclxuICAgIC8vICAgdmFyIG1pbnV0ZXMgPSAoaG91cnMgLSBhYnNvbHV0ZUhvdXJzKSAqIDYwO1xyXG4gICAgLy8gICB2YXIgYWJzb2x1dGVNaW51dGVzID0gTWF0aC5mbG9vcihtaW51dGVzKTtcclxuICAgIC8vICAgdmFyIG0gPSBhYnNvbHV0ZU1pbnV0ZXMgPiA5ID8gYWJzb2x1dGVNaW51dGVzIDogXCIwXCIgKyBhYnNvbHV0ZU1pbnV0ZXM7XHJcblxyXG4gICAgLy8gICAvL0dldCByZW1haW5kZXIgZnJvbSBtaW51dGVzIGFuZCBjb252ZXJ0IHRvIHNlY29uZHNcclxuICAgIC8vICAgdmFyIHNlY29uZHMgPSAobWludXRlcyAtIGFic29sdXRlTWludXRlcykgKiA2MDtcclxuICAgIC8vICAgdmFyIGFic29sdXRlU2Vjb25kcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyk7XHJcbiAgICAvLyAgIHZhciBzID0gYWJzb2x1dGVTZWNvbmRzID4gOSA/IGFic29sdXRlU2Vjb25kcyA6IFwiMFwiICsgYWJzb2x1dGVTZWNvbmRzO1xyXG5cclxuICAgIC8vICAgcmV0dXJuIGggKyBcIjpcIiArIG0gKyBcIjpcIiArIHM7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gdmFyIHRpbWUgPSBwYXJzZU1pbGxpc2Vjb25kc0ludG9SZWFkYWJsZVRpbWUobWlsbGlzZWNvbmRzKTtcclxuXHJcbiAgICAvLyBhbGVydCh0aW1lKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHRpbWUpO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxzcGFuXHJcbiAgICAgICAga2V5PXtpbmRleH1cclxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5tZXNzYWdlfVxyXG4gICAgICAgIC8vIHRpbWU9e25ldyBEYXRlKCkudG9TdHJpbmcoKX1cclxuICAgICAgICBkYXRhLWF1dGhvcj17YXV0aG9yfVxyXG4gICAgICA+XHJcbiAgICAgICAge21lc3NhZ2UuZGF0YX1cclxuICAgICAgPC9zcGFuPlxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG1lc3NhZ2VFbmQuc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvdXI6IFwic21vb3RoXCIgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNoYXRIb2xkZXJ9PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNoYXRUZXh0fT5cclxuICAgICAgICB7bWVzc2FnZXN9XHJcbiAgICAgICAge25ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCl9XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgcmVmPXsoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gZWxlbWVudDtcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgPjwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZUZvcm1TdWJtaXNzaW9ufSBjbGFzc05hbWU9e3N0eWxlcy5mb3JtfT5cclxuICAgICAgICA8dGV4dGFyZWFcclxuICAgICAgICAgIHJlZj17KGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgaW5wdXRCb3ggPSBlbGVtZW50O1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICAgIHZhbHVlPXttZXNzYWdlVGV4dH1cclxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSBhIG1lc3NhZ2UuLi5cIlxyXG4gICAgICAgICAgLy8gdGltZT17bmV3IERhdGUoKS50b1N0cmluZygpfVxyXG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRNZXNzYWdlVGV4dChlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICBvbktleVByZXNzPXtoYW5kbGVLZXlQcmVzc31cclxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRleHRhcmVhfVxyXG4gICAgICAgID48L3RleHRhcmVhPlxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufVxyXG4gICAgICAgICAgZGlzYWJsZWQ9e21lc3NhZ2VUZXh0SXNFbXB0eX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICBTZW5kXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgIDwvZm9ybT5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGF0Q29tcG9uZW50O1xyXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDIxLCBBYmx5XG4gKiBcbiAqIEFibHkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjIuMTNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcbiAqIFxuICogQWJseSBSZWFsdGltZSBNZXNzYWdpbmdcbiAqIGh0dHBzOi8vd3d3LmFibHkuY29tXG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkFibHlcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1MCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG52YXIgTG9nZ2VyID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgY29uc29sZUxvZ2dlciwgZXJyb3JMb2dnZXI7XG5cblx0LyogQ2FuJ3QganVzdCBjaGVjayBmb3IgY29uc29sZSAmJiBjb25zb2xlLmxvZzsgZmFpbHMgaW4gSUUgPD05ICovXG5cdGlmKCh0eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnKSAvKiBub2RlICovIHx8XG5cdFx0IChnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZS5sb2cgJiYgKHR5cGVvZiBnbG9iYWwuY29uc29sZS5sb2cuYXBwbHkgPT09ICdmdW5jdGlvbicpKSAvKiBzZW5zaWJsZSBicm93c2VycyAqLykge1xuXHRcdGNvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTsgfTtcblx0XHRlcnJvckxvZ2dlciA9IGNvbnNvbGUud2FybiA/IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTsgfSA6IGNvbnNvbGVMb2dnZXI7XG5cdH0gZWxzZSBpZihnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZS5sb2cpIHtcblx0XHQvKiBJRSA8PSA5IHdpdGggdGhlIGNvbnNvbGUgb3BlbiAtLSBjb25zb2xlLmxvZyBkb2VzIG5vdFxuXHRcdCAqIGluaGVyaXQgZnJvbSBGdW5jdGlvbiwgc28gaGFzIG5vIGFwcGx5IG1ldGhvZCAqL1xuXHRcdGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkgeyBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTsgfTtcblx0fSBlbHNlIHtcblx0XHQvKiBJRSA8PSA5IHdoZW4gZGV2IHRvb2xzIGFyZSBjbG9zZWQgLSB3aW5kb3cuY29uc29sZSBub3QgZXZlbiBkZWZpbmVkICovXG5cdFx0Y29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhZChzdHIsIHRocmVlKSB7XG5cdFx0cmV0dXJuICgnMDAwJyArIHN0cikuc2xpY2UoLTItKHRocmVlIHx8IDApKTtcblx0fVxuXG5cdHZhciBMT0dfTk9ORSAgPSAwLFxuXHRMT0dfRVJST1IgPSAxLFxuXHRMT0dfTUFKT1IgPSAyLFxuXHRMT0dfTUlOT1IgPSAzLFxuXHRMT0dfTUlDUk8gPSA0O1xuXG5cdHZhciBMT0dfREVGQVVMVCA9IExPR19FUlJPUixcblx0TE9HX0RFQlVHICAgPSBMT0dfTUlDUk87XG5cblx0dmFyIGxvZ0xldmVsID0gTE9HX0RFRkFVTFQ7XG5cblx0ZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcblx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dUaW1lc3RhbXBzID9cblx0XHRcdGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0XHR2YXIgdGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdGxvZ2dlcihwYWQodGltZS5nZXRIb3VycygpKSArICc6JyArIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSkgKyAnOicgKyBwYWQodGltZS5nZXRTZWNvbmRzKCkpICsgJy4nICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIHRydWUpICsgJyAnICsgbXNnKTtcblx0XHRcdH0gOiBsb2dnZXI7XG5cdH1cblxuXHR2YXIgbG9nSGFuZGxlciA9IGdldEhhbmRsZXIoY29uc29sZUxvZ2dlciksXG5cdFx0bG9nRXJyb3JIYW5kbGVyID0gZ2V0SGFuZGxlcihlcnJvckxvZ2dlcik7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIExvZ2dlcihhcmdzKSB7fVxuXG5cdC8qIHB1YmxpYyBjb25zdGFudHMgKi9cblx0TG9nZ2VyLkxPR19OT05FICAgID0gTE9HX05PTkUsXG5cdExvZ2dlci5MT0dfRVJST1IgICA9IExPR19FUlJPUixcblx0TG9nZ2VyLkxPR19NQUpPUiAgID0gTE9HX01BSk9SLFxuXHRMb2dnZXIuTE9HX01JTk9SICAgPSBMT0dfTUlOT1IsXG5cdExvZ2dlci5MT0dfTUlDUk8gICA9IExPR19NSUNSTztcblxuXHRMb2dnZXIuTE9HX0RFRkFVTFQgPSBMT0dfREVGQVVMVCxcblx0TG9nZ2VyLkxPR19ERUJVRyAgID0gTE9HX0RFQlVHO1xuXG5cdC8qIHB1YmxpYyBzdGF0aWMgZnVuY3Rpb25zICovXG5cdExvZ2dlci5sb2dBY3Rpb24gPSBmdW5jdGlvbihsZXZlbCwgYWN0aW9uLCBtZXNzYWdlKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHQobGV2ZWwgPT09IExPR19FUlJPUiA/IGxvZ0Vycm9ySGFuZGxlciA6IGxvZ0hhbmRsZXIpKCdBYmx5OiAnICsgYWN0aW9uICsgJzogJyArIG1lc3NhZ2UpO1xuXHRcdH1cblx0fTtcblxuXHRMb2dnZXIuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG9yaWdpbmFsLCByZXBsYWNlbWVudCkge1xuXHRcdExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyhvcmlnaW5hbCwgXCJQbGVhc2UgdXNlICdcIiArIHJlcGxhY2VtZW50ICsgXCInIGluc3RlYWQuXCIpO1xuXHR9XG5cblx0TG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnID0gZnVuY3Rpb24oZnVuY05hbWUsIG1zZykge1xuXHRcdGlmIChMb2dnZXIuc2hvdWxkTG9nKExPR19FUlJPUikpIHtcblx0XHRcdGxvZ0Vycm9ySGFuZGxlcihcIkFibHk6IERlcHJlY2F0aW9uIHdhcm5pbmcgLSAnXCIgKyBmdW5jTmFtZSArIFwiJyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBhIGZ1dHVyZSB2ZXJzaW9uLiBcIiArIG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0LyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxuXHQgICB0aGUgb2JqZWN0IGJlaW5nIHNlcmlhbGlzZWQgaWYgdGhlIGxvZyBsZXZlbCB3aWxsIG5vdCBvdXRwdXQgdGhlIG1lc3NhZ2UgKi9cblx0TG9nZ2VyLnNob3VsZExvZyA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdFx0cmV0dXJuIGxldmVsIDw9IGxvZ0xldmVsO1xuXHR9O1xuXG5cdExvZ2dlci5zZXRMb2cgPSBmdW5jdGlvbihsZXZlbCwgaGFuZGxlcikge1xuXHRcdGlmKGxldmVsICE9PSB1bmRlZmluZWQpIGxvZ0xldmVsID0gbGV2ZWw7XG5cdFx0aWYoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSBsb2dIYW5kbGVyID0gbG9nRXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcblx0fTtcblxuXHRyZXR1cm4gTG9nZ2VyO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChMb2dnZXIpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cblxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgVXRpbHMgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIFV0aWxzKCkge31cblxuXHRmdW5jdGlvbiByYW5kb21Qb3NuKGFyck9yU3RyKSB7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyck9yU3RyLmxlbmd0aCk7XG5cdH1cblxuXHQvKlxuXHQgKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3Rcblx0ICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuXHQgKiBwcm9wczogIGFuIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlXG5cdCAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XG5cdCAqL1xuXHRVdGlscy5taXhpbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZighc291cmNlKSB7IGJyZWFrOyB9XG5cdFx0XHRmb3IodmFyIGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0aWYoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Lypcblx0ICogQWRkIGEgc2V0IG9mIHByb3BlcnRpZXMgdG8gYSB0YXJnZXQgb2JqZWN0XG5cdCAqIHRhcmdldDogdGhlIHRhcmdldCBvYmplY3Rcblx0ICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuXHQgKiAgICAgICAgIGFkZGVkLCBieSByZWZlcmVuY2Ugb25seVxuXHQgKi9cblx0VXRpbHMuY29weSA9IGZ1bmN0aW9uKHNyYykge1xuXHRcdHJldHVybiBVdGlscy5taXhpbih7fSwgc3JjKTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBnaXZlbiBvYmplY3QgaXNcblx0ICogYW4gYXJyYXkuXG5cdCAqL1xuXHRVdGlscy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblx0Lypcblx0ICogRW5zdXJlcyB0aGF0IGFuIEFycmF5IG9iamVjdCBpcyBhbHdheXMgcmV0dXJuZWRcblx0ICogcmV0dXJuaW5nIHRoZSBvcmlnaW5hbCBBcnJheSBvZiBvYmogaXMgYW4gQXJyYXlcblx0ICogZWxzZSB3cmFwcGluZyB0aGUgb2JqIGluIGEgc2luZ2xlIGVsZW1lbnQgQXJyYXlcblx0ICovXG5cdFV0aWxzLmVuc3VyZUFycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYoVXRpbHMuaXNFbXB0eUFyZyhvYmopKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdGlmKFV0aWxzLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdFx0cmV0dXJuIFtvYmpdO1xuXHR9XG5cblx0LyogLi4uT3IgYW4gT2JqZWN0IChpbiB0aGUgbmFycm93IHNlbnNlKSAqL1xuXHRVdGlscy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb250YWluc1xuXHQgKiBhbnkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKiBvYjogdGhlIG9iamVjdFxuXHQgKi9cblx0VXRpbHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iKSB7XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdFV0aWxzLmlzT25seVByb3BJbiA9IGZ1bmN0aW9uKG9iLCBwcm9wZXJ0eSkge1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYikge1xuXHRcdFx0aWYocHJvcCAhPT0gcHJvcGVydHkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gYXJndW1lbnQgdG8gYW4gb3ZlcmxvYWRlZCBmdW5jdGlvbiBpc1xuXHQgKiB1bmRlZmluZWQgKG1pc3NpbmcpIG9yIG51bGwuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIGNvbnN0cnVjdGluZyBmdW5jdGlvbnMgc3VjaCBhcyAoV2ViSURMIHRlcm1pbm9sb2d5KTpcblx0ICogICBvZmYoW1RyZWF0VW5kZWZpbmVkQXM9TnVsbF0gRE9NU3RyaW5nPyBldmVudClcblx0ICogYXMgeW91IGNhbiB0aGVuIGNvbmZpcm0gdGhlIGFyZ3VtZW50IHVzaW5nOlxuXHQgKiAgIFV0aWxzLmlzRW1wdHlBcmcoZXZlbnQpXG5cdCAqL1xuXG5cdFV0aWxzLmlzRW1wdHlBcmcgPSBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnID09PSBudWxsIHx8IGFyZyA9PT0gdW5kZWZpbmVkO1xuXHR9XG5cblx0Lypcblx0ICogUGVyZm9ybSBhIHNpbXBsZSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdC5cblx0ICogUmVzdWx0IGlzIGFuIG9iamVjdCBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlclxuXHQgKiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IG9yIGFycmF5LiBBbGxcblx0ICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQuXG5cdCAqIG9iOiB0aGUgb2JqZWN0XG5cdCAqL1xuXHRVdGlscy5zaGFsbG93Q2xvbmUgPSBmdW5jdGlvbihvYikge1xuXHRcdHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKVxuXHRcdFx0cmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBDbG9uZSBhbiBvYmplY3QgYnkgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHdpdGggdGhlXG5cdCAqIGdpdmVuIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLiBPcHRpb25hbGx5XG5cdCAqIGEgc2V0IG9mIGFkZGl0aW9uYWwgb3duIHByb3BlcnRpZXMgY2FuIGJlXG5cdCAqIHN1cHBsaWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNsb25lLlxuXHQgKiBvYjogICAgICAgICAgICB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuXHQgKiBvd25Qcm9wZXJ0aWVzOiBvcHRpb25hbCBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsXG5cdCAqICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgdG8gYWRkXG5cdCAqL1xuXHRVdGlscy5wcm90b3R5cGljYWxDbG9uZSA9IGZ1bmN0aW9uKG9iLCBvd25Qcm9wZXJ0aWVzKSB7XG5cdFx0ZnVuY3Rpb24gRigpIHt9XG5cdFx0Ri5wcm90b3R5cGUgPSBvYjtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IEYoKTtcblx0XHRpZihvd25Qcm9wZXJ0aWVzKVxuXHRcdFx0VXRpbHMubWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIERlY2xhcmUgYSBjb25zdHJ1Y3RvciB0byByZXByZXNlbnQgYSBzdWJjbGFzc1xuXHQgKiBvZiBhbm90aGVyIGNvbnN0cnVjdG9yXG5cdCAqIElmIHBsYXRmb3JtIGhhcyBhIGJ1aWx0LWluIHZlcnNpb24gd2UgdXNlIHRoYXQgZnJvbSBQbGF0Zm9ybSwgZWxzZSB3ZVxuXHQgKiBkZWZpbmUgaGVyZSAoc28gY2FuIG1ha2UgdXNlIG9mIG90aGVyIFV0aWxzIGZucylcblx0ICogU2VlIG5vZGUuanMgdXRpbC5pbmhlcml0c1xuXHQgKi9cblx0VXRpbHMuaW5oZXJpdHMgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzIHx8IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHRcdGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHRcdGN0b3IucHJvdG90eXBlID0gVXRpbHMucHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnR5IHdob3NlIHZhbHVlIGVxdWFscyBhIGdpdmVuIHZhbHVlLlxuXHQgKiBvYjogIHRoZSBvYmplY3Rcblx0ICogdmFsOiB0aGUgdmFsdWUgdG8gZmluZFxuXHQgKi9cblx0VXRpbHMuY29udGFpbnNWYWx1ZSA9IGZ1bmN0aW9uKG9iLCB2YWwpIHtcblx0XHRmb3IodmFyIGkgaW4gb2IpIHtcblx0XHRcdGlmKG9iW2ldID09IHZhbClcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRVdGlscy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnIsIG9iKSB7IHJldHVybiBVdGlscy5pc0FycmF5KG9iKSA/IFV0aWxzLmFyckludGVyc2VjdChhcnIsIG9iKSA6IFV0aWxzLmFyckludGVyc2VjdE9iKGFyciwgb2IpOyB9O1xuXG5cdFV0aWxzLmFyckludGVyc2VjdCA9IGZ1bmN0aW9uKGFycjEsIGFycjIpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZW1iZXIgPSBhcnIxW2ldO1xuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihhcnIyLCBtZW1iZXIpICE9IC0xKVxuXHRcdFx0XHRyZXN1bHQucHVzaChtZW1iZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmFyckludGVyc2VjdE9iID0gZnVuY3Rpb24oYXJyLCBvYikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gYXJyW2ldO1xuXHRcdFx0aWYobWVtYmVyIGluIG9iKVxuXHRcdFx0XHRyZXN1bHQucHVzaChtZW1iZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmFyclN1YnRyYWN0ID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBhcnIxW2ldO1xuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihhcnIyLCBlbGVtZW50KSA9PSAtMSlcblx0XHRcdFx0cmVzdWx0LnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJySW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG5cdFx0PyBmdW5jdGlvbihhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuXHRcdFx0cmV0dXJuIGFyci5pbmRleE9mKGVsZW0sICBmcm9tSW5kZXgpO1xuXHRcdH1cblx0XHQ6IGZ1bmN0aW9uKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG5cdFx0XHRmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKDtmcm9tSW5kZXggPCBsZW47IGZyb21JbmRleCsrKSB7XG5cdFx0XHRcdGlmKGFycltmcm9tSW5kZXhdID09PSBlbGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21JbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cblx0VXRpbHMuYXJySW4gPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHJldHVybiBVdGlscy5hcnJJbmRleE9mKGFyciwgdmFsKSAhPT0gLTE7XG5cdH07XG5cblx0VXRpbHMuYXJyRGVsZXRlVmFsdWUgPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHZhciBpZHggPSBVdGlscy5hcnJJbmRleE9mKGFyciwgdmFsKTtcblx0XHR2YXIgcmVzID0gKGlkeCAhPSAtMSk7XG5cdFx0aWYocmVzKVxuXHRcdFx0YXJyLnNwbGljZShpZHgsIDEpO1xuXHRcdHJldHVybiByZXM7XG5cdH07XG5cblx0VXRpbHMuYXJyV2l0aG91dFZhbHVlID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHR2YXIgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG5cdFx0VXRpbHMuYXJyRGVsZXRlVmFsdWUobmV3QXJyLCB2YWwpO1xuXHRcdHJldHVybiBuZXdBcnI7XG5cdH07XG5cblx0Lypcblx0ICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuXHQgKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxuXHQgKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuXHQgKi9cblx0VXRpbHMua2V5c0FycmF5ID0gZnVuY3Rpb24ob2IsIG93bk9ubHkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZihvd25Pbmx5ICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSkgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChwcm9wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZVxuXHQgKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcblx0ICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXG5cdCAqIG9iOiAgICAgIHRoZSBvYmplY3Rcblx0ICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcblx0ICovXG5cdFV0aWxzLnZhbHVlc0FycmF5ID0gZnVuY3Rpb24ob2IsIG93bk9ubHkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZihvd25Pbmx5ICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSkgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChvYltwcm9wXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcHMgPSBmdW5jdGlvbihvYiwgZm4pIHtcblx0XHRmb3IgKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcblx0XHRcdFx0Zm4ocHJvcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdFV0aWxzLmFyckZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA/XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0YXJyLmZvckVhY2goZm4pO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGZuKGFycltpXSwgaSwgYXJyKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8qIFVzZWZ1bCB3aGVuIHRoZSBmdW5jdGlvbiBtYXkgbXV0YXRlIHRoZSBhcnJheSAqL1xuXHRVdGlscy5zYWZlQXJyRm9yRWFjaCA9IGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJyRm9yRWFjaChhcnIuc2xpY2UoKSwgZm4pO1xuXHR9O1xuXG5cdFV0aWxzLmFyck1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAgP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHJldHVybiBhcnIubWFwKGZuKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnIsIGZuKVx0e1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGZuKGFycltpXSwgaSwgYXJyKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0VXRpbHMuYXJyRmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlciA/XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0cmV0dXJuIGFyci5maWx0ZXIoZm4pO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKGFyciwgZm4pXHR7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYoZm4oYXJyW2ldKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRVdGlscy5hcnJFdmVyeSA9IEFycmF5LnByb3RvdHlwZS5ldmVyeSA/XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0cmV0dXJuIGFyci5ldmVyeShmbik7XG5cdFx0fSA6IGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmKCFmbihhcnJbaV0sIGksIGFycikpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cdFV0aWxzLmFsbFNhbWUgPSBmdW5jdGlvbihhcnIsIHByb3ApIHtcblx0XHRpZihhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gYXJyWzBdW3Byb3BdO1xuXHRcdHJldHVybiBVdGlscy5hcnJFdmVyeShhcnIsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtW3Byb3BdID09PSBmaXJzdDtcblx0XHR9KTtcblx0fTtcblxuXHRVdGlscy5uZXh0VGljayA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2s7XG5cblx0dmFyIGNvbnRlbnRUeXBlcyA9IHtcblx0XHRqc29uOiAgICdhcHBsaWNhdGlvbi9qc29uJyxcblx0XHRqc29ucDogICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jyxcblx0XHR4bWw6ICAgICdhcHBsaWNhdGlvbi94bWwnLFxuXHRcdGh0bWw6ICAgJ3RleHQvaHRtbCcsXG5cdFx0bXNncGFjazogJ2FwcGxpY2F0aW9uL3gtbXNncGFjaydcblx0fTtcblxuXHRVdGlscy5kZWZhdWx0R2V0SGVhZGVycyA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuXHRcdHZhciBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8ICdqc29uJ107XG5cdFx0cmV0dXJuIHtcblx0XHRcdGFjY2VwdDogYWNjZXB0LFxuXHRcdFx0J1gtQWJseS1WZXJzaW9uJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbixcblx0XHRcdCdBYmx5LUFnZW50JzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWdlbnRcblx0XHR9O1xuXHR9O1xuXG5cdFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuXHRcdHZhciBhY2NlcHQsIGNvbnRlbnRUeXBlO1xuXHRcdGFjY2VwdCA9IGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCAnanNvbiddO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFjY2VwdDogYWNjZXB0LFxuXHRcdFx0J2NvbnRlbnQtdHlwZSc6IGNvbnRlbnRUeXBlLFxuXHRcdFx0J1gtQWJseS1WZXJzaW9uJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbixcblx0XHRcdCdBYmx5LUFnZW50JzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWdlbnRcblx0XHR9O1xuXHR9O1xuXG5cdFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbihhcnIpIHtcblx0XHRyZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xuXHR9O1xuXG5cdFV0aWxzLnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRpZihwYXJhbXMpIHtcblx0XHRcdGZvcih2YXIga2V5IGluIHBhcmFtcylcblx0XHRcdFx0cGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMubGVuZ3RoID8gJz8nICsgcGFydHMuam9pbignJicpIDogJyc7XG5cdH07XG5cblx0VXRpbHMucGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdFx0dmFyIG1hdGNoLFxuXHRcdFx0c2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nLFxuXHRcdFx0cmVzdWx0ID0ge307XG5cblx0XHR3aGlsZSAobWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSkpXG5cdFx0XHRyZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMl0pO1xuXG4gXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG5cdFx0LyogSUUgOCAqL1xuXHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fTtcblxuXHRVdGlscy5pbnNwZWN0ID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0O1xuXG5cdFV0aWxzLmlzRXJyb3JJbmZvID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0cmV0dXJuIGVyci5jb25zdHJ1Y3Rvci5uYW1lID09ICdFcnJvckluZm8nXG5cdH07XG5cblx0VXRpbHMuaW5zcGVjdEVycm9yID0gZnVuY3Rpb24oeCkge1xuXHRcdC8qIHJlZHVuZGFudCwgYnV0IG5vZGUgdm1jb250ZXh0IGlzc3VlIG1ha2VzIGluc3RhbmNlb2YgdW5yZWxpYWJsZSwgYW5kXG5cdFx0ICogY2FuJ3QgdXNlIGp1c3QgY29uc3RydWN0b3IgdGVzdCBhcyBjb3VsZCBiZSBhIFR5cGVFcnJvciBjb25zdHJ1Y3RvciBldGMuICovXG5cdFx0cmV0dXJuICh4ICYmIChVdGlscy5pc0Vycm9ySW5mbyh4KSB8fFxuXHRcdFx0eC5jb25zdHJ1Y3Rvci5uYW1lID09ICdFcnJvcicgfHxcblx0XHRcdHggaW5zdGFuY2VvZiBFcnJvcikpID9cblx0XHRcdHgudG9TdHJpbmcoKSA6XG5cdFx0XHRVdGlscy5pbnNwZWN0KHgpO1xuXHR9O1xuXG5cdFV0aWxzLmluc3BlY3RCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuXHRcdGlmKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoYm9keSkpIHtcblx0XHRcdHJldHVybiBib2R5LnRvU3RyaW5nKCk7XG5cdFx0fSBlbHNlIGlmKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGJvZHk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QoYm9keSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIERhdGEgaXMgYXNzdW1lZCB0byBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBidWZmZXIuICovXG5cdFV0aWxzLmRhdGFTaXplQnl0ZXMgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0aWYocGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSkge1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYnl0ZUxlbmd0aChkYXRhKTtcblx0XHR9XG5cdFx0aWYodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgVXRpbHMuZGF0YVNpemVCeXRlcyB0byBiZSBhIGJ1ZmZlciBvciBzdHJpbmcsIGJ1dCB3YXM6IFwiICsgKHR5cGVvZiBkYXRhKSk7XG5cdH07XG5cblx0VXRpbHMuY2hlYXBSYW5kU3RyID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG5cdH07XG5cblx0LyogVGFrZXMgcGFyYW0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIG9mIGVudHJvcHkgdGhlIHN0cmluZyBtdXN0XG5cdCAqIGluY2x1ZGUsIG5vdCB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuIFN0cmluZyBsZW5ndGggcHJvZHVjZWQgaXMgbm90XG5cdCAqIGd1YXJhbnRlZWQuICovXG5cdFV0aWxzLnJhbmRvbVN0cmluZyA9IChwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID9cblx0XHRmdW5jdGlvbihudW1CeXRlcykge1xuXHRcdFx0dmFyIHVJbnRBcnIgPSBuZXcgVWludDhBcnJheShudW1CeXRlcyk7XG5cdFx0XHRwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZSh1SW50QXJyKTtcblx0XHR9IDogZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdC8qIE9sZCBicm93c2VyOyBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb20uIENvdWxkIGp1c3QgdXNlIGFcblx0XHRcdCAqIENyeXB0b0pTIHZlcnNpb24gb2YgdGhlIGFib3ZlLCBidXQgd2FudCB0aGlzIHRvIHN0aWxsIHdvcmsgaW4gbm9jcnlwdG9cblx0XHRcdCAqIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5ICovXG5cdFx0XHR2YXIgY2hhcnNldCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0Q2hhclNldDtcblx0XHRcdC8qIGJhc2U2NCBoYXMgMzMlIG92ZXJoZWFkOyByb3VuZCBsZW5ndGggdXAgKi9cblx0XHRcdHZhciBsZW5ndGggPSBNYXRoLnJvdW5kKG51bUJ5dGVzICogNC8zKTtcblx0XHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRcdGZvcih2YXIgaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBjaGFyc2V0W3JhbmRvbVBvc24oY2hhcnNldCldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFV0aWxzLnJhbmRvbUhleFN0cmluZyA9IChwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID9cblx0XHRmdW5jdGlvbihudW1CeXRlcykge1xuXHRcdFx0dmFyIHVJbnRBcnIgPSBuZXcgVWludDhBcnJheShudW1CeXRlcyk7XG5cdFx0XHRwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmhleEVuY29kZSh1SW50QXJyKTtcblx0XHR9IDogZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdHZhciBjaGFyc2V0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5oZXhDaGFyU2V0O1xuXHRcdFx0dmFyIGxlbmd0aCA9IG51bUJ5dGVzICogMjtcblx0XHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRcdGZvcih2YXIgaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBjaGFyc2V0W3JhbmRvbVBvc24oY2hhcnNldCldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdC8qIFBpY2sgbiBlbGVtZW50cyBhdCByYW5kb20gd2l0aG91dCByZXBsYWNlbWVudCBmcm9tIGFuIGFycmF5ICovXG5cdFV0aWxzLmFyckNob29zZU4gPSBmdW5jdGlvbihhcnIsIG4pIHtcblx0XHR2YXIgbnVtSXRlbXMgPSBNYXRoLm1pbihuLCBhcnIubGVuZ3RoKSxcblx0XHRcdG11dGFibGVBcnIgPSBhcnIuc2xpY2UoKSxcblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBudW1JdGVtczsgaSsrKSB7XG5cdFx0XHRyZXN1bHQucHVzaChVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltID8gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdH0gOiBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cdH07XG5cblx0VXRpbHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24ob2IsIGZuTmFtZSwgYXJncykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdG9iW2ZuTmFtZV0uYXBwbHkob2IsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmNvbmNhdChmdW5jdGlvbihlcnIsIHJlcykge1xuXHRcdFx0XHRlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKTtcblx0XHRcdH0pKTtcblx0XHR9KTtcblx0fTtcblxuXHRVdGlscy5kZWNvZGVCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIChmb3JtYXQgPT0gJ21zZ3BhY2snKSA/IG1zZ3BhY2suZGVjb2RlKGJvZHkpIDogSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xuXHR9O1xuXG5cdFV0aWxzLmVuY29kZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gKGZvcm1hdCA9PSAnbXNncGFjaycpID8gbXNncGFjay5lbmNvZGUoYm9keSwgdHJ1ZSkgOiBKU09OLnN0cmluZ2lmeShib2R5KTtcblx0fTtcblxuXHRVdGlscy5hbGxUb0xvd2VyQ2FzZSA9IGZ1bmN0aW9uKGFycikge1xuXHRcdHJldHVybiBVdGlscy5hcnJNYXAoYXJyLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH07XG5cblx0VXRpbHMuYWxsVG9VcHBlckNhc2UgPSBmdW5jdGlvbihhcnIpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJyTWFwKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBVdGlscztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVXRpbHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG52YXIgRXJyb3JJbmZvID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMuY2F1c2UgPSBjYXVzZTtcblx0XHR0aGlzLmhyZWYgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRFcnJvckluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbJyArIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0XHRpZih0aGlzLm1lc3NhZ2UpIHJlc3VsdCArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xuXHRcdGlmKHRoaXMuc3RhdHVzQ29kZSkgcmVzdWx0ICs9ICc7IHN0YXR1c0NvZGU9JyArIHRoaXMuc3RhdHVzQ29kZTtcblx0XHRpZih0aGlzLmNvZGUpIHJlc3VsdCArPSAnOyBjb2RlPScgKyB0aGlzLmNvZGU7XG5cdFx0aWYodGhpcy5jYXVzZSkgcmVzdWx0ICs9ICc7IGNhdXNlPScgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcih0aGlzLmNhdXNlKTtcblx0XHRpZih0aGlzLmhyZWYgJiYgISh0aGlzLm1lc3NhZ2UgJiYgdGhpcy5tZXNzYWdlLmluZGV4T2YoJ2hlbHAuYWJseS5pbycpID4gLTEpKSByZXN1bHQgKz0gJzsgc2VlICcgKyB0aGlzLmhyZWYgKyAnICc7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdEVycm9ySW5mby5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IEVycm9ySW5mbygpLCB2YWx1ZXMpO1xuXHRcdGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0LyogRXJyb3IubWVzc2FnZSBpcyBub3QgZW51bWVyYWJsZSwgc28gbWl4aW4gbG9zZXMgdGhlIG1lc3NhZ2UgKi9cblx0XHRcdHJlc3VsdC5tZXNzYWdlID0gdmFsdWVzLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdGlmKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xuXHRcdFx0cmVzdWx0LmhyZWYgPSAnaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvJyArIHJlc3VsdC5jb2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJldHVybiBFcnJvckluZm87XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9ySW5mbyk7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgc2V0SW1tZWRpYXRlKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saWJfdXRpbF9tc2dwYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXG5pZih0eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdGNvbnNvbGUubG9nKFwiV2FybmluZzogdGhpcyBkaXN0cmlidXRpb24gb2YgQWJseSBpcyBpbnRlbmRlZCBmb3IgYnJvd3NlcnMuIE9uIG5vZGVqcywgcGxlYXNlIHVzZSB0aGUgJ2FibHknIHBhY2thZ2Ugb24gbnBtXCIpO1xufVxuXG5mdW5jdGlvbiBhbGxvd0NvbWV0KCkge1xuXHQvKiB4aHIgcmVxdWVzdHMgZnJvbSBsb2NhbCBmaWxlcyBhcmUgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXJzLCBzdWNoIGFzIENocm9tZSA2NSBhbmQgaGlnaGVyIC0tIHNlZSBlZ1xuXHQgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTI1NjQyOS9jaHJvbWUtNjUtdW5hYmxlLXRvLW1ha2UtcG9zdC1yZXF1ZXN0cy1mcm9tLWxvY2FsLWZpbGVzLXRvLWZsYXNrXG5cdCAqIFNvIGlmIHdlYnNvY2tldHMgYXJlIHN1cHBvcnRlZCwgdGhlbiBqdXN0IGZvcmdldCBhYm91dCBjb21ldCB0cmFuc3BvcnRzIGFuZCB1c2UgdGhhdCAqL1xuXHR2YXIgbG9jID0gZ2xvYmFsLmxvY2F0aW9uO1xuXHRyZXR1cm4gKCFnbG9iYWwuV2ViU29ja2V0IHx8ICFsb2MgfHwgIWxvYy5vcmlnaW4gfHwgbG9jLm9yaWdpbi5pbmRleE9mKFwiaHR0cFwiKSA+IC0xKTtcbn1cblxudmFyIHVzZXJBZ2VudCA9IGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKTtcbnZhciBjdXJyZW50VXJsID0gZ2xvYmFsLmxvY2F0aW9uICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmO1xuXG52YXIgUGxhdGZvcm0gPSB7XG4gICAgICAgIGFnZW50OiAnYnJvd3NlcicsXG5cdGxvZ1RpbWVzdGFtcHM6IHRydWUsXG5cdHVzZXJBZ2VudDogdXNlckFnZW50LFxuXHRjdXJyZW50VXJsOiBjdXJyZW50VXJsLFxuXHRub1VwZ3JhZGU6IHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQubWF0Y2goL01TSUVcXHM4XFwuMC8pLFxuXHRiaW5hcnlUeXBlOiAnYXJyYXlidWZmZXInLFxuXHRXZWJTb2NrZXQ6IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldCxcblx0eGhyU3VwcG9ydGVkOiBnbG9iYWwuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG5cdGpzb25wU3VwcG9ydGVkOiB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyxcblx0YWxsb3dDb21ldDogYWxsb3dDb21ldCgpLFxuXHRzdHJlYW1pbmdTdXBwb3J0ZWQ6IHRydWUsXG5cdHVzZVByb3RvY29sSGVhcnRiZWF0czogdHJ1ZSxcblx0Y3JlYXRlSG1hYzogbnVsbCxcblx0bXNncGFjazogX2xpYl91dGlsX21zZ3BhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSxcblx0c3VwcG9ydHNCaW5hcnk6ICEhZ2xvYmFsLlRleHREZWNvZGVyLFxuXHRwcmVmZXJCaW5hcnk6IGZhbHNlLFxuXHRBcnJheUJ1ZmZlcjogZ2xvYmFsLkFycmF5QnVmZmVyLFxuXHRhdG9iOiBnbG9iYWwuYXRvYixcblx0bmV4dFRpY2s6IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsLnNldEltbWVkaWF0ZS5iaW5kKGdsb2JhbCkgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMCk7IH0sXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGdsb2JhbC5hZGRFdmVudExpc3RlbmVyLFxuXHRpbnNwZWN0OiBKU09OLnN0cmluZ2lmeSxcblx0c3RyaW5nQnl0ZVNpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdC8qIHN0ci5sZW5ndGggd2lsbCBiZSBhbiB1bmRlcmVzdGltYXRlIGZvciBub24tYXNjaWkgc3RyaW5ncy4gQnV0IGlmIHdlJ3JlXG5cdFx0ICogaW4gYSBicm93c2VyIHRvbyBvbGQgdG8gc3VwcG9ydCBUZXh0RGVjb2Rlciwgbm90IG11Y2ggd2UgY2FuIGRvLiBCZXR0ZXJcblx0XHQgKiB0byB1bmRlcmVzdGltYXRlLCBzbyBpZiB3ZSBkbyBnbyBvdmVyLXNpemUsIHRoZSBzZXJ2ZXIgd2lsbCByZWplY3QgdGhlXG5cdFx0ICogbWVzc2FnZSAqL1xuXHRcdHJldHVybiBnbG9iYWwuVGV4dERlY29kZXIgJiZcblx0XHRcdChuZXcgZ2xvYmFsLlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpLmxlbmd0aCB8fFxuXHRcdFx0c3RyLmxlbmd0aDtcblx0fSxcblx0VGV4dEVuY29kZXI6IGdsb2JhbC5UZXh0RW5jb2Rlcixcblx0VGV4dERlY29kZXI6IGdsb2JhbC5UZXh0RGVjb2Rlcixcblx0UHJvbWlzZTogZ2xvYmFsLlByb21pc2UsXG5cdGdldFJhbmRvbVZhbHVlczogKGZ1bmN0aW9uKGNyeXB0bykge1xuXHRcdGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGFyciwgY2FsbGJhY2spIHtcblx0XHRcdGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcblx0XHRcdGlmKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKSAvLyBtc2NyeXB0byBmb3IgSUUxMVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQbGF0Zm9ybSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0Mikuc2V0SW1tZWRpYXRlKSlcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvZGVmYXVsdHMuanNcblxuXG52YXIgRGVmYXVsdHMgPSB7XG5cdGludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHQnLFxuXHRqc29ucEludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC0wLTkuanMnLFxuXHQvKiBPcmRlciBtYXR0ZXJzIGhlcmU6IHRoZSBiYXNlIHRyYW5zcG9ydCBpcyB0aGUgbGVmdG1vc3Qgb25lIGluIHRoZVxuXHQgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzXG5cdCAqIHN1cHBvcnRlZC4gIFRoaXMgaXMgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHRoZSBwcmVmZXJlbmNlIG9yZGVyIC0tIGUuZy5cblx0ICogeGhyX3BvbGxpbmcgaXMgcHJlZmVycmVkIHRvIGpzb25wLCBidXQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCB3ZSB3YW50XG5cdCAqIHRoZSBiYXNlIHRyYW5zcG9ydCB0byBiZSB4aHJfcG9sbGluZywgbm90IGpzb25wICovXG5cdGRlZmF1bHRUcmFuc3BvcnRzOiBbJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnanNvbnAnLCAnd2ViX3NvY2tldCddLFxuXHRiYXNlVHJhbnNwb3J0T3JkZXI6IFsneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICdqc29ucCcsICd3ZWJfc29ja2V0J10sXG5cdHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjogWydqc29ucCcsICd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ3dlYl9zb2NrZXQnXSxcblx0dXBncmFkZVRyYW5zcG9ydHM6IFsneGhyX3N0cmVhbWluZycsICd3ZWJfc29ja2V0J11cbn07XG5cbi8qIElmIHVzaW5nIElFOCwgZG9uJ3QgYXR0ZW1wdCB0byB1cGdyYWRlIGZyb20geGhyX3BvbGxpbmcgdG8geGhyX3N0cmVhbWluZyAtXG4qIHdoaWxlIGl0IGNhbiBkbyBzdHJlYW1pbmcsIHRoZSBsb3cgbWF4IGh0dHAtY29ubmVjdGlvbnMtcGVyLWhvc3QgbGltaXQgbWVhbnNcbiogdGhhdCB0aGUgcG9sbGluZyB0cmFuc3BvcnQgaXMgY3JpcHBsZWQgZHVyaW5nIHRoZSB1cGdyYWRlIHByb2Nlc3MuIFNvIGp1c3RcbiogbGVhdmUgaXQgYXQgdGhlIGJhc2UgdHJhbnNwb3J0ICovXG5pZihwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vVXBncmFkZSkge1xuXHREZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cyA9IFtdO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXG52YXIgYnVmZmVydXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby5qc1xudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLmpzXG5cblxuXG5cblxuXG5cbmRlZmF1bHRzLkVOVklST05NRU5UICAgICAgICAgICAgICA9ICcnO1xuZGVmYXVsdHMuUkVTVF9IT1NUICAgICAgICAgICAgICAgID0gJ3Jlc3QuYWJseS5pbyc7XG5kZWZhdWx0cy5SRUFMVElNRV9IT1NUICAgICAgICAgICAgPSAncmVhbHRpbWUuYWJseS5pbyc7XG5kZWZhdWx0cy5GQUxMQkFDS19IT1NUUyAgICAgICAgICAgPSBbJ0EuYWJseS1yZWFsdGltZS5jb20nLCAnQi5hYmx5LXJlYWx0aW1lLmNvbScsICdDLmFibHktcmVhbHRpbWUuY29tJywgJ0QuYWJseS1yZWFsdGltZS5jb20nLCAnRS5hYmx5LXJlYWx0aW1lLmNvbSddO1xuZGVmYXVsdHMuUE9SVCAgICAgICAgICAgICAgICAgICAgID0gODA7XG5kZWZhdWx0cy5UTFNfUE9SVCAgICAgICAgICAgICAgICAgPSA0NDM7XG5kZWZhdWx0cy5USU1FT1VUUyA9IHtcblx0LyogRG9jdW1lbnRlZCBhcyBvcHRpb25zIHBhcmFtczogKi9cblx0ZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICAgOiAxNTAwMCxcblx0c3VzcGVuZGVkUmV0cnlUaW1lb3V0ICAgICAgOiAzMDAwMCxcblx0LyogVW5kb2N1bWVudGVkLCBidXQgcGFydCBvZiB0aGUgYXBpIGFuZCBjYW4gYmUgdXNlZCBieSBjdXN0b21lcnM6ICovXG5cdGh0dHBSZXF1ZXN0VGltZW91dCAgICAgICAgIDogMTUwMDAsXG5cdGNoYW5uZWxSZXRyeVRpbWVvdXQgICAgICAgIDogMTUwMDAsXG5cdGZhbGxiYWNrUmV0cnlUaW1lb3V0ICAgICAgIDogNjAwMDAwLFxuXHQvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuXHRjb25uZWN0aW9uU3RhdGVUdGwgICAgICAgICA6IDEyMDAwMCxcblx0cmVhbHRpbWVSZXF1ZXN0VGltZW91dCAgICAgOiAxMDAwMCxcblx0cmVjdlRpbWVvdXQgICAgICAgICAgICAgICAgOiA5MDAwMCxcblx0cHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICAgOiA2MDAwLFxuXHRwYXJhbGxlbFVwZ3JhZGVEZWxheSAgICAgICA6IDYwMDBcbn07XG5kZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudCA9IDM7XG5kZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSAgICA9IDY1NTM2O1xuXG5kZWZhdWx0cy5lcnJvclJlcG9ydGluZ1VybCA9ICdodHRwczovL2Vycm9ycy5hYmx5LmlvL2FwaS8xNS9zdG9yZS8nO1xuZGVmYXVsdHMuZXJyb3JSZXBvcnRpbmdIZWFkZXJzID0ge1xuXHRcIlgtU2VudHJ5LUF1dGhcIjogXCJTZW50cnkgc2VudHJ5X3ZlcnNpb249Nywgc2VudHJ5X2tleT1hMDRlMzNjODY3NGM0NTFmOGEzMTBmYmVjMDI5YWNmNSwgc2VudHJ5X2NsaWVudD1hYmx5LWpzLzAuMVwiLFxuXHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxufTtcblxuZGVmYXVsdHMudmVyc2lvbiAgICAgICAgICA9ICcxLjIuMTMnO1xuZGVmYXVsdHMuYXBpVmVyc2lvbiAgICAgICA9ICcxLjInO1xuXG52YXIgYWdlbnQgPSAnYWJseS1qcy8nICsgZGVmYXVsdHMudmVyc2lvbjtcbmlmIChwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFnZW50KSB7XG5cdGFnZW50ICs9ICcgJyArIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWdlbnQ7XG59IFxuZGVmYXVsdHMuYWdlbnQgPSBhZ2VudDtcblxuZGVmYXVsdHMuZ2V0SG9zdCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGhvc3QsIHdzKSB7XG5cdGlmKHdzKVxuXHRcdGhvc3QgPSAoKGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCkgJiYgb3B0aW9ucy5yZWFsdGltZUhvc3QpIHx8IGhvc3QgfHwgb3B0aW9ucy5yZWFsdGltZUhvc3Q7XG5cdGVsc2Vcblx0XHRob3N0ID0gaG9zdCB8fCBvcHRpb25zLnJlc3RIb3N0O1xuXG5cdHJldHVybiBob3N0O1xufTtcblxuZGVmYXVsdHMuZ2V0UG9ydCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRscykge1xuXHRyZXR1cm4gKHRscyB8fCBvcHRpb25zLnRscykgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59O1xuXG5kZWZhdWx0cy5nZXRIdHRwU2NoZW1lID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRyZXR1cm4gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xufTtcblxuLy8gY29uc3RydWN0IGVudmlyb25tZW50IGZhbGxiYWNrIGhvc3RzIGFzIHBlciBSU0MxNWlcbmRlZmF1bHRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50KSB7XG5cdHJldHVybiBbXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWEtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1iLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcblx0XHRlbnZpcm9ubWVudCArICctYy1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWQtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1lLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJ1xuXHRdO1xufTtcblxuZGVmYXVsdHMuZ2V0RmFsbGJhY2tIb3N0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dmFyIGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsXG5cdFx0aHR0cE1heFJldHJ5Q291bnQgPSB0eXBlb2Yob3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IGRlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuXG5cdHJldHVybiBmYWxsYmFja0hvc3RzID8gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn07XG5cbmRlZmF1bHRzLmdldEhvc3RzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRyZXR1cm4gW29wdGlvbnMucmVzdEhvc3RdLmNvbmNhdChkZWZhdWx0cy5nZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG5cdGlmKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2hvc3QgbXVzdCBiZSBhIHN0cmluZzsgd2FzIGEgJyArIHR5cGVvZiBob3N0LCA0MDAwMCwgNDAwKTtcblx0fTtcblx0aWYoIWhvc3QubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnaG9zdCBtdXN0IG5vdCBiZSB6ZXJvLWxlbmd0aCcsIDQwMDAwLCA0MDApO1xuXHR9O1xufVxuXG5kZWZhdWx0cy5vYmplY3RpZnlPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRpZih0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xuXHR9XG5cdHJldHVybiBvcHRpb25zO1xufTtcblxuZGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0LyogRGVwcmVjYXRlZCBvcHRpb25zICovXG5cdGlmKG9wdGlvbnMuaG9zdCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdob3N0JywgJ3Jlc3RIb3N0Jyk7XG5cdFx0b3B0aW9ucy5yZXN0SG9zdCA9IG9wdGlvbnMuaG9zdDtcblx0fVxuXHRpZihvcHRpb25zLndzSG9zdCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd3c0hvc3QnLCAncmVhbHRpbWVIb3N0Jyk7XG5cdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBvcHRpb25zLndzSG9zdDtcblx0fVxuXHRpZihvcHRpb25zLnF1ZXVlRXZlbnRzKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3F1ZXVlRXZlbnRzJywgJ3F1ZXVlTWVzc2FnZXMnKTtcblx0XHRvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSBvcHRpb25zLnF1ZXVlRXZlbnRzO1xuXHR9XG5cblx0aWYob3B0aW9ucy5mYWxsYmFja0hvc3RzVXNlRGVmYXVsdCkge1xuXHRcdC8qIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGFuZCBmYWxsYmFja0hvc3RzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXMgcGVyIFRPM2s3ICovXG5cdFx0aWYob3B0aW9ucy5mYWxsYmFja0hvc3RzKSB7XG5cdFx0XHR2YXIgbXNnID0gJ2ZhbGxiYWNrSG9zdHMgYW5kIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGNhbm5vdCBib3RoIGJlIHNldCc7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDAwMCwgNDAwKTtcblx0XHR9XG5cblx0XHQvKiBkZWZhdWx0IGZhbGxiYWNrcyBjYW4ndCBiZSB1c2VkIHdpdGggY3VzdG9tIHBvcnRzICovXG5cdFx0aWYob3B0aW9ucy5wb3J0IHx8IG9wdGlvbnMudGxzUG9ydCkge1xuXHRcdFx0dmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYmUgc2V0IHdoZW4gcG9ydCBvciB0bHNQb3J0IGFyZSBzZXQnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAwMDAsIDQwMCk7XG5cdFx0fVxuXG5cdFx0LyogZW1pdCBhbiBhcHByb3ByaWF0ZSBkZXByZWNhdGlvbiB3YXJuaW5nICovXG5cdFx0aWYob3B0aW9ucy5lbnZpcm9ubWVudCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWRXaXRoTXNnKCdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCcsICdUaGVyZSBpcyBubyBsb25nZXIgYSBuZWVkIHRvIHNldCB0aGlzIHdoZW4gdGhlIGVudmlyb25tZW50IG9wdGlvbiBpcyBhbHNvIHNldCBzaW5jZSB0aGUgbGlicmFyeSB3aWxsIG5vdyBnZW5lcmF0ZSB0aGUgY29ycmVjdCBmYWxsYmFjayBob3N0cyB1c2luZyB0aGUgZW52aXJvbm1lbnQgb3B0aW9uLicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnZmFsbGJhY2tIb3N0czogQWJseS5EZWZhdWx0cy5GQUxMQkFDS19IT1NUUycpO1xuXHRcdH1cblxuXHRcdC8qIHVzZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBob3N0cyBhcyByZXF1ZXN0ZWQgKi9cblx0XHRvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBkZWZhdWx0cy5GQUxMQkFDS19IT1NUUztcblx0fVxuXG5cdGlmKG9wdGlvbnMucmVjb3ZlciA9PT0gdHJ1ZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd7cmVjb3ZlcjogdHJ1ZX0nLCAne3JlY292ZXI6IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH19Jyk7XG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gZnVuY3Rpb24obGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikgeyBjYih0cnVlKTsgfTtcblx0fVxuXG5cdGlmKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyJyk7XG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gbnVsbDtcblx0fVxuXG5cdGlmKCEoJ2Nsb3NlT25VbmxvYWQnIGluIG9wdGlvbnMpKSB7XG5cdFx0LyogSGF2ZSBjbG9zZU9uVW5sb2FkIGRlZmF1bHQgdG8gdHJ1ZSB1bmxlc3Mgd2UgaGF2ZSBhbnkgaW5kaWNhdGlvbiB0aGF0XG5cdFx0ICogdGhlIHVzZXIgbWF5IHdhbnQgdG8gcmVjb3ZlciB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG5cdH1cblxuXHRpZihvcHRpb25zLnRyYW5zcG9ydHMgJiYgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4ob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJykpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgndHJhbnNwb3J0czogW1wieGhyXCJdJywgJ3RyYW5zcG9ydHM6IFtcInhocl9zdHJlYW1pbmdcIl0nKTtcblx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJEZWxldGVWYWx1ZShvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKTtcblx0XHRvcHRpb25zLnRyYW5zcG9ydHMucHVzaCgneGhyX3N0cmVhbWluZycpO1xuXHR9XG5cblx0aWYoISgncXVldWVNZXNzYWdlcycgaW4gb3B0aW9ucykpXG5cdFx0b3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcblxuXHQvKiBpbmZlciBob3N0cyBhbmQgZmFsbGJhY2tzIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGVudmlyb25tZW50ICovXG5cdHZhciBlbnZpcm9ubWVudCA9IChvcHRpb25zLmVudmlyb25tZW50ICYmIFN0cmluZyhvcHRpb25zLmVudmlyb25tZW50KS50b0xvd2VyQ2FzZSgpKSB8fCBkZWZhdWx0cy5FTlZJUk9OTUVOVDtcblx0dmFyIHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgKGVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbicpO1xuXG5cdGlmKCFvcHRpb25zLmZhbGxiYWNrSG9zdHMgJiYgIW9wdGlvbnMucmVzdEhvc3QgJiYgIW9wdGlvbnMucmVhbHRpbWVIb3N0ICYmICFvcHRpb25zLnBvcnQgJiYgIW9wdGlvbnMudGxzUG9ydCkge1xuXHRcdG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IHByb2R1Y3Rpb24gPyBkZWZhdWx0cy5GQUxMQkFDS19IT1NUUyA6IGRlZmF1bHRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCk7XG5cdH1cblxuXHRpZighb3B0aW9ucy5yZWFsdGltZUhvc3QpIHtcblx0XHQvKiBwcmVmZXIgc2V0dGluZyByZWFsdGltZUhvc3QgdG8gcmVzdEhvc3QgYXMgYSBjdXN0b20gcmVzdEhvc3QgdHlwaWNhbGx5IGluZGljYXRlc1xuXHRcdCAqIGEgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgaXMgYmVpbmcgdXNlZCB0aGF0IGNhbid0IGJlIGluZmVycmVkIGJ5IHRoZSBsaWJyYXJ5ICovXG5cdFx0aWYob3B0aW9ucy5yZXN0SG9zdCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX1dBUk4sICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3Jlc3RIb3N0IGlzIHNldCB0byBcIicgKyBvcHRpb25zLnJlc3RIb3N0ICsgJ1wiIGJ1dCByZWFsdGltZUhvc3QgaXMgbm90IHNldCwgc28gc2V0dGluZyByZWFsdGltZUhvc3QgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJyk7XG5cdFx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMucmVzdEhvc3Rcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBwcm9kdWN0aW9uID8gZGVmYXVsdHMuUkVBTFRJTUVfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgZGVmYXVsdHMuUkVBTFRJTUVfSE9TVDtcblx0XHR9XG5cdH1cblxuXHRpZighb3B0aW9ucy5yZXN0SG9zdCkge1xuXHRcdG9wdGlvbnMucmVzdEhvc3QgPSBwcm9kdWN0aW9uID8gZGVmYXVsdHMuUkVTVF9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBkZWZhdWx0cy5SRVNUX0hPU1Q7XG5cdH1cblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChvcHRpb25zLnJlc3RIb3N0LCBvcHRpb25zLnJlYWx0aW1lSG9zdCksIGNoZWNrSG9zdCk7XG5cblx0b3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IGRlZmF1bHRzLlBPUlQ7XG5cdG9wdGlvbnMudGxzUG9ydCA9IG9wdGlvbnMudGxzUG9ydCB8fCBkZWZhdWx0cy5UTFNfUE9SVDtcblx0b3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemUgfHwgZGVmYXVsdHMubWF4TWVzc2FnZVNpemU7XG5cdGlmKCEoJ3RscycgaW4gb3B0aW9ucykpIG9wdGlvbnMudGxzID0gdHJ1ZTtcblxuXHQvKiBBbGxvdyB2YWx1ZXMgcGFzc2VkIGluIG9wdGlvbnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCB0aW1lb3V0cyAqL1xuXHRvcHRpb25zLnRpbWVvdXRzID0ge307XG5cdGZvcih2YXIgcHJvcCBpbiBkZWZhdWx0cy5USU1FT1VUUykge1xuXHRcdG9wdGlvbnMudGltZW91dHNbcHJvcF0gPSBvcHRpb25zW3Byb3BdIHx8IGRlZmF1bHRzLlRJTUVPVVRTW3Byb3BdO1xuXHR9O1xuXG5cdGlmKCd1c2VCaW5hcnlQcm90b2NvbCcgaW4gb3B0aW9ucykge1xuXHRcdG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzQmluYXJ5ICYmIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2w7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJlZmVyQmluYXJ5O1xuXHR9XG5cblx0aWYob3B0aW9ucy5jbGllbnRJZCkge1xuXHRcdHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXHRcdGhlYWRlcnNbJ1gtQWJseS1DbGllbnRJZCddID0gYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYmFzZTY0RW5jb2RlKGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuXHR9XG5cblx0aWYoISgnaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nJyBpbiBvcHRpb25zKSkge1xuXHRcdG9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gdHJ1ZTtcblx0fVxuXG5cdGlmKG9wdGlvbnMucHJvbWlzZXMgJiYgIXBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uUHJvbWlzZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAne3Byb21pc2VzOiB0cnVlfSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gUHJvbWlzZSBjb25zdHJ1Y3RvciBmb3VuZDsgZGlzYWJsaW5nIHByb21pc2VzJyk7XG5cdFx0b3B0aW9ucy5wcm9taXNlcyA9IGZhbHNlO1xuXHR9XG5cbiAgICAgICAgaWYob3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgICAgICBmb3IodmFyIGtleSBpbiBvcHRpb25zLmFnZW50cykge1xuICAgICAgICAgICAgZGVmYXVsdHMuYWdlbnQgKz0gJyAnICsga2V5ICsgJy8nICsgb3B0aW9ucy5hZ2VudHNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRyZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHV0aWxfZGVmYXVsdHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChkZWZhdWx0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cblxuXG5cblxudmFyIEJ1ZmZlclV0aWxzID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgQXJyYXlCdWZmZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFycmF5QnVmZmVyO1xuXHR2YXIgYXRvYiA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXRvYjtcblx0dmFyIFRleHRFbmNvZGVyID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5UZXh0RW5jb2Rlcjtcblx0dmFyIFRleHREZWNvZGVyID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5UZXh0RGVjb2Rlcjtcblx0dmFyIGJhc2U2NENoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cdHZhciBoZXhDaGFyU2V0ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG5cdGZ1bmN0aW9uIGlzV29yZEFycmF5KG9iKSB7IHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLnNpZ0J5dGVzICE9PSB1bmRlZmluZWQ7IH1cblx0ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihvYikgeyByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7IH1cblx0ZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iKSB7IHJldHVybiBBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iKTsgfVxuXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vam9ubGVpZ2h0b24vOTU4ODQxL3Jhdy9mMjAwZTMwZGZlOTUyMTJjMDE2NWNjZjFhZTAwMGNhNTFlOWRlODAzL2dpc3RmaWxlMS5qc1xuXHRmdW5jdGlvbiB1aW50OFZpZXdUb0Jhc2U2NChieXRlcykge1xuXHRcdHZhciBiYXNlNjQgICAgPSAnJ1xuXHRcdHZhciBlbmNvZGluZ3MgPSBiYXNlNjRDaGFyU2V0O1xuXG5cdFx0dmFyIGJ5dGVMZW5ndGggICAgPSBieXRlcy5ieXRlTGVuZ3RoXG5cdFx0dmFyIGJ5dGVSZW1haW5kZXIgPSBieXRlTGVuZ3RoICUgM1xuXHRcdHZhciBtYWluTGVuZ3RoICAgID0gYnl0ZUxlbmd0aCAtIGJ5dGVSZW1haW5kZXJcblxuXHRcdHZhciBhLCBiLCBjLCBkXG5cdFx0dmFyIGNodW5rXG5cblx0XHQvLyBNYWluIGxvb3AgZGVhbHMgd2l0aCBieXRlcyBpbiBjaHVua3Mgb2YgM1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWFpbkxlbmd0aDsgaSA9IGkgKyAzKSB7XG5cdFx0XHQvLyBDb21iaW5lIHRoZSB0aHJlZSBieXRlcyBpbnRvIGEgc2luZ2xlIGludGVnZXJcblx0XHRcdGNodW5rID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl1cblxuXHRcdFx0Ly8gVXNlIGJpdG1hc2tzIHRvIGV4dHJhY3QgNi1iaXQgc2VnbWVudHMgZnJvbSB0aGUgdHJpcGxldFxuXHRcdFx0YSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxOCAvLyAxNjUxNTA3MiA9ICgyXjYgLSAxKSA8PCAxOFxuXHRcdFx0YiA9IChjaHVuayAmIDI1ODA0OCkgICA+PiAxMiAvLyAyNTgwNDggICA9ICgyXjYgLSAxKSA8PCAxMlxuXHRcdFx0YyA9IChjaHVuayAmIDQwMzIpICAgICA+PiAgNiAvLyA0MDMyICAgICA9ICgyXjYgLSAxKSA8PCA2XG5cdFx0XHRkID0gY2h1bmsgJiA2MyAgICAgICAgICAgICAgIC8vIDYzICAgICAgID0gMl42IC0gMVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRoZSByYXcgYmluYXJ5IHNlZ21lbnRzIHRvIHRoZSBhcHByb3ByaWF0ZSBBU0NJSSBlbmNvZGluZ1xuXHRcdFx0YmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXVxuXHRcdH1cblxuXHRcdC8vIERlYWwgd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzIGFuZCBwYWRkaW5nXG5cdFx0aWYgKGJ5dGVSZW1haW5kZXIgPT0gMSkge1xuXHRcdFx0Y2h1bmsgPSBieXRlc1ttYWluTGVuZ3RoXVxuXG5cdFx0XHRhID0gKGNodW5rICYgMjUyKSA+PiAyIC8vIDI1MiA9ICgyXjYgLSAxKSA8PCAyXG5cblx0XHRcdC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cblx0XHRcdGIgPSAoY2h1bmsgJiAzKSAgIDw8IDQgLy8gMyAgID0gMl4yIC0gMVxuXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgJz09J1xuXHRcdH0gZWxzZSBpZiAoYnl0ZVJlbWFpbmRlciA9PSAyKSB7XG5cdFx0XHRjaHVuayA9IChieXRlc1ttYWluTGVuZ3RoXSA8PCA4KSB8IGJ5dGVzW21haW5MZW5ndGggKyAxXVxuXG5cdFx0XHRhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwIC8vIDY0NTEyID0gKDJeNiAtIDEpIDw8IDEwXG5cdFx0XHRiID0gKGNodW5rICYgMTAwOCkgID4+ICA0IC8vIDEwMDggID0gKDJeNiAtIDEpIDw8IDRcblxuXHRcdFx0Ly8gU2V0IHRoZSAyIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuXHRcdFx0YyA9IChjaHVuayAmIDE1KSAgICA8PCAgMiAvLyAxNSAgICA9IDJeNCAtIDFcblxuXHRcdFx0YmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArICc9J1xuXHRcdH1cblxuXHRcdHJldHVybiBiYXNlNjRcblx0fVxuXG5cdGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoYmFzZTY0KSB7XG5cdFx0dmFyIGJpbmFyeV9zdHJpbmcgPSAgYXRvYihiYXNlNjQpO1xuXHRcdHZhciBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSggbGVuICk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgICAgICAgIHtcblx0XHRcdHZhciBhc2NpaSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcblx0XHRcdGJ5dGVzW2ldID0gYXNjaWk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlcy5idWZmZXI7XG5cdH1cblxuXHQvKiBNb3N0IEJ1ZmZlclV0aWxzIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBiaW5hcnkgb2JqZWN0IHJldHVybiBhbiBBcnJheUJ1ZmZlclxuXHQgKiBpZiBzdXBwb3J0ZWQsIGVsc2UgYSBDcnlwdG9KUyBXb3JkQXJyYXkuIFRoZSBleGNlcHRpb24gaXMgdG9CdWZmZXIsIHdoaWNoXG5cdCAqIHJldHVybnMgYSBVaW50OEFycmF5IChhbmQgd29uJ3Qgd29yayBvbiBicm93c2VycyB0b28gb2xkIHRvIHN1cHBvcnQgaXQpICovXG5cdGZ1bmN0aW9uIEJ1ZmZlclV0aWxzKCkge31cblxuXHRCdWZmZXJVdGlscy5iYXNlNjRDaGFyU2V0ID0gYmFzZTY0Q2hhclNldDtcblx0QnVmZmVyVXRpbHMuaGV4Q2hhclNldCA9IGhleENoYXJTZXQ7XG5cblx0dmFyIGlzQnVmZmVyID0gQnVmZmVyVXRpbHMuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHsgcmV0dXJuIGlzQXJyYXlCdWZmZXIoYnVmKSB8fCBpc1dvcmRBcnJheShidWYpIHx8IGlzVHlwZWRBcnJheShidWYpOyB9O1xuXG5cdC8qIEluIGJyb3dzZXJzLCByZXR1cm5zIGEgVWludDhBcnJheSAqL1xuXHR2YXIgdG9CdWZmZXIgPSBCdWZmZXJVdGlscy50b0J1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKCFBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0byBCdWZmZXI6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbmVjZXNzYXJ5IHR5cGVzXCIpO1xuXHRcdH1cblxuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zik7XG5cdFx0fVxuXG5cdFx0aWYoaXNUeXBlZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyKTtcblx0XHR9XG5cblx0XHRpZihpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHQvKiBCYWNrcG9ydGVkIGZyb20gdW5yZWxlYXNlZCBDcnlwdG9KU1xuXHRcdFx0KiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9zb3VyY2UvYnJvd3NlL2JyYW5jaGVzLzMueC9zcmMvbGliLXR5cGVkYXJyYXlzLmpzP3I9NjYxICovXG5cdFx0XHR2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmLnNpZ0J5dGVzKTtcblx0XHRcdHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLnNpZ0J5dGVzOyBpKyspIHtcblx0XHRcdFx0dWludDhWaWV3W2ldID0gKGJ1Zi53b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1aW50OFZpZXc7XG5cdFx0fTtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlclV0aWxzLnRvQnVmZmVyIGV4cGVjdGVkIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5XCIpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikpIHtcblx0XHRcdHJldHVybiBidWY7XG5cdFx0fVxuXHRcdHJldHVybiB0b0J1ZmZlcihidWYpLmJ1ZmZlcjtcblx0fTtcblxuXHRCdWZmZXJVdGlscy50b1dvcmRBcnJheSA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzVHlwZWRBcnJheShidWYpKSB7XG5cdFx0XHRidWYgPSBidWYuYnVmZmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNXb3JkQXJyYXkoYnVmKSA/IGJ1ZiA6IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuY3JlYXRlKGJ1Zik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNXb3JkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wic3RyaW5naWZ5XCJdKShidWYpO1xuXHRcdH1cblx0XHRyZXR1cm4gdWludDhWaWV3VG9CYXNlNjQodG9CdWZmZXIoYnVmKSk7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0aWYoQXJyYXlCdWZmZXIgJiYgYXRvYikge1xuXHRcdFx0cmV0dXJuIGJhc2U2NFRvQXJyYXlCdWZmZXIoc3RyKTtcblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicGFyc2VcIl0pKHN0cik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuaGV4RW5jb2RlID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKTtcblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzdHJpbmdpZnlcIl0pKGJ1Zik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuaGV4RGVjb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0dmFyIHdvcmRBcnJheSA9IE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wicGFyc2VcIl0pKHN0cmluZyk7XG5cdFx0cmV0dXJuIEFycmF5QnVmZmVyID8gQnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcih3b3JkQXJyYXkpIDogd29yZEFycmF5O1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRpZihUZXh0RW5jb2Rlcikge1xuXHRcdFx0cmV0dXJuIChuZXcgVGV4dEVuY29kZXIoKSkuZW5jb2RlKHN0cmluZykuYnVmZmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicGFyc2VcIl0pKHN0cmluZyk7XG5cdH07XG5cblx0LyogRm9yIHV0ZjggZGVjb2Rpbmcgd2UgYXBwbHkgc2xpZ2h0bHkgc3RyaWN0ZXIgaW5wdXQgdmFsaWRhdGlvbiB0aGFuIHRvXG5cdCAqIGhleEVuY29kZS9iYXNlNjRFbmNvZGUvZXRjOiBpbiB0aG9zZSB3ZSBhY2NlcHQgYW55dGhpbmcgdGhhdCBCdWZmZXIuZnJvbVxuXHQgKiBjYW4gdGFrZSAoaW4gcGFydGljdWxhciBhbGxvd2luZyBzdHJpbmdzLCB3aGljaCBhcmUganVzdCBpbnRlcnByZXRlZCBhc1xuXHQgKiBiaW5hcnkpOyBoZXJlIHdlIGVuc3VyZSB0aGF0IHRoZSBpbnB1dCBpcyBhY3R1YWxseSBhIGJ1ZmZlciBzaW5jZSB0cnlpbmdcblx0ICogdG8gdXRmOC1kZWNvZGUgYSBzdHJpbmcgdG8gYW5vdGhlciBzdHJpbmcgaXMgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UgKi9cblx0QnVmZmVyVXRpbHMudXRmOERlY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKCFpc0J1ZmZlcihidWYpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCBvZiB1dGY4ZGVjb2RlIHRvIGJlIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5XCIpO1xuXHRcdH1cblx0XHRpZihUZXh0RGVjb2RlciAmJiAhaXNXb3JkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIChuZXcgVGV4dERlY29kZXIoKSkuZGVjb2RlKGJ1Zik7XG5cdFx0fVxuXHRcdGJ1ZiA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1Zik7XG5cdFx0cmV0dXJuIE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5idWZmZXJDb21wYXJlID0gZnVuY3Rpb24oYnVmMSwgYnVmMikge1xuXHRcdGlmKCFidWYxKSByZXR1cm4gLTE7XG5cdFx0aWYoIWJ1ZjIpIHJldHVybiAxO1xuXHRcdGJ1ZjEgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYxKTtcblx0XHRidWYyID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmMik7XG5cdFx0YnVmMS5jbGFtcCgpOyBidWYyLmNsYW1wKCk7XG5cblx0XHR2YXIgY21wID0gYnVmMS5zaWdCeXRlcyAtIGJ1ZjIuc2lnQnl0ZXM7XG5cdFx0aWYoY21wICE9IDApIHJldHVybiBjbXA7XG5cdFx0YnVmMSA9IGJ1ZjEud29yZHM7IGJ1ZjIgPSBidWYyLndvcmRzO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBidWYxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjbXAgPSBidWYxW2ldIC0gYnVmMltpXTtcblx0XHRcdGlmKGNtcCAhPSAwKSByZXR1cm4gY21wO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpIHx8IGlzVHlwZWRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ5dGVMZW5ndGhcblx0XHR9IGVsc2UgaWYoaXNXb3JkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIGJ1Zi5zaWdCeXRlcztcblx0XHR9XG5cdH07XG5cblx0LyogUmV0dXJucyBBcnJheUJ1ZmZlciBvbiBicm93c2VyIGFuZCBCdWZmZXIgb24gTm9kZS5qcyAqL1xuXHRCdWZmZXJVdGlscy50eXBlZEFycmF5VG9CdWZmZXIgPSBmdW5jdGlvbih0eXBlZEFycmF5KSB7XG5cdFx0cmV0dXJuIHR5cGVkQXJyYXkuYnVmZmVyO1xuXHR9O1xuXG5cdHJldHVybiBCdWZmZXJVdGlscztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQnVmZmVyVXRpbHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblxuXG52YXIgSHR0cCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIEh0dHAoKSB7fVxuXG5cdHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcblx0XHQvKiBJRSA4ICovXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHNob3VsZEZhbGxiYWNrKGVycikge1xuXHRcdHZhciBzdGF0dXNDb2RlID0gZXJyLnN0YXR1c0NvZGU7XG5cdFx0LyogNDAwICsgbm8gY29kZSA9IGEgZ2VuZXJpYyB4aHIgb25lcnJvci4gQnJvd3NlciBkb2Vzbid0IGdpdmUgdXMgZW5vdWdoXG5cdFx0ICogZGV0YWlsIHRvIGtub3cgd2hldGhlciBpdCdzIGZhbGxiYWNrLWZpeGFibGUsIGJ1dCBpdCBtYXkgYmUgKGVnIGlmIGFcblx0XHQgKiBuZXR3b3JrIGlzc3VlKSwgc28gdHJ5IGp1c3QgaW4gY2FzZSAqL1xuXHRcdHJldHVybiAoc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnIuY29kZSkgfHxcblx0XHRcdChzdGF0dXNDb2RlID09PSA0MDAgJiYgIWVyci5jb2RlKSAgICAgIHx8XG5cdFx0XHQoc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SG9zdHMoY2xpZW50KSB7XG5cdFx0LyogSWYgd2UncmUgYSBjb25uZWN0ZWQgcmVhbHRpbWUgY2xpZW50LCB0cnkgdGhlIGVuZHBvaW50IHdlJ3JlIGNvbm5lY3RlZFxuXHRcdCAqIHRvIGZpcnN0IC0tIGJ1dCBzdGlsbCBoYXZlIGZhbGxiYWNrcywgYmVpbmcgY29ubmVjdGVkIGlzIG5vdCBhbiBhYnNvbHV0ZVxuXHRcdCAqIGd1YXJhbnRlZSB0aGF0IGEgZGF0YWNlbnRlciBoYXMgZnJlZSBjYXBhY2l0eSB0byBzZXJ2aWNlIFJFU1QgcmVxdWVzdHMuICovXG5cdFx0dmFyIGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbixcblx0XHRcdGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG5cblx0XHRpZihjb25uZWN0aW9uSG9zdCkge1xuXHRcdFx0cmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG5cdH1cblx0SHR0cC5fZ2V0SG9zdHMgPSBnZXRIb3N0cztcblxuXHRIdHRwLm1ldGhvZHMgPSBbJ2dldCcsICdkZWxldGUnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXTtcblx0SHR0cC5tZXRob2RzV2l0aG91dEJvZHkgPSBbJ2dldCcsICdkZWxldGUnXTtcblx0SHR0cC5tZXRob2RzV2l0aEJvZHkgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyU3VidHJhY3QoSHR0cC5tZXRob2RzLCBIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSk7XG5cblx0LyogLSBIdHRwLmdldCwgSHR0cC5wb3N0LCBIdHRwLnB1dCwgLi4uXG5cdCAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGZvciBhIGdpdmVuIHBhdGggYWdhaW5zdCBwcmltZSBhbmQgZmFsbGJhY2sgQWJseSBob3N0c1xuXHQgKiBAcGFyYW0gcmVzdFxuXHQgKiBAcGFyYW0gcGF0aCB0aGUgZnVsbCBwYXRoXG5cdCAqIEBwYXJhbSBoZWFkZXJzIG9wdGlvbmFsIGhhc2ggb2YgaGVhZGVyc1xuXHQgKiBbb25seSBmb3IgbWV0aG9kcyB3aXRoIGJvZHk6IEBwYXJhbSBib2R5IG9iamVjdCBvciBidWZmZXIgY29udGFpbmluZyByZXF1ZXN0IGJvZHldXG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHJlc3BvbnNlKVxuXHQgKlxuXHQgKiAtIEh0dHAuZ2V0VXJpLCBIdHRwLnBvc3RVcmksIEh0dHAucHV0VXJpLCAuLi5cblx0ICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gZnVsbCBVUklcblx0ICogQHBhcmFtIHJlc3Rcblx0ICogQHBhcmFtIHVyaSB0aGUgZnVsbCBVUklcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXG5cdCAqIFtvbmx5IGZvciBtZXRob2RzIHdpdGggYm9keTogQHBhcmFtIGJvZHkgb2JqZWN0IG9yIGJ1ZmZlciBjb250YWluaW5nIHJlcXVlc3QgYm9keV1cblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0SHR0cFttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cFsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIG51bGwsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdFx0SHR0cFttZXRob2QgKyAnVXJpJ10gPSBmdW5jdGlvbihyZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIG51bGwsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKEh0dHAubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRIdHRwW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRIdHRwWydkbyddKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0XHRIdHRwW21ldGhvZCArICdVcmknXSA9IGZ1bmN0aW9uKHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0fSk7XG5cblx0LyogVW5saWtlIGZvciBkb1VyaSwgdGhlICdyZXN0JyBwYXJhbSBoZXJlIGlzIG1hbmRhdG9yeSwgYXMgaXQncyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBob3N0cyAqL1xuXHRIdHRwWydkbyddID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciB1cmlGcm9tSG9zdCA9ICh0eXBlb2YocGF0aCkgPT0gJ2Z1bmN0aW9uJykgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gcmVzdC5iYXNlVXJpKGhvc3QpICsgcGF0aDsgfTtcblx0XHR2YXIgYmluYXJ5ID0gKGhlYWRlcnMgJiYgaGVhZGVycy5hY2NlcHQgIT0gJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR2YXIgZG9BcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0dmFyIGN1cnJlbnRGYWxsYmFjayA9IHJlc3QuX2N1cnJlbnRGYWxsYmFjaztcblx0XHRpZihjdXJyZW50RmFsbGJhY2spIHtcblx0XHRcdGlmKGN1cnJlbnRGYWxsYmFjay52YWxpZFVudGlsID4gbm93KCkpIHtcblx0XHRcdFx0LyogVXNlIHN0b3JlZCBmYWxsYmFjayAqL1xuXHRcdFx0XHRIdHRwLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChjdXJyZW50RmFsbGJhY2suaG9zdCksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikpIHtcblx0XHRcdFx0XHRcdC8qIHVuc3RvcmUgdGhlIGZhbGxiYWNrIGFuZCBzdGFydCBmcm9tIHRoZSB0b3Agd2l0aCB0aGUgZGVmYXVsdCBzZXF1ZW5jZSAqL1xuXHRcdFx0XHRcdFx0cmVzdC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdEh0dHBbJ2RvJ10uYXBwbHkoSHR0cCwgZG9BcmdzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIEZhbGxiYWNrIGV4cGlyZWQ7IHJlbW92ZSBpdCBhbmQgZmFsbHRocm91Z2ggdG8gbm9ybWFsIHNlcXVlbmNlICovXG5cdFx0XHRcdHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhvc3RzID0gZ2V0SG9zdHMocmVzdCk7XG5cblx0XHQvKiBpZiB0aGVyZSBpcyBvbmx5IG9uZSBob3N0IGRvIGl0ICovXG5cdFx0aWYoaG9zdHMubGVuZ3RoID09IDEpIHtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIGhvc3RzIGlzIGFuIGFycmF5IHdpdGggcHJlZmVycmVkIGhvc3QgcGx1cyBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgKi9cblx0XHR2YXIgdHJ5QUhvc3QgPSBmdW5jdGlvbihjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2Vzcykge1xuXHRcdFx0dmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHBlcnNpc3RPblN1Y2Nlc3MpIHtcblx0XHRcdFx0XHQvKiBSU0MxNWYgKi9cblx0XHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG5cdFx0XHRcdFx0XHRob3N0OiBob3N0LFxuXHRcdFx0XHRcdFx0dmFsaWRVbnRpbDogbm93KCkgKyByZXN0Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHRyeUFIb3N0KGhvc3RzKTtcblx0fTtcblxuXHRIdHRwLmRvVXJpID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRIdHRwLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdEh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycyA9IGZhbHNlO1xuXHRIdHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPSBmYWxzZTtcblx0cmV0dXJuIEh0dHA7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEh0dHApO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG5cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuXHRcdHRoaXMuYW55ID0gW107XG5cdFx0dGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdHRoaXMuZXZlbnRzT25jZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdH1cblxuXHQvKiBDYWxsIHRoZSBsaXN0ZW5lciwgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIGxvZywgYnV0IGNvbnRpbnVlIG9wZXJhdGlvbiovXG5cdGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGxpc3RlbmVyLmFwcGx5KGV2ZW50VGhpcywgYXJncyk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdFdmVudEVtaXR0ZXIuZW1pdCgpJywgJ1VuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIChlICYmIGUuc3RhY2spKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGxpc3RlbmVycyB0aGF0IG1hdGNoIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB0YXJnZXRMaXN0ZW5lcnMgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgYXJyYXlzIG9yIGV2ZW50IG9iamVjdHMgd2l0aCBhcnJheXMgb2YgbGlzdGVuZXJzXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSBldmVudEZpbHRlciAob3B0aW9uYWwpIGV2ZW50IG5hbWUgaW5zdHJ1Y3RpbmcgdGhlIGZ1bmN0aW9uIHRvIG9ubHkgcmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcblx0XHR2YXIgbGlzdGVuZXJzLCBpZHgsIGV2ZW50TmFtZSwgdGFyZ2V0TGlzdGVuZXJzSW5kZXg7XG5cblx0XHRmb3IgKHRhcmdldExpc3RlbmVyc0luZGV4ID0gMDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPCB0YXJnZXRMaXN0ZW5lcnMubGVuZ3RoOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCsrKSB7XG5cdFx0XHRsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xuXHRcdFx0aWYgKGV2ZW50RmlsdGVyKSB7IGxpc3RlbmVycyA9IGxpc3RlbmVyc1tldmVudEZpbHRlcl07IH1cblxuXHRcdFx0aWYgKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkobGlzdGVuZXJzKSkge1xuXHRcdFx0XHR3aGlsZSAoKGlkeCA9IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YobGlzdGVuZXJzLCBsaXN0ZW5lcikpICE9PSAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBJZiBldmVudHMgb2JqZWN0IGhhcyBhbiBldmVudCBuYW1lIGtleSB3aXRoIG5vIGxpc3RlbmVycyB0aGVuXG5cdFx0XHRcdCAgIHJlbW92ZSB0aGUga2V5IHRvIHN0b3AgdGhlIGxpc3QgZ3Jvd2luZyBpbmRlZmluaXRlbHkgKi9cblx0XHRcdFx0aWYgKGV2ZW50RmlsdGVyICYmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdW2V2ZW50RmlsdGVyXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc09iamVjdChsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdC8qIGV2ZW50cyAqL1xuXHRcdFx0XHRmb3IgKGV2ZW50TmFtZSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUxpc3RlbmVyKFtsaXN0ZW5lcnNdLCBsaXN0ZW5lciwgZXZlbnROYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cblx0ICogICAgICAgIGlmIG5vdCBzdXBwbGllZCwgYWxsIGV2ZW50cyB0cmlnZ2VyIGEgY2FsbCB0byB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmFueS5wdXNoKGV2ZW50KTtcblx0XHR9IGVsc2UgaWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkpIHtcblx0XHRcdHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGV2ZW50KSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0c2VsZi5vbihldiwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbXSkpO1xuXHRcdFx0bGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIG9uZSBvciBtb3JlIGV2ZW50IGxpc3RlbmVyc1xuXHQgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgd2hvc2UgbGlzdGVuZXJcblx0ICogICAgICAgIGlzIHRvIGJlIHJlbW92ZWQuIElmIG5vdCBzdXBwbGllZCwgdGhlIGxpc3RlbmVyIGlzXG5cdCAqICAgICAgICB0cmVhdGVkIGFzIGFuICdhbnknIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciAob3B0aW9uYWwpIHRoZSBsaXN0ZW5lciB0byByZW1vdmUuIElmIG5vdFxuXHQgKiAgICAgICAgc3VwcGxpZWQsIGFsbCBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCB8fCAoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhsaXN0ZW5lcikpKSB7XG5cdFx0XHR0aGlzLmFueSA9IFtdO1xuXHRcdFx0dGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0dGhpcy5hbnlPbmNlID0gW107XG5cdFx0XHR0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcblx0XHRcdGlmKHR5cGVvZihldmVudCkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvKiB3ZSB0YWtlIHRoaXMgdG8gYmUgdGhlIGxpc3RlbmVyIGFuZCB0cmVhdCB0aGUgZXZlbnQgYXMgXCJhbnlcIiAuLiAqL1xuXHRcdFx0XHRsaXN0ZW5lciA9IGV2ZW50O1xuXHRcdFx0XHRldmVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvKiAuLi4gb3Igd2UgdGFrZSBldmVudCB0byBiZSB0aGUgYWN0dWFsIGV2ZW50IG5hbWUgYW5kIGxpc3RlbmVyIHRvIGJlIGFsbCAqL1xuXHRcdH1cblxuXHRcdGlmKGxpc3RlbmVyICYmIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoZXZlbnQpKSB7XG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihbdGhpcy5hbnksIHRoaXMuZXZlbnRzLCB0aGlzLmFueU9uY2UsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGV2ZW50KSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0c2VsZi5vZmYoZXYsIGxpc3RlbmVyKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qIFwibm9ybWFsXCIgY2FzZSB3aGVyZSBldmVudCBpcyBhbiBhY3R1YWwgZXZlbnQgKi9cblx0XHRpZihsaXN0ZW5lcikge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudDsgZXhjbHVkZXMgb25jZSBldmVudHNcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xuXHQgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYoZXZlbnQpIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKTtcblx0XHRcdGlmKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5ldmVudHNPbmNlW2V2ZW50XSk7XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA/IGxpc3RlbmVycyA6IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmFueS5sZW5ndGggPyB0aGlzLmFueSA6IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYW4gZXZlbnRcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50ICAvKiAsIGFyZ3MuLi4gKi8pIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0dmFyIGV2ZW50VGhpcyA9IHtldmVudDpldmVudH07XG5cdFx0dmFyIGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0aWYodGhpcy5hbnlPbmNlLmxlbmd0aCkge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueU9uY2UpO1xuXHRcdFx0dGhpcy5hbnlPbmNlID0gW107XG5cdFx0fVxuXHRcdGlmKHRoaXMuYW55Lmxlbmd0aCkge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG5cdFx0fVxuXHRcdHZhciBldmVudHNPbmNlTGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcblx0XHRpZihldmVudHNPbmNlTGlzdGVuZXJzKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c09uY2VMaXN0ZW5lcnMpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG5cdFx0fVxuXHRcdHZhciBldmVudHNMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF07XG5cdFx0aWYoZXZlbnRzTGlzdGVuZXJzKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIGV2ZW50c0xpc3RlbmVycyk7XG5cdFx0fVxuXG5cdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0XHRjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncyk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhbiBldmVudFxuXHQgKiBAcGFyYW0gZXZlbnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCwgc2VsZiA9IHRoaXM7XG5cdFx0aWYoKGFyZ0NvdW50ID09PSAwIHx8IChhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpKSAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UpIHtcblx0XHRcdHJldHVybiBuZXcgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdFx0c2VsZi5vbmNlKGV2ZW50LCByZXNvbHZlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmFueU9uY2UucHVzaChldmVudCk7XG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLmFueU9uY2UucHVzaChsaXN0ZW5lcik7XG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZXZlbnQpKXtcblx0XHRcdHZhciBsaXN0ZW5lcldyYXBwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdHNlbGYub2ZmKGV2LCBsaXN0ZW5lcldyYXBwZXIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHR9O1xuXHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0c2VsZi5vbihldiwgbGlzdGVuZXJXcmFwcGVyKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzT25jZVtldmVudF0gfHwgKHRoaXMuZXZlbnRzT25jZVtldmVudF0gPSBbXSkpO1xuXHRcdFx0bGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJpdmF0ZSBBUElcblx0ICpcblx0ICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGEgc3RhdGUgZXZlbnQgYW5kIGZpcmUgaW1tZWRpYXRlbHkgaWYgY3VycmVudFN0YXRlIG1hdGNoZXMgdGFyZ2V0U3RhdGVcblx0ICogQHBhcmFtIHRhcmdldFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSBldmVudCB0byBsaXN0ZW4gdG9cblx0ICogQHBhcmFtIGN1cnJlbnRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIG9iamVjdFxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbih0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCBsaXN0ZW5lciAvKiAuLi5saXN0ZW5lckFyZ3MgKi8pIHtcblx0XHR2YXIgZXZlbnRUaGlzID0ge2V2ZW50OnRhcmdldFN0YXRlfSxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0bGlzdGVuZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuXHRcdGlmKCh0eXBlb2YodGFyZ2V0U3RhdGUpICE9PSAnc3RyaW5nJykgfHwgKHR5cGVvZihjdXJyZW50U3RhdGUpICE9PSAnc3RyaW5nJykpIHtcblx0XHRcdHRocm93KFwid2hlblN0YXRlIHJlcXVpcmVzIGEgdmFsaWQgZXZlbnQgU3RyaW5nIGFyZ3VtZW50XCIpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdFx0XHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlLmFwcGx5KHNlbGYsIFt0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCByZXNvbHZlXS5jb25jYXQobGlzdGVuZXJBcmdzKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuXHRcdFx0Y2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGxpc3RlbmVyQXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub25jZSh0YXJnZXRTdGF0ZSwgbGlzdGVuZXIpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBFdmVudEVtaXR0ZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEV2ZW50RW1pdHRlcik7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblxuXG5cblxudmFyIFByb3RvY29sTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBQcm90b2NvbE1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5mbGFncyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZXN0YW1wID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY291bnQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lcnJvciA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2hhbm5lbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNoYW5uZWxTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5tc2dTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnByZXNlbmNlID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuYXV0aCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnBhcmFtcyA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhciBhY3Rpb25zID0gUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiA9IHtcblx0XHQnSEVBUlRCRUFUJyA6IDAsXG5cdFx0J0FDSycgOiAxLFxuXHRcdCdOQUNLJyA6IDIsXG5cdFx0J0NPTk5FQ1QnIDogMyxcblx0XHQnQ09OTkVDVEVEJyA6IDQsXG5cdFx0J0RJU0NPTk5FQ1QnIDogNSxcblx0XHQnRElTQ09OTkVDVEVEJyA6IDYsXG5cdFx0J0NMT1NFJyA6IDcsXG5cdFx0J0NMT1NFRCcgOiA4LFxuXHRcdCdFUlJPUicgOiA5LFxuXHRcdCdBVFRBQ0gnIDogMTAsXG5cdFx0J0FUVEFDSEVEJyA6IDExLFxuXHRcdCdERVRBQ0gnIDogMTIsXG5cdFx0J0RFVEFDSEVEJyA6IDEzLFxuXHRcdCdQUkVTRU5DRScgOiAxNCxcblx0XHQnTUVTU0FHRScgOiAxNSxcblx0XHQnU1lOQycgOiAxNixcblx0XHQnQVVUSCcgOiAxN1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5jaGFubmVsTW9kZXMgPSBbICdQUkVTRU5DRScsICdQVUJMSVNIJywgJ1NVQlNDUklCRScsICdQUkVTRU5DRV9TVUJTQ1JJQkUnIF07XG5cblx0UHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWUgPSBbXTtcblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ua2V5c0FycmF5KFByb3RvY29sTWVzc2FnZS5BY3Rpb24sIHRydWUpLCBmdW5jdGlvbihuYW1lKSB7XG5cdFx0UHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbYWN0aW9uc1tuYW1lXV0gPSBuYW1lO1xuXHR9KTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0LyogQ2hhbm5lbCBhdHRhY2ggc3RhdGUgZmxhZ3MgKi9cblx0XHQnSEFTX1BSRVNFTkNFJzogICAgICAgMSA8PCAwLFxuXHRcdCdIQVNfQkFDS0xPRyc6ICAgICAgICAxIDw8IDEsXG5cdFx0J1JFU1VNRUQnOiAgICAgICAgICAgIDEgPDwgMixcblx0XHQnVFJBTlNJRU5UJzogICAgICAgICAgMSA8PCA0LFxuXHRcdCdBVFRBQ0hfUkVTVU1FJzogICAgICAxIDw8IDUsXG5cdFx0LyogQ2hhbm5lbCBtb2RlIGZsYWdzICovXG5cdFx0J1BSRVNFTkNFJzogICAgICAgICAgIDEgPDwgMTYsXG5cdFx0J1BVQkxJU0gnOiAgICAgICAgICAgIDEgPDwgMTcsXG5cdFx0J1NVQlNDUklCRSc6ICAgICAgICAgIDEgPDwgMTgsXG5cdFx0J1BSRVNFTkNFX1NVQlNDUklCRSc6IDEgPDwgMTlcblx0fTtcblx0dmFyIGZsYWdOYW1lcyA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ua2V5c0FycmF5KGZsYWdzKTtcblx0ZmxhZ3MuTU9ERV9BTEwgPSBmbGFncy5QUkVTRU5DRSB8IGZsYWdzLlBVQkxJU0ggfCBmbGFncy5TVUJTQ1JJQkUgfCBmbGFncy5QUkVTRU5DRV9TVUJTQ1JJQkU7XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5oYXNGbGFnID0gZnVuY3Rpb24oZmxhZykge1xuXHRcdHJldHVybiAoKHRoaXMuZmxhZ3MgJiBmbGFnc1tmbGFnXSkgPiAwKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLnNldEZsYWcgPSBmdW5jdGlvbihmbGFnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHwgZmxhZ3NbZmxhZ107XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmxhZ3MgJiYgKHRoaXMuZmxhZ3MgJiBmbGFncy5NT0RFX0FMTCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVNb2Rlc1RvRmxhZ3MgPSBmdW5jdGlvbihtb2Rlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2gobW9kZXMsIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHRcdHNlbGYuc2V0RmxhZyhtb2RlKTtcblx0XHR9KTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmRlY29kZU1vZGVzRnJvbUZsYWdzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vZGVzID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goUHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcywgZnVuY3Rpb24obW9kZSkge1xuXHRcdFx0aWYoc2VsZi5oYXNGbGFnKG1vZGUpKSB7XG5cdFx0XHRcdG1vZGVzLnB1c2gobW9kZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG1vZGVzLmxlbmd0aCA+IDAgPyBtb2RlcyA6IHVuZGVmaW5lZDtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2Uuc2VyaWFsaXplID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5lbmNvZGVCb2R5O1xuXG5cdFByb3RvY29sTWVzc2FnZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGZvcm1hdCkge1xuXHRcdHZhciBkZXNlcmlhbGl6ZWQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZUJvZHkoc2VyaWFsaXplZCwgZm9ybWF0KTtcblx0XHRyZXR1cm4gUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRlc2VyaWFsaXplZCkge1xuXHRcdHZhciBlcnJvciA9IGRlc2VyaWFsaXplZC5lcnJvcjtcblx0XHRpZihlcnJvcikgZGVzZXJpYWxpemVkLmVycm9yID0gX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoZXJyb3IpO1xuXHRcdHZhciBtZXNzYWdlcyA9IGRlc2VyaWFsaXplZC5tZXNzYWdlcztcblx0XHRpZihtZXNzYWdlcykgZm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSBtZXNzYWdlc1tpXSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhtZXNzYWdlc1tpXSk7XG5cdFx0dmFyIHByZXNlbmNlID0gZGVzZXJpYWxpemVkLnByZXNlbmNlO1xuXHRcdGlmKHByZXNlbmNlKSBmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHByZXNlbmNlW2ldID0gX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMocHJlc2VuY2VbaV0sIHRydWUpO1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgZGVzZXJpYWxpemVkKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBQcm90b2NvbE1lc3NhZ2UoKSwgdmFsdWVzKTtcblx0fTtcblxuXHRmdW5jdGlvbiB0b1N0cmluZ0FycmF5KGFycmF5KSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGlmIChhcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQucHVzaChhcnJheVtpXS50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICdbICcgKyByZXN1bHQuam9pbignLCAnKSArICcgXSc7XG5cdH1cblxuXHR2YXIgc2ltcGxlQXR0cmlidXRlcyA9ICdpZCBjaGFubmVsIGNoYW5uZWxTZXJpYWwgY29ubmVjdGlvbklkIGNvbm5lY3Rpb25LZXkgY29ubmVjdGlvblNlcmlhbCBjb3VudCBtc2dTZXJpYWwgdGltZXN0YW1wJy5zcGxpdCgnICcpO1xuXG5cdFByb3RvY29sTWVzc2FnZS5zdHJpbmdpZnkgPSBmdW5jdGlvbihtc2cpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tQcm90b2NvbE1lc3NhZ2UnO1xuXHRcdGlmKG1zZy5hY3Rpb24gIT09IHVuZGVmaW5lZClcblx0XHRcdHJlc3VsdCArPSAnOyBhY3Rpb249JyArIFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IGZhbHNlO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZTtcblx0XHRmb3IgKHZhciBhdHRyaWJJbmRleCA9IDA7IGF0dHJpYkluZGV4IDwgc2ltcGxlQXR0cmlidXRlcy5sZW5ndGg7IGF0dHJpYkluZGV4KyspIHtcblx0XHRcdGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuXHRcdFx0aWYobXNnW2F0dHJpYnV0ZV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0cmVzdWx0ICs9ICc7ICcgKyBhdHRyaWJ1dGUgKyAnPScgKyBtc2dbYXR0cmlidXRlXTtcblx0XHR9XG5cblx0XHRpZihtc2cubWVzc2FnZXMpXG5cdFx0XHRyZXN1bHQgKz0gJzsgbWVzc2FnZXM9JyArIHRvU3RyaW5nQXJyYXkoX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XG5cdFx0aWYobXNnLnByZXNlbmNlKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHByZXNlbmNlPScgKyB0b1N0cmluZ0FycmF5KF9wcmVzZW5jZW1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzQXJyYXkobXNnLnByZXNlbmNlKSk7XG5cdFx0aWYobXNnLmVycm9yKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGVycm9yPScgKyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhtc2cuZXJyb3IpLnRvU3RyaW5nKCk7XG5cdFx0aWYobXNnLmF1dGggJiYgbXNnLmF1dGguYWNjZXNzVG9rZW4pXG5cdFx0XHRyZXN1bHQgKz0gJzsgdG9rZW49JyArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xuXHRcdGlmKG1zZy5mbGFncylcblx0XHRcdHJlc3VsdCArPSAnOyBmbGFncz0nICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGaWx0ZXIoZmxhZ05hbWVzLCBmdW5jdGlvbihmbGFnKSB7XG5cdFx0XHRcdHJldHVybiBtc2cuaGFzRmxhZyhmbGFnKTtcblx0XHRcdH0pLmpvaW4oJywnKTtcblx0XHRpZihtc2cucGFyYW1zKSB7XG5cdFx0XHR2YXIgc3RyaW5naWZpZWRQYXJhbXMgPSAnJztcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZm9ySW5Pd25Ob25OdWxsUHJvcHMobXNnLnBhcmFtcywgZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHN0cmluZ2lmaWVkUGFyYW1zICs9ICc7ICc7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyaW5naWZpZWRQYXJhbXMgKz0gcHJvcCArICc9JyArIG1zZy5wYXJhbXNbcHJvcF07XG5cdFx0XHR9KTtcblx0XHRcdGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJlc3VsdCArPSAnOyBwYXJhbXM9WycgKyBzdHJpbmdpZmllZFBhcmFtcyArICddJztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qIE9ubHkgdmFsaWQgZm9yIGNoYW5uZWwgbWVzc2FnZXMgKi9cblx0UHJvdG9jb2xNZXNzYWdlLmlzRHVwbGljYXRlID0gZnVuY3Rpb24oYSwgYikge1xuXHRcdGlmIChhICYmIGIpIHtcblx0XHRcdGlmICgoYS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fCBhLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSkgJiZcblx0XHRcdFx0KGEuYWN0aW9uID09PSBiLmFjdGlvbikgJiZcblx0XHRcdFx0KGEuY2hhbm5lbCA9PT0gYi5jaGFubmVsKSAmJlxuXHRcdFx0XHQoYS5pZCA9PT0gYi5pZCkpIHtcblx0XHRcdFx0aWYgKGEuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYS5tZXNzYWdlcy5sZW5ndGggPT09IGIubWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhLm1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgYU1lc3NhZ2UgPSBhLm1lc3NhZ2VzW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGJNZXNzYWdlID0gYi5tZXNzYWdlc1tpXTtcblx0XHRcdFx0XHRcdGlmICgoYU1lc3NhZ2UuZXh0cmFzICYmIGFNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJiBhTWVzc2FnZS5leHRyYXMuZGVsdGEuZm9ybWF0KSAhPT1cblx0XHRcdFx0XHRcdFx0KGJNZXNzYWdlLmV4dHJhcyAmJiBiTWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgYk1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdHJldHVybiBQcm90b2NvbE1lc3NhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb3RvY29sTWVzc2FnZSk7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG52YXIgTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBNZXNzYWdlKCkge1xuXHRcdHRoaXMubmFtZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZXN0YW1wID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xpZW50SWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVuY29kaW5nID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZXh0cmFzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc2l6ZSA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0TWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdGlkOiB0aGlzLmlkLFxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG5cdFx0XHRjb25uZWN0aW9uSWQ6IHRoaXMuY29ubmVjdGlvbklkLFxuXHRcdFx0Y29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5LFxuXHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmcsXG5cdFx0XHRleHRyYXM6IHRoaXMuZXh0cmFzXG5cdFx0fTtcblxuXHRcdC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuXHRcdCAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxuXHRcdCAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG5cdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cdFx0aWYoZGF0YSAmJiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvKiBzdHJpbmdpZnkgY2FsbCAqL1xuXHRcdFx0XHR2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuXHRcdFx0XHRyZXN1bHQuZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvYmFzZTY0JykgOiAnYmFzZTY0Jztcblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKGRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxuXHRcdFx0XHQgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcblx0XHRcdFx0ICogaW4gYnJvd3NlcnMpICovXG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW01lc3NhZ2UnO1xuXHRcdGlmKHRoaXMubmFtZSlcblx0XHRcdHJlc3VsdCArPSAnOyBuYW1lPScgKyB0aGlzLm5hbWU7XG5cdFx0aWYodGhpcy5pZClcblx0XHRcdHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcblx0XHRpZih0aGlzLnRpbWVzdGFtcClcblx0XHRcdHJlc3VsdCArPSAnOyB0aW1lc3RhbXA9JyArIHRoaXMudGltZXN0YW1wO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uSWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY29ubmVjdGlvbklkPScgKyB0aGlzLmNvbm5lY3Rpb25JZDtcblx0XHRpZih0aGlzLmVuY29kaW5nKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGVuY29kaW5nPScgKyB0aGlzLmVuY29kaW5nO1xuXHRcdGlmKHRoaXMuZXh0cmFzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGV4dHJhcyA9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcblx0XHRpZih0aGlzLmRhdGEpIHtcblx0XHRcdGlmICh0eXBlb2YodGhpcy5kYXRhKSA9PSAnc3RyaW5nJylcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcblx0XHRcdGVsc2UgaWYgKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIodGhpcy5kYXRhKSlcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChqc29uKT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcblx0XHR9XG5cdFx0aWYodGhpcy5leHRyYXMpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXh0cmFzPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdE1lc3NhZ2UuZW5jcnlwdCA9IGZ1bmN0aW9uKG1zZywgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHR2YXIgZGF0YSA9IG1zZy5kYXRhLFxuXHRcdFx0ZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcsXG5cdFx0XHRjaXBoZXIgPSBvcHRpb25zLmNoYW5uZWxDaXBoZXI7XG5cblx0XHRlbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy8nKSA6ICcnO1xuXHRcdGlmKCFwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RW5jb2RlKFN0cmluZyhkYXRhKSk7XG5cdFx0XHRlbmNvZGluZyA9IGVuY29kaW5nICsgJ3V0Zi04Lyc7XG5cdFx0fVxuXHRcdGNpcGhlci5lbmNyeXB0KGRhdGEsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRtc2cuZGF0YSA9IGRhdGE7XG5cdFx0XHRtc2cuZW5jb2RpbmcgPSBlbmNvZGluZyArICdjaXBoZXIrJyArIGNpcGhlci5hbGdvcml0aG07XG5cdFx0XHRjYWxsYmFjayhudWxsLCBtc2cpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24obXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBkYXRhID0gbXNnLmRhdGEsIGVuY29kaW5nLFxuXHRcdFx0bmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YoZGF0YSkgPT0gJ3N0cmluZycgfHwgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZDtcblxuXHRcdGlmICghbmF0aXZlRGF0YVR5cGUpIHtcblx0XHRcdGlmIChfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzT2JqZWN0KGRhdGEpIHx8IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRtc2cuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHRcdFx0XHRtc2cuZW5jb2RpbmcgPSAoZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcpID8gKGVuY29kaW5nICsgJy9qc29uJykgOiAnanNvbic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdEYXRhIHR5cGUgaXMgdW5zdXBwb3J0ZWQnLCA0MDAxMywgNDAwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5jaXBoZXIpIHtcblx0XHRcdE1lc3NhZ2UuZW5jcnlwdChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbXNnKTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZS5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBwcm9jZXNzZWQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2VzW2ldLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIG1zZykge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvY2Vzc2VkKys7XG5cdFx0XHRcdGlmIChwcm9jZXNzZWQgPT0gbWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbWVzc2FnZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZS5zZXJpYWxpemUgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVuY29kZUJvZHk7XG5cblx0TWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihtZXNzYWdlLCBjb250ZXh0KSB7XG5cdFx0LyogVGhlIHNlY29uZCBhcmd1bWVudCBjb3VsZCBiZSBlaXRoZXIgRW5jb2RpbmdEZWNvZGluZ0NvbnRleHQgdGhhdCBjb250YWlucyBDaGFubmVsT3B0aW9ucyBvciBDaGFubmVsT3B0aW9ucyAqL1xuXHRcdGlmKCFjb250ZXh0IHx8ICFjb250ZXh0LmNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hhbm5lbE9wdGlvbnMgPSBjb250ZXh0O1xuXHRcdFx0Y29udGV4dCA9IHtcblx0XHRcdFx0Y2hhbm5lbE9wdGlvbnM6IGNoYW5uZWxPcHRpb25zLFxuXHRcdFx0XHRwbHVnaW5zOiB7IH0sXG5cdFx0XHRcdGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB1bmRlZmluZWRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGxhc3RQYXlsb2FkID0gbWVzc2FnZS5kYXRhO1xuXHRcdHZhciBlbmNvZGluZyA9IG1lc3NhZ2UuZW5jb2Rpbmc7XG5cdFx0aWYoZW5jb2RpbmcpIHtcblx0XHRcdHZhciB4Zm9ybXMgPSBlbmNvZGluZy5zcGxpdCgnLycpLFxuXHRcdFx0XHRsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCwgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aCxcblx0XHRcdFx0ZGF0YSA9IG1lc3NhZ2UuZGF0YTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d2hpbGUoKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID0gZW5jb2RpbmdzVG9Qcm9jZXNzKSA+IDApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSB4Zm9ybXNbLS1lbmNvZGluZ3NUb1Byb2Nlc3NdLm1hdGNoKC8oW1xcLVxcd10rKShcXCsoW1xcd1xcLV0rKSk/Lyk7XG5cdFx0XHRcdFx0aWYoIW1hdGNoKSBicmVhaztcblx0XHRcdFx0XHR2YXIgeGZvcm0gPSBtYXRjaFsxXTtcblx0XHRcdFx0XHRzd2l0Y2goeGZvcm0pIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2Jhc2U2NCc6XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NERlY29kZShTdHJpbmcoZGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRpZihsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9PSB4Zm9ybXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBheWxvYWQgPSBkYXRhO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAndXRmLTgnOlxuXHRcdFx0XHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxuXHRcdFx0XHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRjYXNlICdjaXBoZXInOlxuXHRcdFx0XHRcdFx0XHRpZihjb250ZXh0LmNoYW5uZWxPcHRpb25zICE9IG51bGwgJiYgY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaXBoZXIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeGZvcm1BbGdvcml0aG0gPSBtYXRjaFszXSwgY2lwaGVyID0gY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuXHRcdFx0XHRcdFx0XHRcdC8qIGRvbid0IGF0dGVtcHQgdG8gZGVjcnlwdCB1bmxlc3MgdGhlIGNpcGhlciBwYXJhbXMgYXJlIGNvbXBhdGlibGUgKi9cblx0XHRcdFx0XHRcdFx0XHRpZih4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBnaXZlbiBjaXBoZXI7IGluY29tcGF0aWJsZSBjaXBoZXIgcGFyYW1zJyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBjaXBoZXIuZGVjcnlwdChkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2U7IG5vdCBhbiBlbmNyeXB0ZWQgY2hhbm5lbCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXNlICd2Y2RpZmYnOlxuXHRcdFx0XHRcdFx0XHRpZighY29udGV4dC5wbHVnaW5zIHx8ICFjb250ZXh0LnBsdWdpbnMudmNkaWZmKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpJywgNDAwMTksIDQwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRGVsdGEgZGVjb2Rpbmcgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIgKG5lZWQgQXJyYXlCdWZmZXIgJiBVaW50OEFycmF5KScsIDQwMDIwLCA0MDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlbHRhQmFzZSA9IGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ7XG5cdFx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGRlbHRhQmFzZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlbHRhQmFzZSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOEVuY29kZShkZWx0YUJhc2UpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8qIHZjZGlmZiBleHBlY3RzIFVpbnQ4QXJyYXlzLCBjYW4ndCBjb3B5IHdpdGggQXJyYXlCdWZmZXJzLiAoYWxzbywgaWYgd2Vcblx0XHRcdFx0XHRcdFx0XHQgKiBkb24ndCBoYXZlIGEgVGV4dERlY29kZXIsIGRlbHRhQmFzZSBtaWdodCBiZSBhIFdvcmRBcnJheSBoZXJlLCBzbyBuZWVkXG5cdFx0XHRcdFx0XHRcdFx0ICogdG8gcHJvY2VzcyBpdCBpbnRvIGEgYnVmZmVyIGFueXdheSkgKi9cblx0XHRcdFx0XHRcdFx0XHRkZWx0YUJhc2UgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRlbHRhQmFzZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGF0YSk7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50eXBlZEFycmF5VG9CdWZmZXIoY29udGV4dC5wbHVnaW5zLnZjZGlmZi5kZWNvZGUoZGF0YSwgZGVsdGFCYXNlKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBheWxvYWQgPSBkYXRhO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdWY2RpZmYgZGVsdGEgZGVjb2RlIGZhaWxlZCB3aXRoICcgKyBlLCA0MDAxOCwgNDAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRXJyb3IgcHJvY2Vzc2luZyB0aGUgJyArIHhmb3JtICsgJyBlbmNvZGluZywgZGVjb2RlciByZXR1cm5lZCDigJgnICsgZS5tZXNzYWdlICsgJ+KAmScsIGUuY29kZSB8fCA0MDAxMywgNDAwKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdG1lc3NhZ2UuZW5jb2RpbmcgPSAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPD0gMCkgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKCcvJyk7XG5cdFx0XHRcdG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQgPSBsYXN0UGF5bG9hZDtcblx0fTtcblxuXHRNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1zZyA9IGJvZHlbaV0gPSBNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYm9keTtcblx0fTtcblxuXHRNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gTWVzc2FnZS5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRmdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuY2lwaGVyICYmICFvcHRpb25zLmNpcGhlci5jaGFubmVsQ2lwaGVyKSB7XG5cdFx0XHRpZighcGxhdGZvcm1fY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0pIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG5cdFx0XHR2YXIgY2lwaGVyID0gcGxhdGZvcm1fY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyKTtcblx0XHRcdG9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG5cdFx0fVxuXHR9XG5cblx0TWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uKGVuY29kZWQsIG9wdGlvbnMpIHtcblx0XHR2YXIgbXNnID0gTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQpO1xuXHRcdG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMob3B0aW9ucyk7XG5cdFx0LyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cblx0XHQgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cblx0XHR0cnkge1xuXHRcdFx0TWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21FbmNvZGVkKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXNnO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuXHRcdG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMob3B0aW9ucyk7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyTWFwKGVuY29kZWRBcnJheSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRcdFx0cmV0dXJuIE1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG5cdFx0dmFyIHNpemUgPSAwO1xuXHRcdGlmKG1zZy5uYW1lKSB7XG5cdFx0XHRzaXplICs9IG1zZy5uYW1lLmxlbmd0aDtcblx0XHR9XG5cdFx0aWYobXNnLmNsaWVudElkKSB7XG5cdFx0XHRzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG5cdFx0fVxuXHRcdGlmKG1zZy5leHRyYXMpIHtcblx0XHRcdHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuXHRcdH1cblx0XHRpZihtc2cuZGF0YSkge1xuXHRcdFx0c2l6ZSArPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRhdGFTaXplQnl0ZXMobXNnLmRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gc2l6ZTtcblx0fTtcblxuXHQvKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgb24gZW5jb2RlKClkIChhbmQgZW5jcnlwdCgpZCkgTWVzc2FnZXMgKGFzIGl0XG5cdCAqIGFzc3VtZXMgdGhlIGRhdGEgaXMgYSBzdHJpbmcgb3IgYnVmZmVyKSAqL1xuXHRNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0dmFyIG1zZywgdG90YWwgPSAwO1xuXHRcdGZvcih2YXIgaT0wOyBpPG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtc2cgPSBtZXNzYWdlc1tpXTtcblx0XHRcdHRvdGFsICs9IChtc2cuc2l6ZSB8fCAobXNnLnNpemUgPSBnZXRNZXNzYWdlU2l6ZShtc2cpKSlcblx0XHR9XG5cdFx0cmV0dXJuIHRvdGFsO1xuXHR9O1xuXG5cdHJldHVybiBNZXNzYWdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChNZXNzYWdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG5cdCAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLy8gUmVmZXJlbmNlIG9yaWdpbmFsIGluaXRcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcblxuXHQgICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0ICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuXG5cblxuXG52YXIgUHJlc2VuY2VNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbXNncGFjayA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubXNncGFjaztcblxuXHRmdW5jdGlvbiB0b0FjdGlvblZhbHVlKGFjdGlvblN0cmluZykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YoUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMsIGFjdGlvblN0cmluZylcblx0fVxuXG5cdGZ1bmN0aW9uIFByZXNlbmNlTWVzc2FnZSgpIHtcblx0XHR0aGlzLmFjdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZXN0YW1wID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xpZW50SWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zaXplID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0UHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMgPSBbXG5cdFx0J2Fic2VudCcsXG5cdFx0J3ByZXNlbnQnLFxuXHRcdCdlbnRlcicsXG5cdFx0J2xlYXZlJyxcblx0XHQndXBkYXRlJ1xuXHRdO1xuXG5cdC8qIFJldHVybnMgd2hldGhlciB0aGlzIHByZXNlbmNlTWVzc2FnZSBpcyBzeW50aGVzaXplZCwgaS5lLiB3YXMgbm90IGFjdHVhbGx5XG5cdCAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG5cdCAqIGRpc2Nvbm5lY3Rpb24pLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIHN5bnRoZXNpemVkIG1lc3NhZ2VzIGNhbm5vdCBiZVxuXHQgKiBjb21wYXJlZCBmb3IgbmV3bmVzcyBieSBpZCBsZXhpY29ncmFwaGljYWxseSAtIFJUUDJiMVxuXHQgKi9cblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS5pc1N5bnRoZXNpemVkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaWQuc3Vic3RyaW5nKHRoaXMuY29ubmVjdGlvbklkLmxlbmd0aCwgMCkgIT09IHRoaXMuY29ubmVjdGlvbklkO1xuXHR9O1xuXG5cdC8qIFJUUDJiMiAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnBhcnNlSWQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLmlkLnNwbGl0KCc6Jyk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXG5cdFx0XHRtc2dTZXJpYWw6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG5cdFx0XHRpbmRleDogcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdC8qIENvbnZlcnQgcHJlc2VuY2UgYWN0aW9uIGJhY2sgdG8gYW4gaW50IGZvciBzZW5kaW5nIHRvIEFibHkgKi9cblx0XHRcdGFjdGlvbjogdG9BY3Rpb25WYWx1ZSh0aGlzLmFjdGlvbiksXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xuXHRcdH07XG5cblx0XHQvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcblx0XHQgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcblx0XHQgKiBjYWxsIGlmIGl0IGhhcyBhIG5vbi1lbXB0eSBhcmd1bWVudHMgbGlzdCAqL1xuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdGlmKGRhdGEgJiYgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSkge1xuXHRcdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Lyogc3RyaW5naWZ5IGNhbGwgKi9cblx0XHRcdFx0dmFyIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcblx0XHRcdFx0cmVzdWx0LmVuY29kaW5nID0gZW5jb2RpbmcgPyAoZW5jb2RpbmcgKyAnL2Jhc2U2NCcpIDogJ2Jhc2U2NCc7XG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZShkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIENhbGxlZCBieSBtc2dwYWNrLiB0b0J1ZmZlciByZXR1cm5zIGEgZGF0YXR5cGUgdW5kZXJzdGFuZGFibGUgYnlcblx0XHRcdFx0ICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XG5cdFx0XHRcdCAqIGluIGJyb3dzZXJzKSAqL1xuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b0J1ZmZlcihkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzdWx0LmRhdGEgPSBkYXRhO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW1ByZXNlbmNlTWVzc2FnZSc7XG5cdFx0cmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgdGhpcy5hY3Rpb247XG5cdFx0aWYodGhpcy5pZClcblx0XHRcdHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcblx0XHRpZih0aGlzLnRpbWVzdGFtcClcblx0XHRcdHJlc3VsdCArPSAnOyB0aW1lc3RhbXA9JyArIHRoaXMudGltZXN0YW1wO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uSWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY29ubmVjdGlvbklkPScgKyB0aGlzLmNvbm5lY3Rpb25JZDtcblx0XHRpZih0aGlzLmVuY29kaW5nKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGVuY29kaW5nPScgKyB0aGlzLmVuY29kaW5nO1xuXHRcdGlmKHRoaXMuZGF0YSkge1xuXHRcdFx0aWYgKHR5cGVvZih0aGlzLmRhdGEpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuXHRcdFx0ZWxzZSBpZiAocGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUodGhpcy5kYXRhKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuXHRcdH1cblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cdFByZXNlbmNlTWVzc2FnZS5lbmNvZGUgPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVuY29kZTtcblx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlO1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XG5cdFx0aWYoZm9ybWF0KSB7XG5cdFx0XHRib2R5ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtc2cgPSBib2R5W2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSwgdHJ1ZSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJvZHk7XG5cdH07XG5cblx0LyogQ3JlYXRlcyBhIFByZXNlbmNlTWVzc2FnZSBmcm9tIHNwZWNpZmllZCB2YWx1ZXMsIHdpdGggYSBzdHJpbmcgcHJlc2VuY2UgYWN0aW9uICovXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzLCBzdHJpbmdpZnlBY3Rpb24pIHtcblx0XHRpZihzdHJpbmdpZnlBY3Rpb24pIHtcblx0XHRcdHZhbHVlcy5hY3Rpb24gPSBQcmVzZW5jZU1lc3NhZ2UuQWN0aW9uc1t2YWx1ZXMuYWN0aW9uXVxuXHRcdH1cblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIHZhbHVlcyk7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbihlbmNvZGVkLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1zZyA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGVuY29kZWQsIHRydWUpO1xuXHRcdC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG5cdFx0ICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXG5cdFx0dHJ5IHtcblx0XHRcdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtc2c7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbihlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJNYXAoZW5jb2RlZEFycmF5LCBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdFx0XHRyZXR1cm4gUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkKGVuY29kZWQsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5nZXRNZXNzYWdlc1NpemUgPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldE1lc3NhZ2VzU2l6ZTtcblxuXHRyZXR1cm4gUHJlc2VuY2VNZXNzYWdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcmVzZW5jZU1lc3NhZ2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgezsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKmdsb2JhbHMgd2luZG93LCBnbG9iYWwsIHJlcXVpcmUqL1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXG5cdCAgICB2YXIgY3J5cHRvO1xuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgKGV4cGVyaW1lbnRhbCBJRSAxMSkgY3J5cHRvIGZyb20gd2luZG93IChCcm93c2VyKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1zQ3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gZ2xvYmFsIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gZ2xvYmFsLmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBpbXBvcnQgdmlhIHJlcXVpcmUgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgIH1cblxuXHQgICAgLypcblx0ICAgICAqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuXHQgICAgICpcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcnlwdG9TZWN1cmVSYW5kb21JbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xuXHQgICAgICAgICAgICAvLyBVc2UgZ2V0UmFuZG9tVmFsdWVzIG1ldGhvZCAoQnJvd3Nlcilcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2UgcmFuZG9tQnl0ZXMgbWV0aG9kIChOb2RlSlMpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLicpO1xuXHQgICAgfTtcblxuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWxsIG9mIE9iamVjdC5jcmVhdGVcblxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaChjcnlwdG9TZWN1cmVSYW5kb21JbnQoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuXG52YXIgQ29ubmVjdGlvbkVycm9yID0ge1xuXHRkaXNjb25uZWN0ZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMDMsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJ1xuXHR9KSxcblx0c3VzcGVuZGVkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDAyLFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB1bmF2YWlsYWJsZSdcblx0fSksXG5cdGZhaWxlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAwMCxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQgb3IgZGlzY29ubmVjdGVkIGJ5IHNlcnZlcidcblx0fSksXG5cdGNsb3Npbmc6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMTcsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2luZydcblx0fSksXG5cdGNsb3NlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAxNyxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zZWQnXG5cdH0pLFxuXHR1bmtub3duQ29ubmVjdGlvbkVycjogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDUwMCxcblx0XHRjb2RlOiA1MDAwMixcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcidcblx0fSksXG5cdHVua25vd25DaGFubmVsRXJyOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNTAwLFxuXHRcdGNvZGU6IDUwMDAxLFxuXHRcdG1lc3NhZ2U6ICdJbnRlcm5hbCBjaGFubmVsIGVycm9yJ1xuXHR9KVxufTtcblxuQ29ubmVjdGlvbkVycm9yLmlzUmV0cmlhYmxlID0gZnVuY3Rpb24oZXJyKSB7XG5cdGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHZhciByZXRyaWFibGUgPSBmYWxzZTtcblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS52YWx1ZXNBcnJheShDb25uZWN0aW9uRXJyb3IpLmZvckVhY2goZnVuY3Rpb24oY29ubkVycikge1xuXHRcdGlmIChjb25uRXJyLmNvZGUgJiYgY29ubkVyci5jb2RlID09IGVyci5jb2RlKSB7XG5cdFx0XHRyZXRyaWFibGUgPSB0cnVlO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiByZXRyaWFibGU7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbm5lY3Rpb25FcnJvcik7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9odHRwLmpzXG52YXIgaHR0cCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIuanNcbnZhciBtdWx0aWNhc3RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9idWZmZXJ1dGlscy5qc1xudmFyIGJ1ZmZlcnV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLmpzXG52YXIgZXJyb3JpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2Jhc2U2NC5qc1xuLypcbiBDb3B5cmlnaHQgKGMpIDIwMDggRnJlZCBQYWxtZXIgZnJlZC5wYWxtZXJfYXRfZ21haWwuY29tXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIEJhc2U2NCA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gU3RyaW5nQnVmZmVyKClcblx0e1xuXHRcdHRoaXMuYnVmZmVyID0gW107XG5cdH1cblxuXHRTdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzdHJpbmcpXG5cdHtcblx0XHR0aGlzLmJ1ZmZlci5wdXNoKHN0cmluZyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0U3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmJ1ZmZlci5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdHZhciBCYXNlNjQgPVxuXHR7XG5cdFx0Y29kZXggOiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsXG5cblx0XHRlbmNvZGUgOiBmdW5jdGlvbiAoaW5wdXQpXG5cdFx0e1xuXHRcdFx0dmFyIG91dHB1dCA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcblx0XHRcdHZhciBjb2RleCA9IEJhc2U2NC5jb2RleDtcblxuXHRcdFx0dmFyIGVudW1lcmF0b3IgPSBuZXcgVXRmOEVuY29kZUVudW1lcmF0b3IoaW5wdXQpO1xuXHRcdFx0d2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNocjEgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHR2YXIgY2hyMiA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdHZhciBjaHIzID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdHZhciBlbmMxID0gY2hyMSA+PiAyO1xuXHRcdFx0XHR2YXIgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG5cdFx0XHRcdHZhciBlbmMzID0gKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNik7XG5cdFx0XHRcdHZhciBlbmM0ID0gY2hyMyAmIDYzO1xuXG5cdFx0XHRcdGlmIChpc05hTihjaHIyKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVuYzMgPSBlbmM0ID0gNjQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoaXNOYU4oY2hyMykpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmM0ID0gNjQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQuYXBwZW5kKGNvZGV4LmNoYXJBdChlbmMxKSArIGNvZGV4LmNoYXJBdChlbmMyKSArIGNvZGV4LmNoYXJBdChlbmMzKSArIGNvZGV4LmNoYXJBdChlbmM0KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcblx0XHR9LFxuXG5cdFx0ZGVjb2RlIDogZnVuY3Rpb24gKGlucHV0KVxuXHRcdHtcblx0XHRcdHZhciBvdXRwdXQgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG5cblx0XHRcdHZhciBlbnVtZXJhdG9yID0gbmV3IEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpO1xuXHRcdFx0d2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdGlmIChjaGFyQ29kZSA8IDEyOClcblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKTtcblx0XHRcdFx0ZWxzZSBpZiAoKGNoYXJDb2RlID4gMTkxKSAmJiAoY2hhckNvZGUgPCAyMjQpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjaGFyQ29kZSAmIDMxKSA8PCA2KSB8IChjaGFyQ29kZTIgJiA2MykpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMiA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0XHR2YXIgY2hhckNvZGUzID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY2hhckNvZGUgJiAxNSkgPDwgMTIpIHwgKChjaGFyQ29kZTIgJiA2MykgPDwgNikgfCAoY2hhckNvZGUzICYgNjMpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dC50b1N0cmluZygpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBVdGY4RW5jb2RlRW51bWVyYXRvcihpbnB1dClcblx0e1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0dGhpcy5faW5kZXggPSAtMTtcblx0XHR0aGlzLl9idWZmZXIgPSBbXTtcblx0fVxuXG5cdFV0ZjhFbmNvZGVFbnVtZXJhdG9yLnByb3RvdHlwZSA9XG5cdHtcblx0XHRjdXJyZW50OiBOdW1iZXIuTmFOLFxuXG5cdFx0bW92ZU5leHQ6IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX2luZGV4ID49ICh0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gTnVtYmVyLk5hTjtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY2hhckNvZGUgPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5faW5kZXgpO1xuXG5cdFx0XHRcdC8vIFwiXFxyXFxuXCIgLT4gXCJcXG5cIlxuXHRcdFx0XHQvL1xuXHRcdFx0XHRpZiAoKGNoYXJDb2RlID09IDEzKSAmJiAodGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCArIDEpID09IDEwKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNoYXJDb2RlID0gMTA7XG5cdFx0XHRcdFx0dGhpcy5faW5kZXggKz0gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaGFyQ29kZSA8IDEyOClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IGNoYXJDb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKChjaGFyQ29kZSA+IDEyNykgJiYgKGNoYXJDb2RlIDwgMjA0OCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSAoY2hhckNvZGUgPj4gNikgfCAxOTI7XG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goKGNoYXJDb2RlICYgNjMpIHwgMTI4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSAoY2hhckNvZGUgPj4gMTIpIHwgMjI0O1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKCgoY2hhckNvZGUgPj4gNikgJiA2MykgfCAxMjgpO1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKChjaGFyQ29kZSAmIDYzKSB8IDEyOCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gQmFzZTY0RGVjb2RlRW51bWVyYXRvcihpbnB1dClcblx0e1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdFx0dGhpcy5faW5kZXggPSAtMTtcblx0XHR0aGlzLl9idWZmZXIgPSBbXTtcblx0fVxuXG5cdEJhc2U2NERlY29kZUVudW1lcmF0b3IucHJvdG90eXBlID1cblx0e1xuXHRcdGN1cnJlbnQ6IDY0LFxuXG5cdFx0bW92ZU5leHQ6IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuX2luZGV4ID49ICh0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gNjQ7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVuYzEgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXHRcdFx0XHR2YXIgZW5jMiA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cdFx0XHRcdHZhciBlbmMzID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblx0XHRcdFx0dmFyIGVuYzQgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXG5cdFx0XHRcdHZhciBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcblx0XHRcdFx0dmFyIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcblx0XHRcdFx0dmFyIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gY2hyMTtcblxuXHRcdFx0XHRpZiAoZW5jMyAhPSA2NClcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIyKTtcblxuXHRcdFx0XHRpZiAoZW5jNCAhPSA2NClcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIzKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2U2NDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2U2NCA9IChCYXNlNjQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9idWlsZC9obWFjLXNoYTI1Ni5qc1xudmFyIGhtYWNfc2hhMjU2ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG52YXIgaG1hY19zaGEyNTZfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaG1hY19zaGEyNTYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9idWlsZC9lbmMtYmFzZTY0LmpzXG52YXIgZW5jX2Jhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2F1dGguanNcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgYXV0aF9BdXRoID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgTUFYX1RPS0VOX0xFTkdUSCA9IE1hdGgucG93KDIsIDE3KTtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdGZ1bmN0aW9uIHJhbmRvbSgpIHsgcmV0dXJuICgnMDAwMDAwJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFFMTYpKS5zbGljZSgtMTYpOyB9XG5cdGZ1bmN0aW9uIG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikge1xuXHRcdC8qIEEgY2xpZW50IGF1dGggY2FsbGJhY2sgbWF5IGdpdmUgZXJyb3JzIGluIGFueSBudW1iZXIgb2YgZm9ybWF0czsgbm9ybWFsaXNlIHRvIGFuIGVycm9yaW5mbyAqL1xuXHRcdGlmKCF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0Vycm9ySW5mbyhlcnIpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSwgZXJyLmNvZGUgfHwgNDAxNzAsIGVyci5zdGF0dXNDb2RlIHx8IDQwMSk7XG5cdFx0fVxuXHRcdC8qIG5ldHdvcmsgZXJyb3JzIHdpbGwgbm90IGhhdmUgYW4gaW5oZXJlbnQgZXJyb3IgY29kZSAqL1xuXHRcdGlmKCFlcnIuY29kZSkge1xuXHRcdFx0aWYoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuXHRcdFx0XHRlcnIuY29kZSA9IDQwMzAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXJyLmNvZGUgPSA0MDE3MDtcblx0XHRcdFx0Lyogbm9ybWFsaXNlIHN0YXR1c0NvZGUgdG8gNDAxIHBlciBSU0E0ZSAqL1xuXHRcdFx0XHRlcnIuc3RhdHVzQ29kZSA9IDQwMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVycjtcblx0fVxuXG5cdHZhciBobWFjLCB0b0Jhc2U2NDtcblx0aWYocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVIbWFjKSB7XG5cdFx0dG9CYXNlNjQgPSBmdW5jdGlvbihzdHIpIHsgcmV0dXJuIChCdWZmZXIuZnJvbShzdHIsICdhc2NpaScpKS50b1N0cmluZygnYmFzZTY0Jyk7IH07XG5cdFx0aG1hYyA9IGZ1bmN0aW9uKHRleHQsIGtleSkge1xuXHRcdFx0dmFyIGluc3QgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZUhtYWMoJ1NIQTI1NicsIGtleSk7XG5cdFx0XHRpbnN0LnVwZGF0ZSh0ZXh0KTtcblx0XHRcdHJldHVybiBpbnN0LmRpZ2VzdCgnYmFzZTY0Jyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0b0Jhc2U2NCA9IGJhc2U2NC5lbmNvZGU7XG5cdFx0aG1hYyA9IGZ1bmN0aW9uKHRleHQsIGtleSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdChlbmNfYmFzZTY0W1wic3RyaW5naWZ5XCJdKShobWFjX3NoYTI1Nl9kZWZhdWx0KCkodGV4dCwga2V5KSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGMxNG4oY2FwYWJpbGl0eSkge1xuXHRcdGlmKCFjYXBhYmlsaXR5KVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0aWYodHlwZW9mKGNhcGFiaWxpdHkpID09ICdzdHJpbmcnKVxuXHRcdFx0Y2FwYWJpbGl0eSA9IEpTT04ucGFyc2UoY2FwYWJpbGl0eSk7XG5cblx0XHR2YXIgYzE0bkNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHZhciBrZXlzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ua2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuXHRcdGlmKCFrZXlzKVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdGtleXMuc29ydCgpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMpIHtcblx0XHRpZihhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrJyk7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5rZXkpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZycpO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggc3VwcGxpZWQgdG9rZW4gb25seScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gJ2F1dGhPcHRpb25zIG11c3QgaW5jbHVkZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzJztcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykge1xuXHRcdHJldHVybiAndXNlVG9rZW5BdXRoJyBpbiBvcHRpb25zICYmICFvcHRpb25zLnVzZVRva2VuQXV0aDtcblx0fVxuXG5cdC8qIFJTQTQgKi9cblx0ZnVuY3Rpb24gdXNlVG9rZW5BdXRoKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy51c2VUb2tlbkF1dGggfHxcblx0XHRcdCghYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpICYmXG5cdFx0XHQgKG9wdGlvbnMuYXV0aENhbGxiYWNrIHx8XG5cdFx0XHQgIG9wdGlvbnMuYXV0aFVybCAgICAgIHx8XG5cdFx0XHQgIG9wdGlvbnMudG9rZW4gICAgICAgIHx8XG5cdFx0XHQgIG9wdGlvbnMudG9rZW5EZXRhaWxzKSlcblx0fVxuXG5cdC8qIFJTQTRhICovXG5cdGZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XG5cdFx0cmV0dXJuICFvcHRpb25zLmtleSAmJlxuXHRcdFx0IW9wdGlvbnMuYXV0aENhbGxiYWNrICYmXG5cdFx0XHQhb3B0aW9ucy5hdXRoVXJsO1xuXHR9XG5cblx0dmFyIHRySWQgPSAwO1xuXHRmdW5jdGlvbiBnZXRUb2tlblJlcXVlc3RJZCgpIHtcblx0XHRyZXR1cm4gdHJJZCsrO1xuXHR9XG5cblx0ZnVuY3Rpb24gQXV0aChjbGllbnQsIG9wdGlvbnMpIHtcblx0XHR0aGlzLmNsaWVudCA9IGNsaWVudDtcblx0XHR0aGlzLnRva2VuUGFyYW1zID0gb3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMgfHwge307XG5cdFx0LyogVGhlIGlkIG9mIHRoZSBjdXJyZW50IHRva2VuIHJlcXVlc3QgaWYgb25lIGlzIGluIHByb2dyZXNzLCBlbHNlIG51bGwgKi9cblx0XHR0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG5cdFx0dGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcblxuXHRcdGlmKHVzZVRva2VuQXV0aChvcHRpb25zKSkge1xuXHRcdFx0LyogVG9rZW4gYXV0aCAqL1xuXHRcdFx0aWYob3B0aW9ucy5rZXkgJiYgIWhtYWMpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdjbGllbnQtc2lkZSB0b2tlbiByZXF1ZXN0IHNpZ25pbmcgbm90IHN1cHBvcnRlZCc7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0aWYobm9XYXlUb1JlbmV3KG9wdGlvbnMpKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsICdXYXJuaW5nOiBsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG5cdFx0XHRsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogQmFzaWMgYXV0aCAqL1xuXHRcdFx0aWYoIW9wdGlvbnMua2V5KSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTYwLCA0MDEpO1xuXHRcdFx0fVxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ2Fub255bW91cywgdXNpbmcgYmFzaWMgYXV0aCcpO1xuXHRcdFx0dGhpcy5fc2F2ZUJhc2ljT3B0aW9ucyhvcHRpb25zKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSW5zdHJ1Y3RzIHRoZSBsaWJyYXJ5IHRvIGdldCBhIHRva2VuIGltbWVkaWF0ZWx5IGFuZCBlbnN1cmVzIFRva2VuIEF1dGhcblx0ICogaXMgdXNlZCBmb3IgYWxsIGZ1dHVyZSByZXF1ZXN0cywgc3RvcmluZyB0aGUgdG9rZW5QYXJhbXMgYW5kIGF1dGhPcHRpb25zXG5cdCAqIGdpdmVuIGFzIHRoZSBuZXcgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgdXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG5cdCAqXG5cdCAqIC0gdHRsOiAgICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgYW55IG5ldyB0b2tlbiBpbiBtcy4gSWYgbm9uZVxuXHQgKiAgICAgICAgICAgICAgIGlzIHNwZWNpZmllZCBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZVxuXHQgKiAgICAgICAgICAgICAgIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0IGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkXG5cdCAqICAgICAgICAgICAgICAgd2l0aCBhbiBlcnJvci5cblx0ICpcblx0ICogLSBjYXBhYmlsaXR5OiAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG5cdCAqICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG5cdCAqICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuXHQgKlxuXHQgKiAtIGNsaWVudElkOiAgIChvcHRpb25hbCkgYSBjbGllbnQgSWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuXG5cdCAqXG5cdCAqIC0gdGltZXN0YW1wOiAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuXHQgKiAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aCBvcHRpb25zIHJlbGV2YW50IHRvIHRva2VuIGF1dGg6XG5cdCAqXG5cdCAqIC0gcXVlcnlUaW1lICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgQWJseSBzeXN0ZW0gc2hvdWxkIGJlXG5cdCAqICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkuXG5cdCAqXG5cdCAqIC0gdG9rZW5EZXRhaWxzOiAob3B0aW9uYWwpIG9iamVjdDogQW4gYXV0aGVudGljYXRlZCBUb2tlbkRldGFpbHMgb2JqZWN0LlxuXHQgKlxuXHQgKiAtIHRva2VuOiAgICAgICAgKG9wdGlvbmFsKSBzdHJpbmc6IHRoZSBgdG9rZW5gIHByb3BlcnR5IG9mIGEgdG9rZW5EZXRhaWxzIG9iamVjdFxuXHQgKlxuXHQgKiAtIGF1dGhDYWxsYmFjazogIChvcHRpb25hbCkgYSBKYXZhU2NyaXB0IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB0byBnZXQgYXV0aCBpbmZvcm1hdGlvbi5cblx0ICogICAgICAgICAgICAgICAgICBhdXRoQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgKHRva2VuUGFyYW1zLCBjYWxsYmFjaykgdGhhdCBjYWxsc1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBjYWxsYmFjayB3aXRoIChlcnIsIHJlc3VsdCksIHdoZXJlIHJlc3VsdCBpcyBhbnkgb2Y6XG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuUmVxdWVzdCBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGguY3JlYXRlVG9rZW5SZXF1ZXN0IGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbkRldGFpbHMgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLnJlcXVlc3RUb2tlbiBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW4gc3RyaW5nXG5cdCAqXG5cdCAqIC0gYXV0aFVybDogICAgICAgKG9wdGlvbmFsKSBhIFVSTCB0byBiZSB1c2VkIHRvIEdFVCBvciBQT1NUIGEgc2V0IG9mIHRva2VuIHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBwYXJhbXMsIHRvIG9idGFpbiBhIHNpZ25lZCB0b2tlbiByZXF1ZXN0LlxuXHQgKlxuXHQgKiAtIGF1dGhIZWFkZXJzOiAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgaGVhZGVycyB0byBiZSBhZGRlZCB0byBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqIC0gYXV0aFBhcmFtczogICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBxdWVyeSBwYXJhbXMgdG8gYmUgYWRkZWQgdG8gYW55XG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdCBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCB0b2tlbkRldGFpbHMpXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdhdXRob3JpemUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvKiBSU0ExMGE6IGF1dGhvcml6ZSgpIGNhbGwgaW1wbGllcyB0b2tlbiBhdXRoLiBJZiBhIGtleSBpcyBwYXNzZWQgaXQsIHdlXG5cdFx0ICoganVzdCBjaGVjayBpZiBpdCBkb2Vzbid0IGNsYXNoIGFuZCBhc3N1bWUgd2UncmUgZ2VuZXJhdGluZyBhIHRva2VuIGZyb20gaXQgKi9cblx0XHRpZihhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5rZXkgJiYgKHRoaXMuYXV0aE9wdGlvbnMua2V5ICE9PSBhdXRoT3B0aW9ucy5rZXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gdXBkYXRlIGF1dGggb3B0aW9ucyB3aXRoIGluY29tcGF0aWJsZSBrZXknLCA0MDEwMiwgNDAxKTtcblx0XHR9XG5cblx0XHRpZihhdXRoT3B0aW9ucyAmJiAoJ2ZvcmNlJyBpbiBhdXRoT3B0aW9ucykpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGguYXV0aG9yaXplJywgJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IHNwZWNpZnlpbmcge2ZvcmNlOiB0cnVlfSBpbiBhdXRoT3B0aW9ucyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LCBhdXRob3JpemUoKSBub3cgYWx3YXlzIGdldHMgYSBuZXcgdG9rZW4uIFBsZWFzZSByZW1vdmUgdGhpcywgYXMgaW4gdmVyc2lvbiAxLjAgYW5kIGxhdGVyLCBoYXZpbmcgYSBub24tbnVsbCBhdXRoT3B0aW9ucyB3aWxsIG92ZXJ3cml0ZSBzdG9yZWQgbGlicmFyeSBhdXRoT3B0aW9ucywgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50Jyk7XG5cdFx0XHQvKiBFbXVsYXRlIHRoZSBvbGQgYmVoYXZpb3VyOiBpZiAnZm9yY2UnIHdhcyB0aGUgb25seSBtZW1iZXIgb2YgYXV0aE9wdGlvbnMsXG5cdFx0XHQgKiBzZXQgaXQgdG8gbnVsbCBzbyBpdCBkb2Vzbid0IG92ZXJ3cml0ZSBzdG9yZWQuIFRPRE86IHJlbW92ZSBpbiB2ZXJzaW9uIDEuMCAqL1xuXHRcdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPbmx5UHJvcEluKGF1dGhPcHRpb25zLCAnZm9yY2UnKSkge1xuXHRcdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0aWYoc2VsZi5jbGllbnQuY29ubmVjdGlvbikge1xuXHRcdFx0XHRcdC8qIFdlIGludGVycHJldCBSU0E0ZCBhcyBpbmNsdWRpbmcgcmVxdWVzdHMgbWFkZSBieSBhIGNsaWVudCBsaWIgdG9cblx0XHRcdFx0XHQgKiBhdXRoZW50aWNhdGUgdHJpZ2dlcmVkIGJ5IGFuIGV4cGxpY2l0IGF1dGhvcml6ZSgpIG9yIGFuIEFVVEggcmVjZWl2ZWQgZnJvbVxuXHRcdFx0XHRcdCAqIGFibHksIG5vdCBqdXN0IGNvbm5lY3Qtc2VxdWVuY2UtdHJpZ2dlcmVkIHRva2VuIGZldGNoZXMgKi9cblx0XHRcdFx0XHRzZWxmLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBSVEM4XG5cdFx0XHQgKiAtIFdoZW4gYXV0aG9yaXplIGNhbGxlZCBieSBhbiBlbmQgdXNlciBhbmQgaGF2ZSBhIHJlYWx0aW1lIGNvbm5lY3Rpb24sXG5cdFx0XHQgKiBkb24ndCBjYWxsIGJhY2sgdGlsbCBuZXcgdG9rZW4gaGFzIHRha2VuIGVmZmVjdC5cblx0XHRcdCAqIC0gVXNlIHNlbGYuY2xpZW50LmNvbm5lY3Rpb24gYXMgYSBwcm94eSBmb3IgKHNlbGYuY2xpZW50IGluc3RhbmNlb2YgUmVhbHRpbWUpLFxuXHRcdFx0ICogd2hpY2ggZG9lc24ndCB3b3JrIGluIG5vZGUgYXMgUmVhbHRpbWUgaXNuJ3QgcGFydCBvZiB0aGUgdm0gY29udGV4dCBmb3IgUmVzdCBjbGllbnRzICovXG5cdFx0XHRpZihzZWxmLmNsaWVudC5jb25uZWN0aW9uKSB7XG5cdFx0XHRcdHNlbGYuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMsIGNhbGxiYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG5cdFx0XHR9XG5cdFx0fSlcblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5hdXRob3Jpc2UgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnQXV0aC5hdXRob3Jpc2UnLCAnQXV0aC5hdXRob3JpemUnKTtcblx0XHR0aGlzLmF1dGhvcml6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdC8qIEZvciBpbnRlcm5hbCB1c2UsIGVnIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIC0gdXNlZnVsIHdoZW4gd2FudCB0byBjYWxsIGJhY2tcblx0ICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2Vcblx0ICogZWZmZWN0IG9uIHRoZSBjb25uZWN0aW9uIGFzICNhdXRob3JpemUgZG9lcyAqL1xuXHRBdXRoLnByb3RvdHlwZS5fZm9yY2VOZXdUb2tlbiA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvKiBnZXQgcmlkIG9mIGN1cnJlbnQgdG9rZW4gZXZlbiBpZiBzdGlsbCB2YWxpZCAqL1xuXHRcdHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcblxuXHRcdC8qIF9zYXZlIG5vcm1hbGlzZXMgdGhlIHRva2VuUGFyYW1zIGFuZCBhdXRoT3B0aW9ucyBhbmQgdXBkYXRlcyB0aGUgYXV0aFxuXHRcdCAqIG9iamVjdC4gQWxsIHN1YnNlcXVlbnQgb3BlcmF0aW9ucyBzaG91bGQgdXNlIHRoZSB2YWx1ZXMgb24gYHRoaXNgLFxuXHRcdCAqIG5vdCB0aGUgcGFzc2VkIGluIG9uZXMuICovXG5cdFx0dGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuXG5cdFx0bG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucyk7XG5cblx0XHR0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyh0cnVlLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xuXHRcdFx0LyogUlNBMTBnICovXG5cdFx0XHRkZWxldGUgc2VsZi50b2tlblBhcmFtcy50aW1lc3RhbXA7XG5cdFx0XHRkZWxldGUgc2VsZi5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XG5cdFx0XHRjYWxsYmFjayhlcnIsIHRva2VuRGV0YWlscyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cblx0ICogQHBhcmFtIGF1dGhPcHRpb25zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG5cdCAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuXG5cdCAqXG5cdCAqIC0gYXV0aENhbGxiYWNrOiAgKG9wdGlvbmFsKSBhIEphdmFTY3JpcHQgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHRvIGdldCBhdXRoIGluZm9ybWF0aW9uLlxuXHQgKiAgICAgICAgICAgICAgICAgIGF1dGhDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbiBvZiAodG9rZW5QYXJhbXMsIGNhbGxiYWNrKSB0aGF0IGNhbGxzXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIHdpdGggKGVyciwgcmVzdWx0KSwgd2hlcmUgcmVzdWx0IGlzIGFueSBvZjpcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5SZXF1ZXN0IG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5jcmVhdGVUb2tlblJlcXVlc3QgY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuRGV0YWlscyBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGgucmVxdWVzdFRva2VuIGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbiBzdHJpbmdcblx0ICpcblx0ICogLSBhdXRoVXJsOiAgICAgICAob3B0aW9uYWwpIGEgVVJMIHRvIGJlIHVzZWQgdG8gR0VUIG9yIFBPU1QgYSBzZXQgb2YgdG9rZW4gcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIHBhcmFtcywgdG8gb2J0YWluIGEgc2lnbmVkIHRva2VuIHJlcXVlc3QuXG5cdCAqXG5cdCAqIC0gYXV0aEhlYWRlcnM6ICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIGFueSByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICogLSBhdXRoUGFyYW1zOiAgICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIHF1ZXJ5IHBhcmFtcyB0byBiZSBhZGRlZCB0byBhbnlcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0IG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG5cdCAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcblx0ICpcblx0ICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuXHQgKlxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG5cdCAqIC0gdHRsOiAgICAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbWlsbGlzZWNvbmRzLiBJZiBub25lIGlzIHNwZWNpZmllZFxuXHQgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cblx0ICpcblx0ICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG5cdCAqICAgICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuXHQgKlxuXHQgKiAtIGNsaWVudElkOiAgICAgIChvcHRpb25hbCkgYSBjbGllbnQgSWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuOyBpZiBub3Rcblx0ICogICAgICAgICAgICAgICAgICBzcGVjaWZpZWQsIGEgY2xpZW50SWQgcGFzc2VkIGluIGNvbnN0cnVjdGluZyB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG5cdCAqXG5cdCAqIC0gdGltZXN0YW1wOiAgICAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgdG9rZW5EZXRhaWxzKVxuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUucmVxdWVzdFRva2VuID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG5cdFx0aWYodHlwZW9mKHRva2VuUGFyYW1zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSB0b2tlblBhcmFtcztcblx0XHRcdGF1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZXF1ZXN0VG9rZW4nLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qIFJTQThlOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuXHRcdGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcblx0XHR0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXG5cdFx0LyogZmlyc3Qgc2V0IHVwIHdoYXRldmVyIGNhbGxiYWNrIHdpbGwgYmUgdXNlZCB0byBnZXQgc2lnbmVkXG5cdFx0ICogdG9rZW4gcmVxdWVzdHMgKi9cblx0XHR2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuXG5cdFx0aWYoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcblx0XHRcdFx0dmFyIGF1dGhIZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oe2FjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4nfSwgYXV0aE9wdGlvbnMuYXV0aEhlYWRlcnMpLFxuXHRcdFx0XHRcdHVzZVBvc3QgPSBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIGF1dGhPcHRpb25zLmF1dGhNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gJ3Bvc3QnO1xuXHRcdFx0XHRpZighdXNlUG9zdCkge1xuXHRcdFx0XHRcdC8qIENvbWJpbmUgYXV0aFBhcmFtcyB3aXRoIGFueSBxcyBwYXJhbXMgZ2l2ZW4gaW4gdGhlIGF1dGhVcmwgKi9cblx0XHRcdFx0XHR2YXIgcXVlcnlJZHggPSBhdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoJz8nKTtcblx0XHRcdFx0XHRpZihxdWVyeUlkeCA+IC0xKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJvdmlkZWRRc1BhcmFtcyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBhcnNlUXVlcnlTdHJpbmcoYXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZShxdWVyeUlkeCkpO1xuXHRcdFx0XHRcdFx0YXV0aE9wdGlvbnMuYXV0aFVybCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UoMCwgcXVlcnlJZHgpO1xuXHRcdFx0XHRcdFx0LyogSW4gY2FzZSBvZiBjb25mbGljdCwgYXV0aFBhcmFtcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBxcyBwYXJhbXMgaW4gdGhlIGF1dGhVcmwgKi9cblx0XHRcdFx0XHRcdGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwcm92aWRlZFFzUGFyYW1zLCBhdXRoT3B0aW9ucy5hdXRoUGFyYW1zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogUlNBOGMyICovXG5cdFx0XHRcdHZhciBhdXRoUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oe30sIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgfHwge30sIHBhcmFtcyk7XG5cdFx0XHRcdHZhciBhdXRoVXJsUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0XHRcdHZhciBjb250ZW50VHlwZTtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkIEVycm9yOiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuXHRcdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZDsgY29udGVudC10eXBlOiAnICsgY29udGVudFR5cGUgKyAnOyBib2R5OiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEJvZHkoYm9keSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihlcnIgfHwgdW5wYWNrZWQpIHJldHVybiBjYihlcnIsIGJvZHkpO1xuXHRcdFx0XHRcdGlmKGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQnVmZmVyKGJvZHkpKSBib2R5ID0gYm9keS50b1N0cmluZygpO1xuXHRcdFx0XHRcdGlmKCFjb250ZW50VHlwZSkge1xuXHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlcicsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSxcblx0XHRcdFx0XHRcdHRleHQgPSBjb250ZW50VHlwZS5pbmRleE9mKCd0ZXh0L3BsYWluJykgPiAtMSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qd3QnKSA+IC0xO1xuXHRcdFx0XHRcdGlmKCFqc29uICYmICF0ZXh0KSB7XG5cdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbmRlZCB3aXRoIHVuYWNjZXB0YWJsZSBjb250ZW50LXR5cGUgJyArIGNvbnRlbnRUeXBlICsgJywgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvbicsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoanNvbikge1xuXHRcdFx0XHRcdFx0aWYoYm9keS5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG5cdFx0XHRcdFx0XHRcdGNiKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2F1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGgnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHRcdGNiKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuZXhwZWN0ZWQgZXJyb3IgcHJvY2Vzc2luZyBhdXRoVVJMIHJlc3BvbnNlOyBlcnIgPSAnICsgZS5tZXNzYWdlLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2IobnVsbCwgYm9keSwgY29udGVudFR5cGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlcXVlc3RpbmcgdG9rZW4gZnJvbSAnICsgYXV0aE9wdGlvbnMuYXV0aFVybCArICc7IFBhcmFtczogJyArIEpTT04uc3RyaW5naWZ5KGF1dGhQYXJhbXMpICsgJzsgbWV0aG9kOiAnICsgKHVzZVBvc3QgPyAnUE9TVCcgOiAnR0VUJykpO1xuXHRcdFx0XHRpZih1c2VQb3N0KSB7XG5cdFx0XHRcdFx0Lyogc2VuZCBib2R5IGZvcm0tZW5jb2RlZCAqL1xuXHRcdFx0XHRcdHZhciBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG5cdFx0XHRcdFx0aGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcblx0XHRcdFx0XHR2YXIgYm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnRvUXVlcnlTdHJpbmcoYXV0aFBhcmFtcykuc2xpY2UoMSk7IC8qIHNsaWNlIGlzIHRvIHJlbW92ZSB0aGUgaW5pdGlhbCAnPycgKi9cblx0XHRcdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBvc3RVcmkoY2xpZW50LCBhdXRoT3B0aW9ucy5hdXRoVXJsLCBoZWFkZXJzLCBib2R5LCB7fSwgYXV0aFVybFJlcXVlc3RDYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRVcmkoY2xpZW50LCBhdXRoT3B0aW9ucy5hdXRoVXJsLCBhdXRoSGVhZGVycyB8fCB7fSwgYXV0aFBhcmFtcywgYXV0aFVybFJlcXVlc3RDYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmtleSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZycpO1xuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbihwYXJhbXMsIGNiKSB7IHNlbGYuY3JlYXRlVG9rZW5SZXF1ZXN0KHBhcmFtcywgYXV0aE9wdGlvbnMsIGNiKTsgfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG1zZyA9IFwiTmVlZCBhIG5ldyB0b2tlbiwgYnV0IGF1dGhPcHRpb25zIGRvZXMgbm90IGluY2x1ZGUgYW55IHdheSB0byByZXF1ZXN0IG9uZSAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpXCI7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCAnbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHAnKTtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE3MSwgNDAzKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Lyogbm9ybWFsaXNlIHRva2VuIHBhcmFtcyAqL1xuXHRcdGlmKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcylcblx0XHRcdHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuXG5cdFx0dmFyIHRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uKHNpZ25lZFRva2VuUGFyYW1zLCB0b2tlbkNiKSB7XG5cdFx0XHR2YXIga2V5TmFtZSA9IHNpZ25lZFRva2VuUGFyYW1zLmtleU5hbWUsXG5cdFx0XHRcdHBhdGggPSAnL2tleXMvJyArIGtleU5hbWUgKyAnL3JlcXVlc3RUb2tlbicsXG5cdFx0XHRcdHRva2VuVXJpID0gZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gY2xpZW50LmJhc2VVcmkoaG9zdCkgKyBwYXRoOyB9O1xuXG5cdFx0XHR2YXIgcmVxdWVzdEhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoKTtcblx0XHRcdGlmKGF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihyZXF1ZXN0SGVhZGVycywgYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS5yZXF1ZXN0VG9rZW4nLCAnU2VuZGluZyBQT1NUIHRvICcgKyBwYXRoICsgJzsgVG9rZW4gcGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpKTtcblx0XHRcdHNpZ25lZFRva2VuUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpO1xuXHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5wb3N0KGNsaWVudCwgdG9rZW5VcmksIHJlcXVlc3RIZWFkZXJzLCBzaWduZWRUb2tlblBhcmFtcywgbnVsbCwgdG9rZW5DYik7XG5cdFx0fTtcblxuXHRcdHZhciB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gZmFsc2UsXG5cdFx0XHR0aW1lb3V0TGVuZ3RoID0gdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LFxuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG5cdFx0XHRcdHZhciBtc2cgPSAnVG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0aW1lZCBvdXQgYWZ0ZXIgJyArICh0aW1lb3V0TGVuZ3RoIC8gMTAwMCkgKyAnIHNlY29uZHMnO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcwLCA0MDEpKTtcblx0XHRcdH0sIHRpbWVvdXRMZW5ndGgpO1xuXG5cdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sodG9rZW5QYXJhbXMsIGZ1bmN0aW9uKGVyciwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBjb250ZW50VHlwZSkge1xuXHRcdFx0aWYodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCkgcmV0dXJuO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCk7XG5cblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0XHRjYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogdGhlIHJlc3BvbnNlIGZyb20gdGhlIGNhbGxiYWNrIG1pZ2h0IGJlIGEgdG9rZW4gc3RyaW5nLCBhIHNpZ25lZCByZXF1ZXN0IG9yIGEgdG9rZW4gZGV0YWlscyAqL1xuXHRcdFx0aWYodHlwZW9mKHRva2VuUmVxdWVzdE9yRGV0YWlscykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiBzdHJpbmcgaXMgZW1wdHknLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdH0gZWxzZSBpZih0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzICcgKyB0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdH0gZWxzZSBpZih0b2tlblJlcXVlc3RPckRldGFpbHMgPT09ICd1bmRlZmluZWQnIHx8IHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ251bGwnKSB7XG5cdFx0XHRcdFx0LyogY29tbW9uIGZhaWx1cmUgbW9kZSB3aXRoIHBvb3JseS1pbXBsZW1lbnRlZCBhdXRoQ2FsbGJhY2tzICovXG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYoKHRva2VuUmVxdWVzdE9yRGV0YWlsc1swXSA9PT0gJ3snKSAmJiAhKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTEpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gd2FzIGRvdWJsZS1lbmNvZGVkOyBtYWtlIHN1cmUgeW91XFwncmUgbm90IEpTT04tZW5jb2RpbmcgYW4gYWxyZWFkeSBlbmNvZGVkIHRva2VuIHJlcXVlc3Qgb3IgZGV0YWlscycsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB7dG9rZW46IHRva2VuUmVxdWVzdE9yRGV0YWlsc30pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0V4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhICcgKyB0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBvYmplY3RTaXplID0gSlNPTi5zdHJpbmdpZnkodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKS5sZW5ndGg7XG5cdFx0XHRpZihvYmplY3RTaXplID4gTUFYX1RPS0VOX0xFTkdUSCAmJiAhYXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0IGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgc3RyaW5naWZpZWQgc2l6ZSAod2FzICcgKyBvYmplY3RTaXplICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCdpc3N1ZWQnIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykge1xuXHRcdFx0XHQvKiBhIHRva2VuRGV0YWlscyBvYmplY3QgKi9cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoISgna2V5TmFtZScgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0V4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcsIHRva2VuIHJlcXVlc3Qgb2JqZWN0LCBvciB0b2tlbiBkZXRhaWxzIG9iamVjdCc7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBpdCdzIGEgdG9rZW4gcmVxdWVzdCwgc28gbWFrZSB0aGUgcmVxdWVzdCAqL1xuXHRcdFx0dG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgZnVuY3Rpb24oZXJyLCB0b2tlblJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3QgQVBJIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF1bnBhY2tlZCkgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd0b2tlbiByZWNlaXZlZCcpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlc3BvbnNlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuXHQgKiBOT1RFIHRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBrZXkgdmFsdWUgaXMgYXZhaWxhYmxlIGxvY2FsbHkuXG5cdCAqIE90aGVyd2lzZSwgc2lnbmVkIHRva2VuIHJlcXVlc3RzIG11c3QgYmUgb2J0YWluZWQgZnJvbSB0aGUga2V5XG5cdCAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cblx0ICpcblx0ICogQHBhcmFtIGF1dGhPcHRpb25zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG5cdCAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIGEga2V5IHBhc3NlZCBpbiBjb25zdHJ1Y3Rpbmdcblx0ICogICAgICAgICAgICAgICAgICB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG5cdCAqXG5cdCAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXG5cdCAqICAgICAgICAgICAgICAgICAgcXVlcmllZCBmb3IgdGhlIGN1cnJlbnQgdGltZSB3aGVuIG5vbmUgaXMgc3BlY2lmaWVkIGV4cGxpY2l0bHlcblx0ICpcblx0ICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuXHQgKlxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XG5cdCAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG5cdCAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuXHQgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5jcmVhdGVUb2tlblJlcXVlc3QgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdjcmVhdGVUb2tlblJlcXVlc3QnLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qIFJTQTloOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuXHRcdGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcblx0XHR0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XG5cblx0XHR2YXIga2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuXHRcdGlmKCFrZXkpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ05vIGtleSBzcGVjaWZpZWQnLCA0MDEwMSwgNDAzKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBrZXlQYXJ0cyA9IGtleS5zcGxpdCgnOicpLFxuXHRcdFx0a2V5TmFtZSA9IGtleVBhcnRzWzBdLFxuXHRcdFx0a2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XG5cblx0XHRpZigha2V5U2VjcmV0KSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdJbnZhbGlkIGtleSBzcGVjaWZpZWQnLCA0MDEwMSwgNDAzKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYodG9rZW5QYXJhbXMuY2xpZW50SWQgPT09ICcnKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBjYW7igJl0IGJlIGFuIGVtcHR5IHN0cmluZycsIDQwMDEyLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZignY2FwYWJpbGl0eScgaW4gdG9rZW5QYXJhbXMpIHtcblx0XHRcdHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgPSBjMTRuKHRva2VuUGFyYW1zLmNhcGFiaWxpdHkpO1xuXHRcdH1cblxuXHRcdHZhciByZXF1ZXN0ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oeyBrZXlOYW1lOiBrZXlOYW1lIH0sIHRva2VuUGFyYW1zKSxcblx0XHRcdGNsaWVudElkID0gdG9rZW5QYXJhbXMuY2xpZW50SWQgfHwgJycsXG5cdFx0XHR0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgJycsXG5cdFx0XHRjYXBhYmlsaXR5ID0gdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSB8fCAnJyxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0KGZ1bmN0aW9uKGF1dGhvcmlzZUNiKSB7XG5cdFx0XHRpZihyZXF1ZXN0LnRpbWVzdGFtcCkge1xuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9O1xuXHRcdFx0c2VsZi5nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lLCBmdW5jdGlvbihlcnIsIHRpbWUpIHtcblx0XHRcdFx0aWYoZXJyKSB7Y2FsbGJhY2soZXJyKTsgcmV0dXJuO31cblx0XHRcdFx0cmVxdWVzdC50aW1lc3RhbXAgPSB0aW1lO1xuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xuXHRcdFx0fSk7XG5cdFx0fSkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBub25jZSAqL1xuXHRcdFx0LyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG5cdFx0XHQgKiBzcGVjaWZpZXMgdGhlIG5vbmNlOyB0aGlzIGlzIGRvbmUgYnkgdGhlIGxpYnJhcnlcblx0XHRcdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuXHRcdFx0ICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xuXHRcdFx0dmFyIG5vbmNlID0gcmVxdWVzdC5ub25jZSB8fCAocmVxdWVzdC5ub25jZSA9IHJhbmRvbSgpKSxcblx0XHRcdFx0dGltZXN0YW1wID0gcmVxdWVzdC50aW1lc3RhbXA7XG5cblx0XHRcdHZhciBzaWduVGV4dFxuXHRcdFx0PVx0cmVxdWVzdC5rZXlOYW1lICsgJ1xcbidcblx0XHRcdCtcdHR0bCArICdcXG4nXG5cdFx0XHQrXHRjYXBhYmlsaXR5ICsgJ1xcbidcblx0XHRcdCtcdGNsaWVudElkICsgJ1xcbidcblx0XHRcdCtcdHRpbWVzdGFtcCArICdcXG4nXG5cdFx0XHQrXHRub25jZSArICdcXG4nO1xuXG5cdFx0XHQvKiBtYWMgKi9cblx0XHRcdC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuXHRcdFx0ICogc3BlY2lmaWVzIHRoZSBtYWM7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuXHRcdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG5cdFx0XHQgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG5cdFx0XHRyZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XG5cblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW5SZXF1ZXN0KCknLCAnZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0Jyk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhdXRoIHF1ZXJ5IHBhcmFtcyB0byB1c2UgZm9yIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24sXG5cdCAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuZ2V0QXV0aFBhcmFtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0aWYodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJylcblx0XHRcdGNhbGxiYWNrKG51bGwsIHtrZXk6IHRoaXMua2V5fSk7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHthY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbn0pO1xuXHRcdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgdG8gdXNlIGZvciBhIFJFU1Qgb3IgY29tZXQgcmVxdWVzdCxcblx0ICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5nZXRBdXRoSGVhZGVycyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0aWYodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJykge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwge2F1dGhvcml6YXRpb246ICdCYXNpYyAnICsgdGhpcy5iYXNpY0tleX0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwge2F1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIHRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbil9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IHRpbWUgYmFzZWQgb24gdGhlIGxvY2FsIGNsb2NrLFxuXHQgKiBvciBpZiB0aGUgb3B0aW9uIHF1ZXJ5VGltZSBpcyB0cnVlLCByZXR1cm4gdGhlIHNlcnZlciB0aW1lLlxuXHQgKiBUaGUgc2VydmVyIHRpbWUgb2Zmc2V0IGZyb20gdGhlIGxvY2FsIHRpbWUgaXMgc3RvcmVkIHNvIHRoYXRcblx0ICogb25seSBvbmUgcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgdGltZSBpcyBldmVyIG5lZWRlZFxuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24ocXVlcnlUaW1lLCBjYWxsYmFjaykge1xuXHRcdGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSAmJiAocXVlcnlUaW1lIHx8IHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKSkge1xuXHRcdFx0dGhpcy5jbGllbnQudGltZShjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSk7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpICsgKHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgfHwgMCk7XG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuaXNUaW1lT2Zmc2V0U2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgIT09IG51bGw7XG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuX3NhdmVCYXNpY09wdGlvbnMgPSBmdW5jdGlvbihhdXRoT3B0aW9ucykge1xuXHRcdHRoaXMubWV0aG9kID0gJ2Jhc2ljJztcblx0XHR0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcblx0XHR0aGlzLmJhc2ljS2V5ID0gdG9CYXNlNjQoYXV0aE9wdGlvbnMua2V5KTtcblx0XHR0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwge307XG5cdFx0aWYoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xuXHRcdFx0dGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcblx0XHR9XG5cdH1cblxuXHRBdXRoLnByb3RvdHlwZS5fc2F2ZVRva2VuT3B0aW9ucyA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuXHRcdHRoaXMubWV0aG9kID0gJ3Rva2VuJztcblxuXHRcdGlmKHRva2VuUGFyYW1zKSB7XG5cdFx0XHQvKiBXZSB0ZW1wb3JhcmlseSBwZXJzaXN0IHRva2VuUGFyYW1zLnRpbWVzdGFtcCBpbiBjYXNlIGEgbmV3IHRva2VuIG5lZWRzXG5cdFx0XHQgKiB0byBiZSByZXF1ZXN0ZWQsIHRoZW4gbnVsbCBpdCBvdXQgaW4gdGhlIGNhbGxiYWNrIG9mXG5cdFx0XHQgKiBfZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgZm9yIFJTQTEwZyBjb21wbGlhbmNlICovXG5cdFx0XHR0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XG5cdFx0fVxuXG5cdFx0aWYoYXV0aE9wdGlvbnMpIHtcblx0XHRcdC8qIG5vcm1hbGlzZSAqL1xuXHRcdFx0aWYoYXV0aE9wdGlvbnMudG9rZW4pIHtcblx0XHRcdFx0Lyogb3B0aW9ucy50b2tlbiBtYXkgY29udGFpbiBhIHRva2VuIHN0cmluZyBvciwgZm9yIGNvbnZlbmllbmNlLCBhIFRva2VuRGV0YWlscyAqL1xuXHRcdFx0XHRhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMgPSAodHlwZW9mKGF1dGhPcHRpb25zLnRva2VuKSA9PT0gJ3N0cmluZycpID8ge3Rva2VuOiBhdXRoT3B0aW9ucy50b2tlbn0gOiBhdXRoT3B0aW9ucy50b2tlbjtcblx0XHRcdH1cblxuXHRcdFx0aWYoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRcdHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZignY2xpZW50SWQnIGluIGF1dGhPcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucztcblx0XHR9XG5cdH07XG5cblx0LyogQHBhcmFtIGZvcmNlU3VwZXJzZWRlOiBmb3JjZSBhIG5ldyB0b2tlbiByZXF1ZXN0IGV2ZW4gaWYgdGhlcmUncyBvbmUgaW5cblx0ICogcHJvZ3Jlc3MsIG1ha2luZyBhbGwgcGVuZGluZyBjYWxsYmFja3Mgd2FpdCBmb3IgdGhlIG5ldyBvbmUgKi9cblx0QXV0aC5wcm90b3R5cGUuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oZm9yY2VTdXBlcnNlZGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0dG9rZW4gPSB0aGlzLnRva2VuRGV0YWlscztcblxuXHRcdGlmKHRva2VuKSB7XG5cdFx0XHRpZih0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2godG9rZW4uY2xpZW50SWQpKSB7XG5cdFx0XHRcdC8qIDQwMyB0byB0cmlnZ2VyIGEgcGVybWFuZW50bHkgZmFpbGVkIGNsaWVudCAtIFJTQTE1YyAqL1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdNaXNtYXRjaCBiZXR3ZWVuIGNsaWVudElkIGluIHRva2VuICgnICsgdG9rZW4uY2xpZW50SWQgKyAnKSBhbmQgY3VycmVudCBjbGllbnRJZCAoJyArIHRoaXMuY2xpZW50SWQgKyAnKScsIDQwMTAyLCA0MDMpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogUlNBNGIxIC0tIGlmIHdlIGhhdmUgYSBzZXJ2ZXIgdGltZSBvZmZzZXQgc2V0IGFscmVhZHksIHdlIGNhblxuXHRcdFx0ICogYXV0b3JlbW92ZSBleHBpcmVkIHRva2Vucy4gRWxzZSBqdXN0IHVzZSB0aGUgY2FjaGVkIHRva2VuLiBJZiBpdCBpc1xuXHRcdFx0ICogZXhwaXJlZCBBYmx5IHdpbGwgdGVsbCB1cyBhbmQgd2UnbGwgZGlzY2FyZCBpdCB0aGVuLiAqL1xuXHRcdFx0aWYoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgfHwgIXRva2VuLmV4cGlyZXMgfHwgKHRva2VuLmV4cGlyZXMgPj0gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKSkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gJyArIHRva2VuLmV4cGlyZXMpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGV4cGlyZWQsIHNvIHJlbW92ZSBhbmQgZmFsbHRocm91Z2ggdG8gZ2V0dGluZyBhIG5ldyBvbmUgKi9cblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICdkZWxldGluZyBleHBpcmVkIHRva2VuJyk7XG5cdFx0XHR0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0KHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gT2JqZWN0KG11bHRpY2FzdGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpKSkucHVzaChjYWxsYmFjayk7XG5cdFx0aWYodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogUmVxdWVzdCBhIG5ldyB0b2tlbiAqL1xuXHRcdHZhciB0b2tlblJlcXVlc3RJZCA9IHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gZ2V0VG9rZW5SZXF1ZXN0SWQoKTtcblx0XHR0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UpIHtcblx0XHRcdGlmKHNlbGYuY3VycmVudFRva2VuUmVxdWVzdElkID4gdG9rZW5SZXF1ZXN0SWQpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoKScsICdEaXNjYXJkaW5nIHRva2VuIHJlcXVlc3QgcmVzcG9uc2U7IG92ZXJ0YWtlbiBieSBuZXdlciBvbmUnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IHNlbGYud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCBub29wO1xuXHRcdFx0c2VsZi53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFja3MoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2tzKG51bGwsIChzZWxmLnRva2VuRGV0YWlscyA9IHRva2VuUmVzcG9uc2UpKTtcblx0XHR9KTtcblx0fTtcblxuXG5cdC8qIFVzZXItc2V0OiBjaGVjayB0eXBlcywgJyonIGlzIGRpc2FsbG93ZWQsIHRocm93IGFueSBlcnJvcnMgKi9cblx0QXV0aC5wcm90b3R5cGUuX3VzZXJTZXRDbGllbnRJZCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XG5cdFx0aWYoISh0eXBlb2YoY2xpZW50SWQpID09PSAnc3RyaW5nJyB8fCBjbGllbnRJZCA9PT0gbnVsbCkpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwnLCA0MDAxMiwgNDAwKTtcblx0XHR9IGVsc2UgaWYoY2xpZW50SWQgPT09ICcqJykge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLCA0MDAxMiwgNDAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcblx0XHRcdGlmKGVycikgdGhyb3cgZXJyO1xuXHRcdH1cblx0fTtcblxuXHQvKiBBYmx5LXNldDogbm8gdHlwZWNoZWNraW5nLCAnKicgaXMgYWxsb3dlZCBidXQgbm90IHNldCBvbiB0aGlzLmNsaWVudElkKSwgcmV0dXJuIGVycm9ycyB0byB0aGUgY2FsbGVyICovXG5cdEF1dGgucHJvdG90eXBlLl91bmNoZWNrZWRTZXRDbGllbnRJZCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XG5cdFx0aWYodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuXHRcdFx0LyogU2hvdWxkIG5ldmVyIGhhcHBlbiBpbiBub3JtYWwgY2lyY3Vtc3RhbmNlcyBhcyByZWFsdGltZSBzaG91bGRcblx0XHRcdCAqIHJlY29nbmlzZSBtaXNtYXRjaCBhbmQgcmV0dXJuIGFuIGVycm9yICovXG5cdFx0XHR2YXIgbXNnID0gJ1VuZXhwZWN0ZWQgY2xpZW50SWQgbWlzbWF0Y2g6IGNsaWVudCBoYXMgJyArIHRoaXMuY2xpZW50SWQgKyAnLCByZXF1ZXN0ZWQgJyArIGNsaWVudElkO1xuXHRcdFx0dmFyIGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDEwMiwgNDAxKTtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGguX3VuY2hlY2tlZFNldENsaWVudElkKCknLCBtc2cpO1xuXHRcdFx0cmV0dXJuIGVycjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogUlNBN2E0OiBpZiBvcHRpb25zLmNsaWVudElkIGlzIHByb3ZpZGVkIGFuZCBpcyBub3Rcblx0XHRcdCAqIG51bGwsIGl0IG92ZXJyaWRlcyBkZWZhdWx0VG9rZW5QYXJhbXMuY2xpZW50SWQgKi9cblx0XHRcdHRoaXMuY2xpZW50SWQgPSB0aGlzLnRva2VuUGFyYW1zLmNsaWVudElkID0gY2xpZW50SWQ7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCA9IGZ1bmN0aW9uKHRva2VuQ2xpZW50SWQpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnRJZCAmJlxuXHRcdFx0KHRoaXMuY2xpZW50SWQgIT09ICcqJykgJiZcblx0XHRcdHRva2VuQ2xpZW50SWQgJiZcblx0XHRcdCh0b2tlbkNsaWVudElkICE9PSAnKicpICYmXG5cdFx0XHQodGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XG5cdH07XG5cblx0QXV0aC5pc1Rva2VuRXJyID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRyZXR1cm4gZXJyb3IuY29kZSAmJiAoZXJyb3IuY29kZSA+PSA0MDE0MCkgJiYgKGVycm9yLmNvZGUgPCA0MDE1MCk7XG5cdH07XG5cblx0cmV0dXJuIEF1dGg7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhdXRoID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoYXV0aF9BdXRoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG5cblxuXG52YXIgQ29tZXRUcmFuc3BvcnQgPSAoZnVuY3Rpb24oKSB7XG5cblx0dmFyIFJFUV9TRU5EID0gMCxcblx0XHRSRVFfUkVDViA9IDEsXG5cdFx0UkVRX1JFQ1ZfUE9MTCA9IDIsXG5cdFx0UkVRX1JFQ1ZfU1RSRUFNID0gMztcblxuXHQvKiBUT0RPOiBjYW4gcmVtb3ZlIG9uY2UgcmVhbHRpbWUgc2VuZHMgcHJvdG9jb2wgbWVzc2FnZSByZXNwb25zZXMgZm9yIGNvbWV0IGVycm9ycyAqL1xuXHRmdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuXHRcdHZhciBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG5cdFx0aWYoZXJyLmNvZGUpIHtcblx0XHRcdGlmKF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoZXJyKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0aWYoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbihVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMsIGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRyZXR1cm4gKGVyci5jb2RlID49IDQwMDAwICYmIGVyci5jb2RlIDwgNTAwMDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBMaWtlbHkgYSBuZXR3b3JrIG9yIHRyYW5zcG9ydCBlcnJvciBvZiBzb21lIGtpbmQuIENlcnRhaW5seSBub3QgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSB7XG5cdFx0LyogZXJyIHdpbGwgYmUgZWl0aGVyIGEgbGVnYWN5IChub24tcHJvdG9jb2xtZXNzYWdlKSBjb21ldCBlcnJvciByZXNwb25zZVxuXHRcdCAqICh3aGljaCB3aWxsIGhhdmUgYW4gZXJyLmNvZGUpLCBvciBhIHhoci9uZXR3b3JrIGVycm9yICh3aGljaCB3b24ndCkuICovXG5cdFx0aWYoc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpKSB7XG5cdFx0XHRyZXR1cm4gW190eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb24uRVJST1IsIGVycm9yOiBlcnJ9KV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbi5ESVNDT05ORUNURUQsIGVycm9yOiBlcnJ9KV07XG5cdFx0fVxuXHR9XG5cblx0Lypcblx0ICogQSBiYXNlIGNvbWV0IHRyYW5zcG9ydCBjbGFzc1xuXHQgKi9cblx0ZnVuY3Rpb24gQ29tZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCwgc28ganVzdCBmYWxsIGJhY2sgdG8gZGVmYXVsdCAqL1xuXHRcdHBhcmFtcy5mb3JtYXQgPSB1bmRlZmluZWQ7XG5cdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSB0cnVlO1xuXHRcdF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHQvKiBzdHJlYW1pbmcgZGVmYXVsdHMgdG8gdHJ1ZSAqL1xuXHRcdHRoaXMuc3RyZWFtID0gKCdzdHJlYW0nIGluIHBhcmFtcykgPyBwYXJhbXMuc3RyZWFtIDogdHJ1ZTtcblx0XHR0aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcblx0XHR0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcblx0XHR0aGlzLnBlbmRpbmdDYWxsYmFjayA9IG51bGw7XG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoQ29tZXRUcmFuc3BvcnQsIF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdENvbWV0VHJhbnNwb3J0LlJFUV9TRU5EID0gUkVRX1NFTkQ7XG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWID0gUkVRX1JFQ1Y7XG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1BPTEwgPSBSRVFfUkVDVl9QT0xMO1xuXHRDb21ldFRyYW5zcG9ydC5SRVFfUkVDVl9TVFJFQU0gPSBSRVFfUkVDVl9TVFJFQU07XG5cblx0LyogcHVibGljIGluc3RhbmNlIG1ldGhvZHMgKi9cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3N0YXJ0aW5nJyk7XG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuXHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblx0XHR2YXIgaG9zdCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0SG9zdChvcHRpb25zLCBwYXJhbXMuaG9zdCk7XG5cdFx0dmFyIHBvcnQgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFBvcnQob3B0aW9ucyk7XG5cdFx0dmFyIGNvbWV0U2NoZW1lID0gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xuXG5cdFx0dGhpcy5iYXNlVXJpID0gY29tZXRTY2hlbWUgKyBob3N0ICsgJzonICsgcG9ydCArICcvY29tZXQvJztcblx0XHR2YXIgY29ubmVjdFVyaSA9IHRoaXMuYmFzZVVyaSArICdjb25uZWN0Jztcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIGNvbm5lY3RVcmkpO1xuXHRcdHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZihzZWxmLmlzRGlzcG9zZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5hdXRoUGFyYW1zID0gYXV0aFBhcmFtcztcblx0XHRcdHZhciBjb25uZWN0UGFyYW1zID0gc2VsZi5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcblx0XHRcdGlmKCdzdHJlYW0nIGluIGNvbm5lY3RQYXJhbXMpIHNlbGYuc3RyZWFtID0gY29ubmVjdFBhcmFtcy5zdHJlYW07XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ2Nvbm5lY3RQYXJhbXM6JyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKSk7XG5cblx0XHRcdC8qIHRoaXMgd2lsbCBiZSB0aGUgJ3JlY3ZSZXF1ZXN0JyBzbyB0aGlzIGNvbm5lY3Rpb24gY2FuIHN0cmVhbSBtZXNzYWdlcyAqL1xuXHRcdFx0dmFyIHByZWNvbm5lY3RlZCA9IGZhbHNlLFxuXHRcdFx0XHRjb25uZWN0UmVxdWVzdCA9IHNlbGYucmVjdlJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3QoY29ubmVjdFVyaSwgbnVsbCwgY29ubmVjdFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1YpKTtcblxuXHRcdFx0Y29ubmVjdFJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdGlmKCFzZWxmLnJlY3ZSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0LyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighcHJlY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0cHJlY29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3ByZWNvbm5lY3QnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0XHRcdH0pO1xuXHRcdFx0Y29ubmVjdFJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyLCBfYm9keSwgaGVhZGVycykge1xuXHRcdFx0XHRpZighc2VsZi5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRcdC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cblx0XHRcdFx0XHRlcnIgPSBlcnIgfHwgbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnUmVxdWVzdCBjYW5jZWxsZWQnLCA4MDAwMywgNDAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcblx0XHRcdFx0LyogQ29ubmVjdCByZXF1ZXN0IG1heSBjb21wbGV0ZSB3aXRob3V0IGEgZW1pdHRpbmcgJ2RhdGEnIGV2ZW50IHNpbmNlIHRoYXQgaXMgbm90XG5cdFx0XHRcdCAqIGVtaXR0ZWQgZm9yIGUuZy4gYSBub24tc3RyZWFtZWQgZXJyb3IgcmVzcG9uc2UuIFN0aWxsIGltcGxpZXMgcHJlY29ubmVjdC4gKi9cblx0XHRcdFx0aWYoIXByZWNvbm5lY3RlZCAmJiAhZXJyKSB7XG5cdFx0XHRcdFx0cHJlY29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3ByZWNvbm5lY3QnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLm9uQWN0aXZpdHkoKTtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyLmNvZGUpIHtcblx0XHRcdFx0XHRcdC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuXHRcdFx0XHRcdFx0ICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcblx0XHRcdFx0XHRcdCAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cblx0XHRcdFx0XHRcdHNlbGYub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcblx0XHRcdFx0XHRcdCAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5yZWN2KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25uZWN0UmVxdWVzdC5leGVjKCk7XG5cdFx0fSk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScpO1xuXHRcdHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCh0cnVlKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScpO1xuXHRcdHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QgPSBmdW5jdGlvbihjbG9zaW5nKSB7XG5cdFx0dmFyIGNsb3NlT3JEaXNjb25uZWN0VXJpID0gY2xvc2luZyA/IHRoaXMuY2xvc2VVcmkgOiB0aGlzLmRpc2Nvbm5lY3RVcmk7XG5cdFx0aWYoY2xvc2VPckRpc2Nvbm5lY3RVcmkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0cmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChjbG9zZU9yRGlzY29ubmVjdFVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCBSRVFfU0VORCk7XG5cblx0XHRcdHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdCcgKyAoY2xvc2luZyA/ICdDbG9zZSgpJyA6ICdEaXNjb25uZWN0KCknKSwgJ3JlcXVlc3QgcmV0dXJuZWQgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdHNlbGYuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJlcXVlc3QuZXhlYygpO1xuXHRcdH1cblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0aWYoIXRoaXMuaXNEaXNwb3NlZCkge1xuXHRcdFx0dGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcblx0XHRcdGlmKHRoaXMucmVjdlJlcXVlc3QpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdhYm9ydGluZyByZWN2IHJlcXVlc3QnKTtcblx0XHRcdFx0dGhpcy5yZWN2UmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0XHR0aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8qIEluIGFsbW9zdCBhbGwgY2FzZXMgdGhlIHRyYW5zcG9ydCB3aWxsIGJlIGZpbmlzaGVkIGJlZm9yZSBpdCdzXG5cdFx0XHQgKiBkaXNwb3NlZC4gRmluaXNoIGhlcmUganVzdCB0byBtYWtlIHN1cmUuICovXG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgX2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRpc2Nvbm5lY3RlZCk7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Rpc3Bvc2VkJyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBpZiB0aGlzIHRyYW5zcG9ydCBoYXMgYmVlbiBkaXNwb3NlZCB3aGlsc3QgYXdhaXRpbmcgY29ubmVjdGlvbiwgZG8gbm90aGluZyAqL1xuXHRcdGlmKHRoaXMuaXNEaXNwb3NlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIHRoZSBjb25uZWN0aW9uS2V5IGluIGEgY29tZXQgY29ubmVjdGVkIHJlc3BvbnNlIGlzIHJlYWxseVxuXHRcdCAqIDxpbnN0SWQ+LTxjb25uZWN0aW9uS2V5PiAqL1xuXHRcdHZhciBjb25uZWN0aW9uU3RyID0gbWVzc2FnZS5jb25uZWN0aW9uS2V5O1xuXHRcdF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucHJvdG90eXBlLm9uQ29ubmVjdC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG5cdFx0dmFyIGJhc2VDb25uZWN0aW9uVXJpID0gIHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NvbWV0VHJhbnNwb3J0Lm9uQ29ubmVjdCgpJywgJ2Jhc2VVcmkgPSAnICsgYmFzZUNvbm5lY3Rpb25VcmkgKyAnOyBjb25uZWN0aW9uS2V5ID0gJyArIG1lc3NhZ2UuY29ubmVjdGlvbktleSk7XG5cdFx0dGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3NlbmQnO1xuXHRcdHRoaXMucmVjdlVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9yZWN2Jztcblx0XHR0aGlzLmNsb3NlVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Nsb3NlJztcblx0XHR0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvZGlzY29ubmVjdCc7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0aWYodGhpcy5zZW5kUmVxdWVzdCkge1xuXHRcdFx0LyogdGhlcmUgaXMgYSBwZW5kaW5nIHNlbmQsIHNvIHF1ZXVlIHRoaXMgbWVzc2FnZSAqL1xuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcblx0XHRcdHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8qIHNlbmQgdGhpcywgcGx1cyBhbnkgcGVuZGluZywgbm93ICovXG5cdFx0dmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuXHRcdHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblxuXHRcdHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRBbnlQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zO1xuXG5cdFx0aWYoIXBlbmRpbmdJdGVtcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblx0XHR0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuXHR9XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0c2VuZFJlcXVlc3QgPSB0aGlzLnNlbmRSZXF1ZXN0ID0gc2VsZi5jcmVhdGVSZXF1ZXN0KHNlbGYuc2VuZFVyaSwgbnVsbCwgc2VsZi5hdXRoUGFyYW1zLCB0aGlzLmVuY29kZVJlcXVlc3QoaXRlbXMpLCBSRVFfU0VORCk7XG5cblx0XHRzZW5kUmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcblx0XHRcdGlmKGVycikgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnNlbmRJdGVtcygpJywgJ29uIGNvbXBsZXRlOiBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRzZWxmLnNlbmRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdFx0LyogdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdCwgZXZlbiBpZiBhIG5hY2ssIGlzIHVzdWFsbHkgYSBwcm90b2NvbCByZXNwb25zZVxuXHRcdFx0ICogY29udGFpbmVkIGluIHRoZSBkYXRhLiBBbiBlcnIgaXMgYW5vbW9sb3VzLCBhbmQgaW5kaWNhdGVzIHNvbWUgaXNzdWUgd2l0aCB0aGVcblx0XHRcdCAqIG5ldHdvcmssdHJhbnNwb3J0LCBvciBjb25uZWN0aW9uICovXG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0aWYoZXJyLmNvZGUpIHtcblx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuXHRcdFx0XHRcdCAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cblx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcblx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoc2VsZi5wZW5kaW5nSXRlbXMpIHtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvKiBJZiB0aGVyZSdzIGEgbmV3IHNlbmQgcmVxdWVzdCBieSBub3csIGFueSBwZW5kaW5nIGl0ZW1zIHdpbGwgaGF2ZVxuXHRcdFx0XHRcdCAqIGJlZW4gcGlja2VkIHVwIGJ5IHRoYXQ7IGFueSBuZXcgb25lcyBhZGRlZCBzaW5jZSB0aGVuIHdpbGwgYmVcblx0XHRcdFx0XHQgKiBwaWNrZWQgdXAgYWZ0ZXIgdGhhdCBvbmUgY29tcGxldGVzICovXG5cdFx0XHRcdFx0aWYoIXNlbGYuc2VuZFJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdHNlbGYuc2VuZEFueVBlbmRpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHNlbmRSZXF1ZXN0LmV4ZWMoKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVjdiA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHJlcXVlc3QsIHdoaWNoIG1pZ2h0IGJlIHN0cmVhbWluZyAqL1xuXHRcdGlmKHRoaXMucmVjdlJlcXVlc3QpXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvKiBJZiB3ZSdyZSBubyBsb25nZXIgY29ubmVjdGVkLCBkbyBub3RoaW5nICovXG5cdFx0aWYoIXRoaXMuaXNDb25uZWN0ZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRyZWN2UmVxdWVzdCA9IHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QodGhpcy5yZWN2VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIChzZWxmLnN0cmVhbSA/IFJFUV9SRUNWX1NUUkVBTSA6IFJFUV9SRUNWX1BPTEwpKTtcblxuXHRcdHJlY3ZSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0c2VsZi5vbkRhdGEoZGF0YSk7XG5cdFx0fSk7XG5cdFx0cmVjdlJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRzZWxmLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcblx0XHRcdC8qIEEgcmVxdWVzdCBjb21wbGV0aW5nIG11c3QgYmUgY29uc2lkZXJlZCBhY3Rpdml0eSwgYXMgcmVhbHRpbWUgc2VuZHNcblx0XHRcdCAqIGhlYXJ0YmVhdHMgZXZlcnkgMTVzIHNpbmNlIGEgcmVxdWVzdCBiZWdhbiwgbm90IGV2ZXJ5IDE1cyBhYnNvbHV0ZWx5ICovXG5cdFx0XHRzZWxmLm9uQWN0aXZpdHkoKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0XHRcdC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuXHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG5cdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRcdHNlbGYub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHRcdCAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZWN2KCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRyZWN2UmVxdWVzdC5leGVjKCk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKHJlc3BvbnNlRGF0YSkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XG5cdFx0XHRpZihpdGVtcyAmJiBpdGVtcy5sZW5ndGgpXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHR0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tRGVzZXJpYWxpemVkKGl0ZW1zW2ldKSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0Lm9uRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBldmVudDogJyArIGUuc3RhY2spO1xuXHRcdH1cblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZW5jb2RlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3RJdGVtcykge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0SXRlbXMpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kZWNvZGVSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlRGF0YSkge1xuXHRcdGlmKHR5cGVvZihyZXNwb25zZURhdGEpID09ICdzdHJpbmcnKVxuXHRcdFx0cmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xuXHRcdHJldHVybiByZXNwb25zZURhdGE7XG5cdH07XG5cblx0LyogRm9yIGNvbWV0LCB3ZSBjb3VsZCBkbyB0aGUgYXV0aCB1cGRhdGUgYnkgYWJvcnRpbmcgdGhlIGN1cnJlbnQgcmVjdiBhbmRcblx0ICogc3RhcnRpbmcgYSBuZXcgb25lIHdpdGggdGhlIG5ldyB0b2tlbiwgdGhhdCdkIGJlIHN1ZmZpY2llbnQgZm9yIHJlYWx0aW1lLlxuXHQgKiBQcm9ibGVtIGlzIEpTT05QIC0geW91IGNhbid0IGNhbmNlbCB0cnVseSBhYm9ydCBhIHJlY3Ygb25jZSBzdGFydGVkLiBTb1xuXHQgKiB3ZSBuZWVkIHRvIHNlbmQgYW4gQVVUSCBmb3IganNvbnAuIEluIHdoaWNoIGNhc2UgaXQncyBzaW1wbGVyIHRvIGtlZXAgYWxsXG5cdCAqIGNvbWV0IHRyYW5zcG9ydHMgdGhlIHNhbWUgYW5kIGRvIGl0IGZvciBhbGwgb2YgdGhlbS4gU28gd2Ugc2VuZCB0aGUgQVVUSFxuXHQgKiBpbnN0ZWFkLCBhbmQgZG9uJ3QgbmVlZCB0byBhYm9ydCB0aGUgcmVjdiAqL1xuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uKHRva2VuRGV0YWlscykge1xuXHRcdHRoaXMuYXV0aFBhcmFtcyA9IHthY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbn07XG5cdH07XG5cblx0cmV0dXJuIENvbWV0VHJhbnNwb3J0O1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb21ldFRyYW5zcG9ydCk7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG52YXIgV2ViU3RvcmFnZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIHNlc3Npb25TdXBwb3J0ZWQsXG5cdFx0bG9jYWxTdXBwb3J0ZWQsXG5cdFx0dGVzdCA9ICdhYmx5anMtc3RvcmFnZS10ZXN0JztcblxuXHQvKiBFdmVuIGp1c3QgYWNjZXNzaW5nIHRoZSBzZXNzaW9uL2xvY2FsU3RvcmFnZSBvYmplY3QgY2FuIHRocm93IGFcblx0ICogc2VjdXJpdHkgZXhjZXB0aW9uIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3aXRoIHNvbWUgYnJvd3NlcnMuIEluXG5cdCAqIG90aGVycywgY2FsbGluZyBzZXRJdGVtIHdpbGwgdGhyb3cuIFNvIGhhdmUgdG8gY2hlY2sgaW4gdGhpc1xuXHQgKiBzb21ld2hhdCByb3VuZGFib3V0IHdheS4gKElmIHVuc3VwcG9ydGVkIG9yIG5vIGdsb2JhbCBvYmplY3QsXG5cdCAqIHdpbGwgdGhyb3cgb24gYWNjZXNzaW5nIGEgcHJvcGVydHkgb2YgdW5kZWZpbmVkKSAqL1xuXHR0cnkge1xuXHRcdGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuXHRcdGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuXHRcdHNlc3Npb25TdXBwb3J0ZWQgPSB0cnVlO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRzZXNzaW9uU3VwcG9ydGVkID0gZmFsc2U7XG5cdH1cblxuXHR0cnkge1xuXHRcdGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcblx0XHRnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG5cdFx0bG9jYWxTdXBwb3J0ZWQgPSB0cnVlO1xuXHR9IGNhdGNoKGUpIHtcblx0XHRsb2NhbFN1cHBvcnRlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViU3RvcmFnZSgpIHt9XG5cblx0ZnVuY3Rpb24gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKSB7XG5cdFx0cmV0dXJuIHNlc3Npb24gPyBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UgOiBnbG9iYWwubG9jYWxTdG9yYWdlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlLCB0dGwsIHNlc3Npb24pIHtcblx0XHR2YXIgd3JhcHBlZFZhbHVlID0ge3ZhbHVlOiB2YWx1ZX07XG5cdFx0aWYodHRsKSB7XG5cdFx0XHR3cmFwcGVkVmFsdWUuZXhwaXJlcyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSArIHR0bDtcblx0XHR9XG5cdFx0cmV0dXJuIHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikuc2V0SXRlbShuYW1lLCBKU09OLnN0cmluZ2lmeSh3cmFwcGVkVmFsdWUpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldChuYW1lLCBzZXNzaW9uKSB7XG5cdFx0dmFyIHJhd0l0ZW0gPSBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLmdldEl0ZW0obmFtZSk7XG5cdFx0aWYoIXJhd0l0ZW0pIHJldHVybiBudWxsO1xuXHRcdHZhciB3cmFwcGVkVmFsdWUgPSBKU09OLnBhcnNlKHJhd0l0ZW0pO1xuXHRcdGlmKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmICh3cmFwcGVkVmFsdWUuZXhwaXJlcyA8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSkpIHtcblx0XHRcdHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gd3JhcHBlZFZhbHVlLnZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIHNlc3Npb24pIHtcblx0XHRyZXR1cm4gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuXHR9XG5cblx0aWYobG9jYWxTdXBwb3J0ZWQpIHtcblx0XHRXZWJTdG9yYWdlLnNldCAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB0dGwpIHsgcmV0dXJuIHNldChuYW1lLCB2YWx1ZSwgdHRsLCBmYWxzZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5nZXQgICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBnZXQobmFtZSwgZmFsc2UpOyB9O1xuXHRcdFdlYlN0b3JhZ2UucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gcmVtb3ZlKG5hbWUsIGZhbHNlKTsgfTtcblx0fVxuXG5cdGlmKHNlc3Npb25TdXBwb3J0ZWQpIHtcblx0XHRXZWJTdG9yYWdlLnNldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgdHRsKSB7IHJldHVybiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5nZXRTZXNzaW9uICAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZ2V0KG5hbWUsIHRydWUpOyB9O1xuXHRcdFdlYlN0b3JhZ2UucmVtb3ZlU2Vzc2lvbiA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIHJlbW92ZShuYW1lLCB0cnVlKTsgfTtcblx0fVxuXG5cdHJldHVybiBXZWJTdG9yYWdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChXZWJTdG9yYWdlKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jztcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghcmV2ZXJzZU1hcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG5cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHNDb21iaW5lZCA9IGJpdHMxIHwgYml0czI7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSBiaXRzQ29tYmluZWQgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cblxuXG5cblxuXG52YXIgQ3J5cHRvID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgREVGQVVMVF9BTEdPUklUSE0gPSAnYWVzJztcblx0dmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2OyAvLyBiaXRzXG5cdHZhciBERUZBVUxUX01PREUgPSAnY2JjJztcblx0dmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjsgLy8gYnl0ZXNcblx0dmFyIERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMgPSA0OyAvLyAzMi1iaXQgd29yZHNcblx0dmFyIFVJTlQzMl9TVVAgPSAweDEwMDAwMDAwMDtcblx0dmFyIElOVDMyX1NVUCA9IDB4ODAwMDAwMDA7XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBzZWN1cmUgcmFuZG9tIHdvcmRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxlbmd0aCBvZiBieXRlc1xuXHQgKiBAcGFyYW0gYnl0ZXNcblx0ICogQHBhcmFtIGNhbGxiYWNrXG5cdCAqL1xuXHR2YXIgZ2VuZXJhdGVSYW5kb207XG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tV29yZEFycmF5KSB7XG5cdFx0Z2VuZXJhdGVSYW5kb20gPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVdvcmRBcnJheTtcblx0fSBlbHNlIGlmKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMpIHtcblx0XHR2YXIgYmxvY2tSYW5kb21BcnJheSA9IG5ldyBVaW50MzJBcnJheShERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTKTtcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uKGJ5dGVzLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHdvcmRzID0gYnl0ZXMgLyA0LCBuYXRpdmVBcnJheSA9ICh3b3JkcyA9PSBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTKSA/IGJsb2NrUmFuZG9tQXJyYXkgOiBuZXcgVWludDMyQXJyYXkod29yZHMpO1xuXHRcdFx0cGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMobmF0aXZlQXJyYXksIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkobmF0aXZlQXJyYXkpKVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uKGJ5dGVzLCBjYWxsYmFjaykge1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUFKT1IsICdBYmx5LkNyeXB0by5nZW5lcmF0ZVJhbmRvbSgpJywgJ1dhcm5pbmc6IHRoZSBicm93c2VyIHlvdSBhcmUgdXNpbmcgZG9lcyBub3Qgc3VwcG9ydCBzZWN1cmUgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbW5lc3MgZ2VuZXJhdGlvbjsgZmFsbGluZyBiYWNrIHRvIGluc2VjdXJlIE1hdGgucmFuZG9tKCknKTtcblx0XHRcdHZhciB3b3JkcyA9IGJ5dGVzIC8gNCwgYXJyYXkgPSBuZXcgQXJyYXkod29yZHMpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcblx0XHRcdFx0LyogY3J5cHRvanMgd29yZGFycmF5cyB1c2Ugc2lnbmVkIGludHMuIFdoZW4gV29yZEFycmF5LmNyZWF0ZSBpcyBmZWQgYVxuXHRcdFx0XHQqIFVpbnQzMkFycmF5IHVuc2lnbmVkIGFyZSBjb252ZXJ0ZWQgdG8gc2lnbmVkIGF1dG9tYXRpY2FsbHksIGJ1dCB3aGVuXG5cdFx0XHRcdCogZmVkIGEgbm9ybWFsIGFycmF5IHRoZXkgYXJlbid0LCBzbyBuZWVkIHRvIGRvIHNvIG91cnNlbHZlcyBieVxuXHRcdFx0XHQqIHN1YnRyYWN0aW5nIElOVDMyX1NVUCAqL1xuXHRcdFx0XHRhcnJheVtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFVJTlQzMl9TVVApIC0gSU5UMzJfU1VQO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayhudWxsLCBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShhcnJheSkpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGNhbGN1bGF0ZSB0aGUgcGFkZGVkIGxlbmd0aCBvZiBhIGdpdmVuIHBsYWludGV4dFxuXHQgKiB1c2luZyBQS0NTNS5cblx0ICogQHBhcmFtIHBsYWludGV4dExlbmd0aFxuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSB7XG5cdFx0cmV0dXJuIChwbGFpbnRleHRMZW5ndGggKyBERUZBVUxUX0JMT0NLTEVOR1RIKSAmIC1ERUZBVUxUX0JMT0NLTEVOR1RIO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBjaGVja3MgdGhhdCB0aGUgY2lwaGVyUGFyYW1zIGFyZSBhIHZhbGlkIGNvbWJpbmF0aW9uLiBDdXJyZW50bHlcblx0ICoganVzdCBjaGVja3MgdGhhdCB0aGUgY2FsY3VsYXRlZCBrZXlMZW5ndGggaXMgYSB2YWxpZCBvbmUgZm9yIGFlcy1jYmNcblx0ICovXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xuXHRcdGlmKHBhcmFtcy5hbGdvcml0aG0gPT09ICdhZXMnICYmIHBhcmFtcy5tb2RlID09PSAnY2JjJykge1xuXHRcdFx0aWYocGFyYW1zLmtleUxlbmd0aCA9PT0gMTI4IHx8IHBhcmFtcy5rZXlMZW5ndGggPT09IDI1Nikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBsZW5ndGggJyArIHBhcmFtcy5rZXlMZW5ndGggKyAnIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKScpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5vcm1hbGlzZUJhc2U2NChzdHJpbmcpIHtcblx0XHQvKiB1cmwtc2FmZSBiYXNlNjQgc3RyaW5ncyB1c2UgXyBhbmQgLSBpbnN0cmVhZCBvZiAvIGFuZCArICovXG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCdfJywgJy8nKS5yZXBsYWNlKCctJywgJysnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogYSBibG9jayBjb250YWluaW5nIHplcm9zXG5cdCAqL1xuXHR2YXIgZW1wdHlCbG9jayA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFswLDAsMCwwXSk7XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBvYnRhaW4gdGhlIHBrY3M1IHBhZGRpbmcgc3RyaW5nIGZvciBhIGdpdmVuIHBhZGRlZCBsZW5ndGg7XG5cdCAqL1xuXHR2YXIgcGtjczVQYWRkaW5nID0gW1xuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwXSwgMTYpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAxMDAwMDAwXSwgMSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDIwMjAwMDBdLCAyKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMzAzMDMwMF0sIDMpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA0MDQwNDA0XSwgNCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDUwNTA1MDUsMHgwNTAwMDAwMF0sIDUpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA2MDYwNjA2LDB4MDYwNjAwMDBdLCA2KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNzA3MDcwNywweDA3MDcwNzAwXSwgNyksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDgwODA4MDgsMHgwODA4MDgwOF0sIDgpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA5MDkwOTA5LDB4MDkwOTA5MDksMHgwOTAwMDAwMF0sIDkpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBhMGEwYTBhLDB4MGEwYTBhMGEsMHgwYTBhMDAwMF0sIDEwKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYjBiMGIwYiwweDBiMGIwYjBiLDB4MGIwYjBiMDBdLCAxMSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGMwYzBjMGMsMHgwYzBjMGMwYywweDBjMGMwYzBjXSwgMTIpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBkMGQwZDBkLDB4MGQwZDBkMGQsMHgwZDBkMGQwZCwweDBkMDAwMDAwXSwgMTMpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBlMGUwZTBlLDB4MGUwZTBlMGUsMHgwZTBlMGUwZSwweDBlMGUwMDAwXSwgMTQpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBmMGYwZjBmLDB4MGYwZjBmMGYsMHgwZjBmMGYwZiwweDBmMGYwZjBmXSwgMTUpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwXSwgMTYpXG5cdF07XG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBmb3IgbWVzc2FnZSBwYXlsb2FkIGVuY3J5cHRpb24uXG5cdCAqXG5cdCAqIFRoaXMgY2xhc3Mgc3VwcG9ydHMgQUVTL0NCQy9QS0NTNSB3aXRoIGEgZGVmYXVsdCBrZXlsZW5ndGggb2YgMTI4IGJpdHNcblx0ICogYnV0IHN1cHBvcnRpbmcgb3RoZXIga2V5bGVuZ3Rocy4gT3RoZXIgYWxnb3JpdGhtcyBhbmQgY2hhaW5pbmcgbW9kZXMgYXJlXG5cdCAqIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHksIGJ1dCBzdXBwb3J0YWJsZSBieSBleHRlbmRpbmcvaW1wbGVtZW50aW5nIHRoZSBiYXNlXG5cdCAqIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgaGVyZS5cblx0ICpcblx0ICogU2VjdXJlIHJhbmRvbSBkYXRhIGZvciBjcmVhdGlvbiBvZiBJbml0aWFsaXphdGlvbiBWZWN0b3JzIChJVnMpIGFuZCBrZXlzXG5cdCAqIGlzIG9idGFpbmVkIGZyb20gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaWYgYXZhaWxhYmxlLCBvciBmcm9tXG5cdCAqIE1hdGgucmFuZG9tKCkgaWYgbm90LiBDbGllbnRzIHdobyBkbyBub3Qgd2FudCB0byBkZXBlbmQgb24gTWF0aC5yYW5kb20oKVxuXHQgKiBzaG91bGQgcG9seWZpbGwgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgd2l0aCBhIGxpYnJhcnkgdGhhdCBzZWVkc1xuXHQgKiBhIFBSTkcgd2l0aCByZWFsIGVudHJvcHkuXG5cdCAqXG5cdCAqIEVhY2ggbWVzc2FnZSBwYXlsb2FkIGlzIGVuY3J5cHRlZCB3aXRoIGFuIElWIGluIENCQyBtb2RlLCBhbmQgdGhlIElWIGlzXG5cdCAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSByZXN1bHRpbmcgcmF3IGNpcGhlcnRleHQgdG8gY29uc3RydWN0IHRoZSBcImNpcGhlcnRleHRcIlxuXHQgKiBkYXRhIHBhc3NlZCB0byB0aGUgcmVjaXBpZW50LlxuXHQgKi9cblx0ZnVuY3Rpb24gQ3J5cHRvKCkge31cblxuXHQvKipcblx0ICogQSBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSBjbGllbnQtc3BlY2lmaWFibGUgcGFyYW1ldGVycyBmb3Jcblx0ICogdGhlIGNpcGhlci5cblx0ICpcblx0ICogYWxnb3JpdGhtIGlzIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0gaW4gdGhlIGRlZmF1bHQgc3lzdGVtIHByb3ZpZGVyLFxuXHQgKiBvciB0aGUgbG93ZXItY2FzZWQgdmVyc2lvbiBvZiBpdDsgZWcgXCJhZXNcIiBvciBcIkFFU1wiLlxuXHQgKlxuXHQgKiBDbGllbnRzIGFyZSByZWNvbW1lbmRlZCB0byBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB0byB1c2UgdGhlXG5cdCAqIENyeXB0by5nZXREZWZhdWx0UGFyYW1zIGhlbHBlciwgd2hpY2ggd2lsbCBmaWxsIGluIGFueSBmaWVsZHMgbm90IHN1cHBsaWVkXG5cdCAqIHdpdGggZGVmYXVsdCB2YWx1ZXMgYW5kIHZhbGlkYXRpb24gdGhlIHJlc3VsdC5cblx0ICovXG5cdGZ1bmN0aW9uIENpcGhlclBhcmFtcygpIHtcblx0XHR0aGlzLmFsZ29yaXRobSA9IG51bGw7XG5cdFx0dGhpcy5rZXlMZW5ndGggPSBudWxsO1xuXHRcdHRoaXMubW9kZSA9IG51bGw7XG5cdFx0dGhpcy5rZXkgPSBudWxsO1xuXHR9XG5cdENyeXB0by5DaXBoZXJQYXJhbXMgPSBDaXBoZXJQYXJhbXM7XG5cblx0LyoqXG5cdCAqIE9idGFpbiBhIGNvbXBsZXRlIENpcGhlclBhcmFtcyBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBwYXJhbXMsIGZpbGxpbmdcblx0ICogaW4gYW55IG5vdCBwcm92aWRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLCBjYWxjdWxhdGluZyBhIGtleUxlbmd0aCBmcm9tXG5cdCAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXG5cdCAqIEBwYXJhbSBwYXJhbXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXQgYSBtaW5pbXVtIGEgYGtleWAga2V5IHdpdGggdmFsdWUgdGhlXG5cdCAqIGtleSwgYXMgZWl0aGVyIGEgYmluYXJ5IChBcnJheUJ1ZmZlciwgQXJyYXksIFdvcmRBcnJheSkgb3IgYVxuXHQgKiBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0b1xuXHQgKiBBRVMpLCBtb2RlIChkZWZhdWx0cyB0byAnY2JjJylcblx0ICovXG5cdENyeXB0by5nZXREZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIGtleTtcblx0XHQvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5ICovXG5cdFx0aWYoKHR5cGVvZihwYXJhbXMpID09PSAnZnVuY3Rpb24nKSB8fCAodHlwZW9mKHBhcmFtcykgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZXByZWNhdGVkKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhrZXksIGNhbGxiYWNrKScsICdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBrZXl9KScpO1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Q3J5cHRvLmdlbmVyYXRlUmFuZG9tS2V5KGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdHBhcmFtcyhudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBrZXl9KSk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9IGVsc2UgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRhcmd1bWVudHNbMV0obnVsbCwgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoe2tleTogcGFyYW1zfSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZighcGFyYW1zLmtleSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWQnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mKHBhcmFtcy5rZXkpID09PSAnc3RyaW5nJykge1xuXHRcdFx0a2V5ID0gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkobm9ybWFsaXNlQmFzZTY0KHBhcmFtcy5rZXkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShwYXJhbXMua2V5KTsgLy8gRXhwZWN0IGtleSB0byBiZSBhbiBBcnJheSwgQXJyYXlCdWZmZXIsIG9yIFdvcmRBcnJheSBhdCB0aGlzIHBvaW50XG5cdFx0fVxuXG5cdFx0dmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoKTtcblx0XHRjaXBoZXJQYXJhbXMua2V5ID0ga2V5O1xuXHRcdGNpcGhlclBhcmFtcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtIHx8IERFRkFVTFRfQUxHT1JJVEhNO1xuXHRcdGNpcGhlclBhcmFtcy5rZXlMZW5ndGggPSBrZXkud29yZHMubGVuZ3RoICogKDQgKiA4KTtcblx0XHRjaXBoZXJQYXJhbXMubW9kZSA9IHBhcmFtcy5tb2RlIHx8IERFRkFVTFRfTU9ERTtcblxuXHRcdGlmKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgJyArIHBhcmFtcy5rZXlMZW5ndGggKyAnIHdhcyBzcGVjaWZpZWQsIGJ1dCB0aGUga2V5IGFjdHVhbGx5IGhhcyBsZW5ndGggJyArIGNpcGhlclBhcmFtcy5rZXlMZW5ndGgpO1xuXHRcdH1cblxuXHRcdHZhbGlkYXRlQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcyk7XG5cdFx0cmV0dXJuIGNpcGhlclBhcmFtcztcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYSByYW5kb20gZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgc3VwcGxpZWQga2V5bGVuZ3RoIChvciB0aGVcblx0ICogZGVmYXVsdCBrZXlMZW5ndGggaWYgbm9uZSBzdXBwbGllZCkgYXMgYSBDcnlwdG9KUyBXb3JkQXJyYXlcblx0ICogQHBhcmFtIGtleUxlbmd0aCAob3B0aW9uYWwpIHRoZSByZXF1aXJlZCBrZXlMZW5ndGggaW4gYml0c1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwga2V5KVxuXHQgKi9cblx0Q3J5cHRvLmdlbmVyYXRlUmFuZG9tS2V5ID0gZnVuY3Rpb24oa2V5TGVuZ3RoLCBjYWxsYmFjaykge1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2Yoa2V5TGVuZ3RoKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYWxsYmFjayA9IGtleUxlbmd0aDtcblx0XHRcdGtleUxlbmd0aCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Z2VuZXJhdGVSYW5kb20oKGtleUxlbmd0aCB8fCBERUZBVUxUX0tFWUxFTkdUSCkgLyA4LCBjYWxsYmFjayk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludGVybmFsOyBnZXQgYSBDaGFubmVsQ2lwaGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBnaXZlbiBjaXBoZXJQYXJhbXNcblx0ICogQHBhcmFtIHBhcmFtcyBlaXRoZXIgYSBDaXBoZXJQYXJhbXMgaW5zdGFuY2Ugb3Igc29tZSBzdWJzZXQgb2YgaXRzXG5cdCAqIGZpZWxkcyB0aGF0IGluY2x1ZGVzIGEga2V5XG5cdCAqL1xuXHRDcnlwdG8uZ2V0Q2lwaGVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIGNpcGhlclBhcmFtcyA9IChwYXJhbXMgaW5zdGFuY2VvZiBDaXBoZXJQYXJhbXMpID9cblx0XHQgICAgICAgICAgICAgICAgICAgcGFyYW1zIDpcblx0XHQgICAgICAgICAgICAgICAgICAgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcblxuXHRcdHJldHVybiB7Y2lwaGVyUGFyYW1zOiBjaXBoZXJQYXJhbXMsIGNpcGhlcjogbmV3IENCQ0NpcGhlcihjaXBoZXJQYXJhbXMsIERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMsIHBhcmFtcy5pdil9O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIENCQ0NpcGhlcihwYXJhbXMsIGJsb2NrTGVuZ3RoV29yZHMsIGl2KSB7XG5cdFx0dGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgJy0nICsgU3RyaW5nKHBhcmFtcy5rZXlMZW5ndGgpICsgJy0nICsgcGFyYW1zLm1vZGU7XG5cdFx0dGhpcy5janNBbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLVxcZCskLywgJycpO1xuXHRcdHRoaXMua2V5ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShwYXJhbXMua2V5KTtcblx0XHRpZihpdikge1xuXHRcdFx0dGhpcy5pdiA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkoaXYpLmNsb25lKCk7XG5cdFx0fVxuXHRcdHRoaXMuYmxvY2tMZW5ndGhXb3JkcyA9IGJsb2NrTGVuZ3RoV29yZHM7XG5cdH1cblxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQsIGNhbGxiYWNrKSB7XG5cdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDQkNDaXBoZXIuZW5jcnlwdCgpJywgJycpO1xuXHRcdHBsYWludGV4dCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkocGxhaW50ZXh0KTtcblx0XHR2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0LnNpZ0J5dGVzLFxuXHRcdFx0cGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCksXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdHZhciB0aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmdldEl2KGZ1bmN0aW9uKGVyciwgaXYpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjaXBoZXJPdXQgPSBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhwbGFpbnRleHQuY29uY2F0KHBrY3M1UGFkZGluZ1twYWRkZWRMZW5ndGggLSBwbGFpbnRleHRMZW5ndGhdKSk7XG5cdFx0XHRcdHZhciBjaXBoZXJ0ZXh0ID0gaXYuY29uY2F0KGNpcGhlck91dCk7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIGNpcGhlcnRleHQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5lbmNyeXB0Q2lwaGVyKSB7XG5cdFx0XHRpZih0aGlzLml2KSB7XG5cdFx0XHRcdHRoaXMuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3IodGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG5cdFx0XHRcdHRoZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uKGVyciwgaXYpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmVuY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1tzZWxmLmNqc0FsZ29yaXRobV0uY3JlYXRlRW5jcnlwdG9yKHNlbGYua2V5LCB7IGl2OiBpdiB9KTtcblx0XHRcdFx0XHRzZWxmLml2ID0gaXY7XG5cdFx0XHRcdFx0dGhlbigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhlbigpO1xuXHRcdH1cblx0fTtcblxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDQkNDaXBoZXIuZGVjcnlwdCgpJywgJycpO1xuXHRcdGNpcGhlcnRleHQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KGNpcGhlcnRleHQpO1xuXHRcdHZhciBibG9ja0xlbmd0aFdvcmRzID0gdGhpcy5ibG9ja0xlbmd0aFdvcmRzLFxuXHRcdFx0Y2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3Jkcyxcblx0XHRcdGl2ID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDAsIGJsb2NrTGVuZ3RoV29yZHMpKSxcblx0XHRcdGNpcGhlcnRleHRCb2R5ID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKGJsb2NrTGVuZ3RoV29yZHMpKTtcblxuXHRcdHZhciBkZWNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZURlY3J5cHRvcih0aGlzLmtleSwgeyBpdjogaXYgfSk7XG5cdFx0dmFyIHBsYWludGV4dCA9IGRlY3J5cHRDaXBoZXIucHJvY2VzcyhjaXBoZXJ0ZXh0Qm9keSk7XG5cdFx0dmFyIGVwaWxvZ3VlID0gZGVjcnlwdENpcGhlci5maW5hbGl6ZSgpO1xuXHRcdGRlY3J5cHRDaXBoZXIucmVzZXQoKTtcblx0XHRpZihlcGlsb2d1ZSAmJiBlcGlsb2d1ZS5zaWdCeXRlcykgcGxhaW50ZXh0LmNvbmNhdChlcGlsb2d1ZSk7XG5cdFx0cmV0dXJuIHBsYWludGV4dDtcblx0fTtcblxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmdldEl2ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLml2KSB7XG5cdFx0XHR2YXIgaXYgPSB0aGlzLml2O1xuXHRcdFx0dGhpcy5pdiA9IG51bGw7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBpdik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogU2luY2UgdGhlIGl2IGZvciBhIG5ldyBibG9jayBpcyB0aGUgY2lwaGVydGV4dCBvZiB0aGUgbGFzdCwgdGhpc1xuXHRcdCogc2V0cyBhIG5ldyBpdiAoPSBhZXMocmFuZG9tQmxvY2sgWE9SIGxhc3RDaXBoZXJUZXh0KSkgYXMgd2VsbCBhc1xuXHRcdCogcmV0dXJuaW5nIGl0ICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uKGVyciwgcmFuZG9tQmxvY2spIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBcblx0XHRcdGNhbGxiYWNrKG51bGwsIHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHJhbmRvbUJsb2NrKSk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIENyeXB0bztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ3J5cHRvKTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cblxudmFyIFRyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uO1xuXHR2YXIgY2xvc2VNZXNzYWdlID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5DTE9TRX0pO1xuXHR2YXIgZGlzY29ubmVjdE1lc3NhZ2UgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1R9KTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qXG5cdCAqIEV2ZW50RW1pdHRlciwgZ2VuZXJhdGVzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuXHQgKlxuXHQgKiBldmVudCBuYW1lICAgICAgIGRhdGFcblx0ICogY2xvc2VkICAgICAgICAgICBlcnJvclxuXHQgKiBmYWlsZWQgICAgICAgICAgIGVycm9yXG5cdCAqIGRpc3Bvc2VkXG5cdCAqIGNvbm5lY3RlZCAgICAgICAgbnVsbCBlcnJvciwgY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlsc1xuXHQgKiBzeW5jICAgICAgICAgICAgIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZFxuXHQgKiBldmVudCAgICAgICAgICAgIGNoYW5uZWwgbWVzc2FnZSBvYmplY3Rcblx0ICovXG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydCh0aGlzKTtcblx0XHR0aGlzLmF1dGggPSBhdXRoO1xuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXHRcdHRoaXMudGltZW91dHMgPSBwYXJhbXMub3B0aW9ucy50aW1lb3V0cztcblx0XHR0aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcblx0XHR0aGlzLmlkbGVUaW1lciA9IG51bGw7XG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoVHJhbnNwb3J0LCBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0Q2xvc2UoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2Nsb3NlZCcsIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2xvc2VkKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihlcnIpIHtcblx0XHQvKiBVc2VkIGZvciBuZXR3b3JrL3RyYW5zcG9ydCBpc3N1ZXMgdGhhdCBuZWVkIHRvIHJlc3VsdCBpbiB0aGUgdHJhbnNwb3J0XG5cdFx0ICogYmVpbmcgZGlzY29ubmVjdGVkLCBidXQgc2hvdWxkIG5vdCBhZmZlY3QgdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG5cdFx0fVxuXHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIgfHwgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kaXNjb25uZWN0ZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdC8qIFVzZWQgZm9yIGNsaWVudC1zaWRlLWRldGVjdGVkIGZhdGFsIGNvbm5lY3Rpb24gaXNzdWVzICovXG5cdFx0aWYodGhpcy5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuXHRcdH1cblx0XHR0aGlzLmZpbmlzaCgnZmFpbGVkJywgZXJyIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZmFpbGVkKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGV2ZW50LCBlcnIpIHtcblx0XHRpZih0aGlzLmlzRmluaXNoZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcblx0XHR0aGlzLmlkbGVUaW1lciA9IG51bGw7XG5cdFx0dGhpcy5lbWl0KGV2ZW50LCBlcnIpO1xuXHRcdHRoaXMuZGlzcG9zZSgpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25Qcm90b2NvbE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0aWYgKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNob3VsZExvZyhfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAncmVjZWl2ZWQgb24gJyArIHRoaXMuc2hvcnROYW1lICsgJzogJyArIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdpZnkobWVzc2FnZSkgKyAnOyBjb25uZWN0aW9uSWQgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQpO1xuXHRcdH1cblx0XHR0aGlzLm9uQWN0aXZpdHkoKTtcblxuXHRcdHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xuXHRcdGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCB0aGlzLnNob3J0TmFtZSArICcgaGVhcnRiZWF0OyBjb25uZWN0aW9uSWQgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQpO1xuXHRcdFx0dGhpcy5lbWl0KCdoZWFydGJlYXQnLCBtZXNzYWdlLmlkKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5DT05ORUNURUQ6XG5cdFx0XHR0aGlzLm9uQ29ubmVjdChtZXNzYWdlKTtcblx0XHRcdHRoaXMuZW1pdCgnY29ubmVjdGVkJywgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkNMT1NFRDpcblx0XHRcdHRoaXMub25DbG9zZShtZXNzYWdlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5ESVNDT05ORUNURUQ6XG5cdFx0XHR0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5BQ0s6XG5cdFx0XHR0aGlzLmVtaXQoJ2FjaycsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5OQUNLOlxuXHRcdFx0dGhpcy5lbWl0KCduYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQsIG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLlNZTkM6XG5cdFx0XHRpZihtZXNzYWdlLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8qIGEgdHJhbnNwb3J0IFNZTkMgKi9cblx0XHRcdFx0dGhpcy5lbWl0KCdzeW5jJywgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8qIG90aGVyd2lzZSBpdCdzIGEgY2hhbm5lbCBTWU5DLCBzbyBoYW5kbGUgaXQgaW4gdGhlIGNoYW5uZWwgKi9cblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5BVVRIOlxuXHRcdFx0dGhpcy5hdXRoLmF1dGhvcml6ZShmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ0FibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5FUlJPUjpcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBlcnJvciBhY3Rpb247IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCArICc7IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QobWVzc2FnZS5lcnJvcikgKyAobWVzc2FnZS5jaGFubmVsID8gKCcsIGNoYW5uZWw6ICcgKyAgbWVzc2FnZS5jaGFubmVsKSA6ICcnKSk7XG5cdFx0XHRpZihtZXNzYWdlLmNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdC8qIGFsbCBvdGhlciBhY3Rpb25zIGFyZSBjaGFubmVsLXNwZWNpZmljICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuXHRcdHZhciBtYXhQcm9taXNlZElkbGUgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcblx0XHRpZihtYXhQcm9taXNlZElkbGUpIHtcblx0XHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuXHRcdFx0dGhpcy5vbkFjdGl2aXR5KCk7XG5cdFx0fVxuXHRcdC8qIGVsc2UgUmVhbHRpbWUgZGVjbGluZXMgdG8gZ3VhcmFudGVlIGFueSBtYXhpbXVtIGlkbGUgaW50ZXJ2YWwgLSBDRDJoICovXG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRpc2Nvbm5lY3QgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0LyogVXNlZCBmb3Igd2hlbiB0aGUgc2VydmVyIGhhcyBkaXNjb25uZWN0ZWQgdGhlIGNsaWVudCAodXN1YWxseSB3aXRoIGFcblx0XHQgKiBESVNDT05ORUNURUQgYWN0aW9uKSAqL1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkRpc2Nvbm5lY3QoKScsICdlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkZhdGFsRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0LyogT24gcmVjZWlwdCBvZiBhIGZhdGFsIGNvbm5lY3Rpb24gZXJyb3IsIHdlIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2VydmVyXG5cdFx0ICogd2lsbCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhbmQgdGhlIHRyYW5zcG9ydCwgYW5kIGRvIG5vdCBuZWVkIHRvIHJlcXVlc3Rcblx0XHQgKiBhIGRpc2Nvbm5lY3Rpb24gLSBSVE4xNWkgKi9cblx0XHR2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25GYXRhbEVycm9yKCknLCAnZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25DbG9zZSgpJywgJ2VyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHR0aGlzLmZpbmlzaCgnY2xvc2VkJywgZXJyKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5zZW5kKGNsb3NlTWVzc2FnZSk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScsICcnKTtcblx0XHR0aGlzLnNlbmQoZGlzY29ubmVjdE1lc3NhZ2UpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIG1zZyA9IHthY3Rpb246IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb24uSEVBUlRCRUFUfTtcblx0XHRpZihpZCkgbXNnLmlkID0gaWQ7XG5cdFx0dGhpcy5zZW5kKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1zZykpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG5cdFx0dGhpcy5vZmYoKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQWN0aXZpdHkgPSBmdW5jdGlvbigpIHtcblx0XHRpZighdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmxhc3RBY3Rpdml0eSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCk7XG5cdFx0dGhpcy5zZXRJZGxlVGltZXIodGhpcy5tYXhJZGxlSW50ZXJ2YWwgKyAxMDApO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuc2V0SWRsZVRpbWVyID0gZnVuY3Rpb24odGltZW91dCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZighdGhpcy5pZGxlVGltZXIpIHtcblx0XHRcdHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5vbklkbGVUaW1lckV4cGlyZSgpO1xuXHRcdFx0fSwgdGltZW91dCk7XG5cdFx0fVxuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25JZGxlVGltZXJFeHBpcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlkbGVUaW1lciA9IG51bGw7XG5cdFx0dmFyIHNpbmNlTGFzdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eSxcblx0XHRcdHRpbWVSZW1haW5pbmcgPSB0aGlzLm1heElkbGVJbnRlcnZhbCAtIHNpbmNlTGFzdDtcblx0XHRpZih0aW1lUmVtYWluaW5nIDw9IDApIHtcblx0XHRcdHZhciBtc2cgPSAnTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluICcgKyBzaW5jZUxhc3QgKyAnbXM7IGFzc3VtaW5nIGNvbm5lY3Rpb24gaGFzIGRyb3BwZWQnO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpJywgbXNnKTtcblx0XHRcdHRoaXMuZGlzY29ubmVjdChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgODAwMDMsIDQwOCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldElkbGVUaW1lcih0aW1lUmVtYWluaW5nICsgMTAwKTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24oKSB7fTtcblxuXHRyZXR1cm4gVHJhbnNwb3J0O1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChUcmFuc3BvcnQpO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDb25uZWN0aW9uU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xuXHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHR0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuXHRcdGlmKHJldHJ5SW4pIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XG5cdFx0aWYocmVhc29uKSB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcblx0fVxuXG5cdHJldHVybiBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbm5lY3Rpb25TdGF0ZUNoYW5nZSk7XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbnZhciBNdWx0aWNhc3RlciA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBNdWx0aWNhc3RlcihtZW1iZXJzKSB7XG5cdFx0bWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG5cblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIG1lbWJlciA9IG1lbWJlcnNbaV07XG5cdFx0XHRcdGlmKG1lbWJlcikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9IGNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnTXVsdGljYXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2sgaGFuZGxlcicsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyBlLnN0YWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aGFuZGxlci5wdXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShtZW1iZXJzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGhhbmRsZXI7XG5cdH1cblxuXHRyZXR1cm4gTXVsdGljYXN0ZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE11bHRpY2FzdGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblxuXG5cblxuXG52YXIgRXJyb3JSZXBvcnRlciA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gRXJyb3JSZXBvcnRlcigpIHt9XG5cblx0dmFyIGxldmVscyA9IEVycm9yUmVwb3J0ZXIubGV2ZWxzID0gW1xuXHRcdCdmYXRhbCcsXG5cdFx0J2Vycm9yJyxcblx0XHQnd2FybmluZycsXG5cdFx0J2luZm8nLFxuXHRcdCdkZWJ1Zydcblx0XTtcblxuXHQvKiAobGV2ZWw6IHR5cGVvZiBFcnJvclJlcG9ydGVyLmxldmVsc1tudW1iZXJdLCBtZXNzYWdlOiBzdHJpbmcsIGZpbmdlcnByaW50Pzogc3RyaW5nLCB0YWdzPzoge1trZXk6IHN0cmluZ106IHN0cmluZ30pOiB2b2lkICovXG5cdEVycm9yUmVwb3J0ZXIucmVwb3J0ID0gZnVuY3Rpb24obGV2ZWwsIG1lc3NhZ2UsIGZpbmdlcnByaW50LCB0YWdzKSB7XG5cdFx0dmFyIGV2ZW50SWQgPSBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yYW5kb21IZXhTdHJpbmcoMTYpO1xuXG5cdFx0dmFyIGV2ZW50ID0ge1xuXHRcdFx0ZXZlbnRfaWQ6IGV2ZW50SWQsXG5cdFx0XHR0YWdzOiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbih7XG5cdFx0XHRcdGFibHlBZ2VudDogX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudFxuXHRcdFx0fSwgdGFncyksXG5cdFx0XHRwbGF0Zm9ybTogJ2phdmFzY3JpcHQnLFxuXHRcdFx0bGV2ZWw6IGxldmVsLFxuXHRcdFx0cmVsZWFzZTogX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS52ZXJzaW9uLFxuXHRcdFx0ZmluZ2VycHJpbnQ6IGZpbmdlcnByaW50ICYmIFsgZmluZ2VycHJpbnQgXSxcblx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRyZXF1ZXN0OiB7XG5cdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHQnVXNlci1BZ2VudCc6IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXNlckFnZW50XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVybDogcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jdXJyZW50VXJsXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Vycm9yUmVwb3J0ZXInLCAnUE9TVGluZyB0byBlcnJvciByZXBvcnRlcjogJyArIG1lc3NhZ2UpO1xuXHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wb3N0VXJpKG51bGwsIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXJyb3JSZXBvcnRpbmdVcmwsIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXJyb3JSZXBvcnRpbmdIZWFkZXJzLCBKU09OLnN0cmluZ2lmeShldmVudCksIHt9LCBmdW5jdGlvbihlcnIsIHJlcykge1xuXHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnRXJyb3JSZXBvcnRlcicsICdQT1NUaW5nIHRvIGVycm9yIHJlcG9ydGVyIHJlc3VsdGVkIGluOiAnICtcblx0XHRcdFx0KGVyciA/IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpIDogX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEJvZHkocmVzKSlcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIEVycm9yUmVwb3J0ZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9yUmVwb3J0ZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbXNncGFjayA9IChmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGV4cG9ydHMgPSB7fTtcblxuXHRleHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXHRmdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuXHRcdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBcInVuZGVmaW5lZFwiO1xuXHRcdHZhciB2aWV3O1xuXHRcdHZhciB0eXBlO1xuXHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdHR5cGUgPSBcIkFycmF5QnVmZmVyXCI7XG5cdFx0XHR2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0fSBlbHNlIGlmICggYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcblx0XHRcdHR5cGUgPSBcIkRhdGFWaWV3XCI7XG5cdFx0XHR2aWV3ID0gYnVmZmVyO1xuXHRcdH1cblx0XHRpZiAoIXZpZXcpXG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYnVmZmVyKTtcblx0XHR2YXIgYnl0ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpID4gMjApIHtcblx0XHRcdFx0Ynl0ZXMucHVzaChcIi4uLlwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpLnRvU3RyaW5nKDE2KTtcblx0XHRcdGlmIChieXRlXy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdGJ5dGVfID0gXCIwXCIgKyBieXRlXztcblx0XHRcdGJ5dGVzLnB1c2goYnl0ZV8pO1xuXHRcdH1cblx0XHRyZXR1cm4gXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBieXRlcy5qb2luKFwiIFwiKSArIFwiPlwiO1xuXHR9XG5cblx0Ly8gRW5jb2RlIHN0cmluZyBhcyB1dGY4IGludG8gZGF0YXZpZXcgYXQgb2Zmc2V0XG5cdGV4cG9ydHMudXRmOFdyaXRlID0gdXRmOFdyaXRlO1xuXHRmdW5jdGlvbiB1dGY4V3JpdGUodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcblx0XHR2YXIgYnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuXHRcdFx0Ly8gT25lIGJ5dGUgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4N2YgfCAweDAwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR3byBieXRlcyBvZiBVVEYtOFxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDB4MWYgfCAweGMwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhyZWUgYnl0ZXMgb2YgVVRGLTguXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDEyICYgMHgwZiB8IDB4ZTApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvdXIgYnl0ZXMgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDE4ICYgMHgwNyB8IDB4ZjApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDEyICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcblx0XHR9XG5cdH1cblxuXG5cdGV4cG9ydHMudXRmOFJlYWQgPSB1dGY4UmVhZDtcblx0ZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0XHR2YXIgc3RyaW5nID0gXCJcIjtcblx0XHRmb3IgKHZhciBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKTtcblx0XHRcdC8vIE9uZSBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ODApID09PSAweDAwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVfKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBUd28gYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweGUwKSA9PT0gMHhjMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgNikgfCAodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIFRocmVlIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhmMCkgPT09IDB4ZTApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDEyKSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBGb3VyIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhmOCkgPT09IDB4ZjApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MDcpIDw8IDE4KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBcIiArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXG5cdGV4cG9ydHMudXRmOEJ5dGVDb3VudCA9IHV0ZjhCeXRlQ291bnQ7XG5cdGZ1bmN0aW9uIHV0ZjhCeXRlQ291bnQoc3RyaW5nKSB7XG5cdFx0dmFyIGNvdW50ID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDE7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcblx0XHRcdFx0Y291bnQgKz0gMztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcblx0XHRcdFx0Y291bnQgKz0gNDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblxuXHRleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcblx0XHR2YXIgc2l6ZSA9IHNpemVvZih2YWx1ZSwgc3BhcnNlKTtcblx0XHRpZihzaXplID09IDApXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG5cdFx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblx0XHRlbmNvZGUodmFsdWUsIHZpZXcsIDAsIHNwYXJzZSk7XG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblx0fTtcblxuXHRleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblxuXHR2YXIgU0hfTF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSwgU0hfUl8zMiA9IDEgLyBTSF9MXzMyO1xuXHRmdW5jdGlvbiBnZXRJbnQ2NCh2aWV3LCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRyZXR1cm4gdmlldy5nZXRJbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VWludDY0KHZpZXcsIG9mZnNldCkge1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcblx0XHRpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG5cdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCAweDdmZmZmZmZmKTtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4N2ZmZmZmZmYpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuXHRcdGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHhmZmZmZmZmZik7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweGZmZmZmZmZmKTtcblx0XHR9XG5cdH1cblxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZnJzeXVraS81NDMyNTU5IC0gdjUgc3BlY1xuLy9cbi8vIEkndmUgdXNlZCBvbmUgZXh0ZW5zaW9uIHBvaW50IGZyb20gYGZpeGV4dCAxYCB0byBzdG9yZSBgdW5kZWZpbmVkYC4gT24gdGhlIHdpcmUgdGhpc1xuLy8gc2hvdWxkIHRyYW5zbGF0ZSB0byBleGFjdGx5IDB4ZDQwMDAwXG4vL1xuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gfCAgMHhkNCAgfCAgMHgwMCAgfCAgMHgwMCAgfFxuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gICAgXiBmaXhleHQgfCAgICAgICAgXiB2YWx1ZSBwYXJ0IHVudXNlZCAoZml4ZWQgdG8gYmUgMClcbi8vICAgICAgICAgICAgIF4gaW5kaWNhdGVzIHVuZGVmaW5lZCB2YWx1ZVxuLy9cblxuXHRmdW5jdGlvbiBEZWNvZGVyKHZpZXcsIG9mZnNldCkge1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0dGhpcy52aWV3ID0gdmlldztcblx0fVxuXG5cblx0RGVjb2Rlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRoaXMucGFyc2UoKTtcblx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLnBhcnNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5iaW4gPSBEZWNvZGVyLnByb3RvdHlwZS5idWYgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcblx0XHQobmV3IFVpbnQ4QXJyYXkodmFsdWUpKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5leHQgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB7fTtcblx0XHQvLyBHZXQgdGhlIHR5cGUgYnl0ZVxuXHRcdHZhbHVlWyd0eXBlJ10gPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG5cdFx0dGhpcy5vZmZzZXQrKztcblx0XHQvLyBHZXQgdGhlIGRhdGEgYXJyYXkgKGxlbmd0aClcblx0XHR2YWx1ZVsnZGF0YSddID0gdGhpcy5idWYobGVuZ3RoKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuXHRcdHZhciB2YWx1ZSwgbGVuZ3RoO1xuXG5cdFx0Ly8gUG9zaXRpdmUgRml4SW50IC0gMHh4eHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweDgwKSA9PT0gMHgwMCkge1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH1cblxuXHRcdC8vIEZpeE1hcCAtIDEwMDB4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhmMCkgPT09IDB4ODApIHtcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIEZpeEFycmF5IC0gMTAwMXh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg5MCkge1xuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MGY7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBGaXhTdHIgLSAxMDF4eHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZTApID09PSAweGEwKSB7XG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgxZjtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBOZWdhdGl2ZSBGaXhJbnQgLSAxMTF4eHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZTApID09PSAweGUwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cblx0XHRcdC8vIG5pbFxuXHRcdFx0Y2FzZSAweGMwOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0Ly8gMHhjMSBuZXZlciB1c2VkIC0gdXNlIGZvciB1bmRlZmluZWQgKE5PTi1TVEFOREFSRClcblx0XHRcdGNhc2UgMHhjMTpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gZmFsc2Vcblx0XHRcdGNhc2UgMHhjMjpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyB0cnVlXG5cdFx0XHRjYXNlIDB4YzM6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBiaW4gOFxuXHRcdFx0Y2FzZSAweGM0OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG5cblx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0Y2FzZSAweGM1OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG5cdFx0XHQvLyBiaW4gMzJcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDhcblx0XHRcdGNhc2UgMHhjNzpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBleHQgMTZcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRjYXNlIDB4Yzk6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZsb2F0IDMyXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBmbG9hdCA2NFxuXHRcdFx0Y2FzZSAweGNiOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludDhcblx0XHRcdGNhc2UgMHhjYzpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50IDE2XG5cdFx0XHRjYXNlIDB4Y2Q6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQgMzJcblx0XHRcdGNhc2UgMHhjZTpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludCA2NFxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHR2YWx1ZSA9IGdldFVpbnQ2NCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gaW50IDhcblx0XHRcdGNhc2UgMHhkMDpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCAxNlxuXHRcdFx0Y2FzZSAweGQxOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCAzMlxuXHRcdFx0Y2FzZSAweGQyOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCA2NFxuXHRcdFx0Y2FzZSAweGQzOlxuXHRcdFx0XHR2YWx1ZSA9IGdldEludDY0KHRoaXMudmlldywgdGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gOTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBmaXhleHQgMVxuXHRcdFx0Y2FzZSAweGQ0OlxuXHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDJcblx0XHRcdGNhc2UgMHhkNTpcblx0XHRcdFx0bGVuZ3RoID0gMjtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCA0XG5cdFx0XHRjYXNlIDB4ZDY6XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHRsZW5ndGggPSA4O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDE2XG5cdFx0XHRjYXNlIDB4ZDg6XG5cdFx0XHRcdGxlbmd0aCA9IDE2O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gc3RyOFxuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdGNhc2UgMHhkYzpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuXG5cdFx0XHQvLyBhcnJheSAzMlxuXHRcdFx0Y2FzZSAweGRkOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG5cblx0XHRcdC8vIG1hcCAxNlxuXHRcdFx0Y2FzZSAweGRlOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuXG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdGNhc2UgMHhkZjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuXHRcdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0dmFyIGRlY29kZXIgPSBuZXcgRGVjb2Rlcih2aWV3KTtcblx0XHR2YXIgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG5cdFx0aWYgKGRlY29kZXIub2Zmc2V0ICE9PSBidWZmZXIuYnl0ZUxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcigoYnVmZmVyLmJ5dGVMZW5ndGggLSBkZWNvZGVyLm9mZnNldCkgKyBcIiB0cmFpbGluZyBieXRlc1wiKTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIGtleXMgPSBbXTsgLy8gVE9ETzogdXNlIE9iamVjdC5rZXlzIHdoZW4gd2UgYXJlIGFibGUgdG8gdHJhbnNwaWxlIHRvIEVTM1xuXHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZih2YWwpO1xuXHRcdFx0cmV0dXJuICghc3BhcnNlIHx8ICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpKSAmJiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZSB8fCAhIXZhbC50b0pTT04pO1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGUodmFsdWUsIHZpZXcsIG9mZnNldCwgc3BhcnNlKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHQvLyBTdHJpbmdzIEJ5dGVzXG5cdFx0Ly8gVGhlcmUgYXJlIGZvdXIgc3RyaW5nIHR5cGVzOiBmaXhzdHIvc3RyOC9zdHIxNi9zdHIzMlxuXHRcdGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG5cblx0XHRcdC8vIGZpeHN0clxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8IDB4YTApO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMSArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RyOFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ5KTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RyMTZcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRhKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdHIzMlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRiKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDUsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcblx0XHRcdC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5idWZmZXI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlcmUgYXJlIHRocmVlIGJpbiB0eXBlczogYmluOC9iaW4xNi9iaW4zMlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuXHRcdFx0Ly8gYmluOFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM0KTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHQobmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAyKTtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJpbjE2XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzYpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHQobmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcblxuXHRcdFx0Ly8gRmxvYXRpbmcgUG9pbnRcblx0XHRcdC8vIE5PVEU6IFdlJ3JlIGFsd2F5cyB1c2luZyBmbG9hdDY0XG5cdFx0XHRpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNiKTtcblx0XHRcdFx0dmlldy5zZXRGbG9hdDY0KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludGVnZXJzXG5cdFx0XHRpZiAodmFsdWUgPj0gMCkge1xuXHRcdFx0XHQvLyBwb3NpdGl2ZSBmaXhudW1cblx0XHRcdFx0aWYgKHZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCA4XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2MpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVpbnQgMTZcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNkKTtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCAzMlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNlKTtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCA2NFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2YpO1xuXHRcdFx0XHRcdHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5lZ2F0aXZlIGZpeG51bVxuXHRcdFx0aWYgKHZhbHVlID49IC0weDIwKSB7XG5cdFx0XHRcdHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgOFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQwKTtcblx0XHRcdFx0dmlldy5zZXRJbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgMTZcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQxKTtcblx0XHRcdFx0dmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW50IDMyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDIpO1xuXHRcdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQzKTtcblx0XHRcdFx0c2V0SW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyAoLXZhbHVlKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcblx0XHR9XG5cblx0XHQvLyB1bmRlZmluZWQgLSB1c2UgZDQgKE5PTi1TVEFOREFSRClcblx0XHRpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0aWYoc3BhcnNlKSByZXR1cm4gMDtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ0KTtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgMHgwMCk7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDB4MDApO1xuXHRcdFx0cmV0dXJuIDM7XG5cdFx0fVxuXG5cdFx0Ly8gbnVsbFxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0aWYoc3BhcnNlKSByZXR1cm4gMDtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGMwKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdC8vIEJvb2xlYW5cblx0XHRpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSA/IDB4YzMgOiAweGMyKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG5cdFx0XHRyZXR1cm4gZW5jb2RlKHZhbHVlLnRvSlNPTigpLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSk7XG5cblx0XHQvLyBDb250YWluZXIgVHlwZXNcblx0XHRpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0dmFyIGxlbmd0aCwgc2l6ZSA9IDA7XG5cdFx0XHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG5cdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNpemU7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgKCBpc0FycmF5ID8gMHg5MCA6IDB4ODApKTtcblx0XHRcdFx0c2l6ZSA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRjIDogMHhkZSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHNpemUgPSAzO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGQgOiAweGRmKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0c2l6ZSA9IDU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZSh2YWx1ZVtpXSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XG5cdFx0XHRcdFx0c2l6ZSArPSBlbmNvZGUodmFsdWVba2V5XSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cdFx0aWYodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHQvLyBmaXhzdHIgb3Igc3RyOCBvciBzdHIxNiBvciBzdHIzMlxuXHRcdGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRyZXR1cm4gMSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG5cdFx0XHQvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcblx0XHRcdHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuXHRcdH1cblxuXHRcdC8vIGJpbjggb3IgYmluMTYgb3IgYmluMzJcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0Ly8gRmxvYXRpbmcgUG9pbnQgKDMyIGJpdHMpXG5cdFx0XHQvLyBkb3VibGVcblx0XHRcdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG5cdFx0XHRcdHJldHVybiA5O1xuXG5cdFx0XHQvLyBJbnRlZ2Vyc1xuXHRcdFx0aWYgKHZhbHVlID49IDApIHtcblx0XHRcdFx0Ly8gcG9zaXRpdmUgZml4aW50XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4ODApXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdC8vIHVpbnQgOFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMClcblx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwKVxuXHRcdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKVxuXHRcdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0XHQvLyB1aW50IDY0XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHRcdC8vIFRvbyBiaWdcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZWdhdGl2ZSBmaXhpbnRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHgyMClcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHQvLyBpbnQgOFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwKVxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIGludCAxNlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDApXG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0Ly8gaW50IDMyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApXG5cdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0Ly8gaW50IDY0XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMClcblx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHQvLyBUb28gc21hbGxcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcblx0XHR9XG5cblx0XHQvLyBCb29sZWFuXG5cdFx0aWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gMTtcblxuXHRcdC8vIHVuZGVmaW5lZCwgbnVsbFxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHNwYXJzZSA/IDAgOiAxO1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3BhcnNlID8gMCA6IDM7XG5cblx0XHRpZignZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuXHRcdFx0cmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcblxuXHRcdC8vIENvbnRhaW5lciBUeXBlc1xuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCBzaXplID0gMDtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzaXplICs9IHNpemVvZih2YWx1ZVtpXSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKVxuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHNpemUgKz0gc2l6ZW9mKGtleSkgKyBzaXplb2YodmFsdWVba2V5XSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0cmV0dXJuIDEgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDMgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgc2l6ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFycmF5IG9yIG9iamVjdCB0b28gbG9uZyAweFwiICsgbGVuZ3RoLnRvU3RyaW5nKDE2KSk7XG5cdFx0fVxuXHRcdGlmKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG5cdH1cblxuXHRyZXR1cm4gZXhwb3J0cztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAobXNncGFjayk7XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbXVsdGljYXN0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX3RyYW5zcG9ydHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd2Vic29ja2V0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgaGF2ZVdlYlN0b3JhZ2UgPSAhISh0eXBlb2YocGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgIT09ICd1bmRlZmluZWQnICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0KTtcblx0dmFyIGhhdmVTZXNzaW9uU3RvcmFnZSA9ICEhKHR5cGVvZihwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRTZXNzaW9uKTtcblx0dmFyIGFjdGlvbnMgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uO1xuXHR2YXIgUGVuZGluZ01lc3NhZ2UgPSBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5QZW5kaW5nTWVzc2FnZTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI7XG5cdHZhciBvcHRpbWFsVHJhbnNwb3J0ID0gdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyW3RyYW5zcG9ydFByZWZlcmVuY2VPcmRlci5sZW5ndGggLSAxXTtcblx0dmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xuXG5cdHZhciBzZXNzaW9uUmVjb3ZlcnlOYW1lID0gJ2FibHktY29ubmVjdGlvbi1yZWNvdmVyeSc7XG5cdGZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lKTtcblx0fVxuXHRmdW5jdGlvbiBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lLCB2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG5cdFx0cmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlbW92ZVNlc3Npb24oc2Vzc2lvblJlY292ZXJ5TmFtZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBiZXR0ZXJUcmFuc3BvcnRUaGFuKGEsIGIpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYS5zaG9ydE5hbWUpID5cblx0XHQgICBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBiLnNob3J0TmFtZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBUcmFuc3BvcnRQYXJhbXMob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5ob3N0ID0gaG9zdDtcblx0XHR0aGlzLm1vZGUgPSBtb2RlO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25LZXk7XG5cdFx0dGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nO1xuXG5cdFx0dGhpcy5jb25uZWN0aW9uU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUuZ2V0Q29ubmVjdFBhcmFtcyA9IGZ1bmN0aW9uKGF1dGhQYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1zID0gYXV0aFBhcmFtcyA/IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShhdXRoUGFyYW1zKSA6IHt9O1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHN3aXRjaCh0aGlzLm1vZGUpIHtcblx0XHRcdGNhc2UgJ3VwZ3JhZGUnOlxuXHRcdFx0XHRwYXJhbXMudXBncmFkZSA9IHRoaXMuY29ubmVjdGlvbktleTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyZXN1bWUnOlxuXHRcdFx0XHRwYXJhbXMucmVzdW1lID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuXHRcdFx0XHRpZih0aGlzLnRpbWVTZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xuXHRcdFx0XHR9IGVsc2UgaWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRwYXJhbXMuY29ubmVjdGlvblNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JlY292ZXInOlxuXHRcdFx0XHR2YXIgbWF0Y2ggPSBvcHRpb25zLnJlY292ZXIuc3BsaXQoJzonKTtcblx0XHRcdFx0aWYobWF0Y2gpIHtcblx0XHRcdFx0XHRwYXJhbXMucmVjb3ZlciA9IG1hdGNoWzBdO1xuXHRcdFx0XHRcdHZhciByZWNvdmVyU2VyaWFsID0gbWF0Y2hbMV07XG5cdFx0XHRcdFx0aWYoaXNOYU4ocmVjb3ZlclNlcmlhbCkpIHtcblx0XHRcdFx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gcmVjb3ZlclNlcmlhbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSByZWNvdmVyU2VyaWFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0fVxuXHRcdGlmKG9wdGlvbnMuY2xpZW50SWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcblx0XHR9XG5cdFx0aWYob3B0aW9ucy5lY2hvTWVzc2FnZXMgPT09IGZhbHNlKSB7XG5cdFx0XHRwYXJhbXMuZWNobyA9ICdmYWxzZSc7XG5cdFx0fVxuXHRcdGlmKHRoaXMuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcblx0XHR9XG5cdFx0aWYodGhpcy5zdHJlYW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuXHRcdH1cblx0XHRpZih0aGlzLmhlYXJ0YmVhdHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG5cdFx0fVxuXHRcdHBhcmFtcy52ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcGlWZXJzaW9uO1xuXHRcdHBhcmFtcy5hZ2VudCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWdlbnQ7XG5cdFx0aWYob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihwYXJhbXMsIG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcztcblx0fTtcblxuXHRUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbbW9kZT0nICsgdGhpcy5tb2RlO1xuXHRcdGlmKHRoaXMuaG9zdCkgeyByZXN1bHQgKz0gKCcsaG9zdD0nICsgdGhpcy5ob3N0KTsgfVxuXHRcdGlmKHRoaXMuY29ubmVjdGlvbktleSkgeyByZXN1bHQgKz0gKCcsY29ubmVjdGlvbktleT0nICsgdGhpcy5jb25uZWN0aW9uS2V5KTsgfVxuXHRcdGlmKHRoaXMuY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdCArPSAoJyxjb25uZWN0aW9uU2VyaWFsPScgKyB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpOyB9XG5cdFx0aWYodGhpcy50aW1lU2VyaWFsKSB7IHJlc3VsdCArPSAoJyx0aW1lU2VyaWFsPScgKyB0aGlzLnRpbWVTZXJpYWwpOyB9XG5cdFx0aWYodGhpcy5mb3JtYXQpIHsgcmVzdWx0ICs9ICgnLGZvcm1hdD0nICsgdGhpcy5mb3JtYXQpOyB9XG5cdFx0cmVzdWx0ICs9ICddJztcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25NYW5hZ2VyKHJlYWx0aW1lLCBvcHRpb25zKSB7XG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR2YXIgdGltZW91dHMgPSBvcHRpb25zLnRpbWVvdXRzO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHQvKiBjb25uZWN0aW5nVGltZW91dDogbGVhdmUgcHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICh+NnMpIHRvIHRyeSB0aGVcblx0XHQgKiBwcmVmZXJlbmNlIHRyYW5zcG9ydCwgdGhlbiByZWFsdGltZVJlcXVlc3RUaW1lb3V0ICh+MTBzKSB0byBlc3RhYmxpc2hcblx0XHQgKiB0aGUgYmFzZSB0cmFuc3BvcnQgaW4gY2FzZSB0aGF0IGZhaWxzICovXG5cdFx0dmFyIGNvbm5lY3RpbmdUaW1lb3V0ID0gdGltZW91dHMucHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICsgdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcblx0XHR0aGlzLnN0YXRlcyA9IHtcblx0XHRcdGluaXRpYWxpemVkOiAgIHtzdGF0ZTogJ2luaXRpYWxpemVkJywgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0Y29ubmVjdGluZzogICAge3N0YXRlOiAnY29ubmVjdGluZycsICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogY29ubmVjdGluZ1RpbWVvdXQsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0Y29ubmVjdGVkOiAgICAge3N0YXRlOiAnY29ubmVjdGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiB0cnVlLCAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRzeW5jaHJvbml6aW5nOiB7c3RhdGU6ICdjb25uZWN0ZWQnLCAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCBmb3JjZVF1ZXVlRXZlbnRzOiB0cnVlLCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdGRpc2Nvbm5lY3RlZDogIHtzdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IHRpbWVvdXRzLmRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRzdXNwZW5kZWQ6ICAgICB7c3RhdGU6ICdzdXNwZW5kZWQnLCAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiB0aW1lb3V0cy5zdXNwZW5kZWRSZXRyeVRpbWVvdXQsIGZhaWxTdGF0ZTogJ3N1c3BlbmRlZCd9LFxuXHRcdFx0Y2xvc2luZzogICAgICAge3N0YXRlOiAnY2xvc2luZycsICAgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgZmFpbFN0YXRlOiAnY2xvc2VkJ30sXG5cdFx0XHRjbG9zZWQ6ICAgICAgICB7c3RhdGU6ICdjbG9zZWQnLCAgICAgICAgdGVybWluYWw6IHRydWUsICBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdjbG9zZWQnfSxcblx0XHRcdGZhaWxlZDogICAgICAgIHtzdGF0ZTogJ2ZhaWxlZCcsICAgICAgICB0ZXJtaW5hbDogdHJ1ZSwgIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2ZhaWxlZCd9XG5cdFx0fTtcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMuaW5pdGlhbGl6ZWQ7XG5cdFx0dGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG5cblx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzID0gbmV3IF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgpO1xuXHRcdHRoaXMubXNnU2VyaWFsID0gMDtcblx0XHR0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gdGltZW91dHMuY29ubmVjdGlvblN0YXRlVHRsO1xuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcblxuXHRcdHRoaXMudHJhbnNwb3J0cyA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJzZWN0KChvcHRpb25zLnRyYW5zcG9ydHMgfHwgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWZhdWx0VHJhbnNwb3J0cyksIENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHMpO1xuXHRcdC8qIGJhc2VUcmFuc3BvcnRzIHNlbGVjdHMgdGhlIGxlZnRtb3N0IHRyYW5zcG9ydCBpbiB0aGUgRGVmYXVsdHMuYmFzZVRyYW5zcG9ydE9yZGVyIGxpc3Rcblx0XHQqIHRoYXQncyBib3RoIHJlcXVlc3RlZCBhbmQgc3VwcG9ydGVkLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgeGhyX3BvbGxpbmc7XG5cdFx0KiBpZiB4aHIgaXNuJ3Qgc3VwcG9ydGVkIGl0IHdpbGwgYmUganNvbnAuIElmIHRoZSB1c2VyIGhhcyBmb3JjZWQgYVxuXHRcdCogdHJhbnNwb3J0LCBpdCdsbCBqdXN0IGJlIHRoYXQgb25lLiAqL1xuXHRcdHRoaXMuYmFzZVRyYW5zcG9ydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJzZWN0KF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZVRyYW5zcG9ydE9yZGVyLCB0aGlzLnRyYW5zcG9ydHMpWzBdO1xuXHRcdHRoaXMudXBncmFkZVRyYW5zcG9ydHMgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmludGVyc2VjdCh0aGlzLnRyYW5zcG9ydHMsIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXBncmFkZVRyYW5zcG9ydHMpO1xuXHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG5cblx0XHR0aGlzLmh0dHBIb3N0cyA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0SG9zdHMob3B0aW9ucyk7XG5cdFx0dGhpcy5hY3RpdmVQcm90b2NvbCA9IG51bGw7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcblx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzID0gW107XG5cdFx0dGhpcy5ob3N0ID0gbnVsbDtcblx0XHR0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IG51bGw7XG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuXHRcdHRoaXMubW9zdFJlY2VudE1zZyA9IG51bGw7XG5cdFx0dGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuXHRcdHRoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnc3RhcnRlZCcpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ3JlcXVlc3RlZCB0cmFuc3BvcnRzID0gWycgKyAob3B0aW9ucy50cmFuc3BvcnRzIHx8IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVmYXVsdFRyYW5zcG9ydHMpICsgJ10nKTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdhdmFpbGFibGUgdHJhbnNwb3J0cyA9IFsnICsgdGhpcy50cmFuc3BvcnRzICsgJ10nKTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdodHRwIGhvc3RzID0gWycgKyB0aGlzLmh0dHBIb3N0cyArICddJyk7XG5cblx0XHRpZighdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIG1zZyA9ICdubyByZXF1ZXN0ZWQgdHJhbnNwb3J0cyBhdmFpbGFibGUnO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXG5cdFx0dmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0aWYoYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0LyogaW50ZXJjZXB0IGNsb3NlIGV2ZW50IGluIGJyb3dzZXIgdG8gcGVyc2lzdCBjb25uZWN0aW9uIGlkIGlmIHJlcXVlc3RlZCAqL1xuXHRcdFx0aWYoaGF2ZVNlc3Npb25TdG9yYWdlICYmIHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0LyogVXN1YWxseSBjYW4ndCB1c2UgYmluZCBhcyBub3Qgc3VwcG9ydGVkIGluIElFOCwgYnV0IElFIGRvZXNuJ3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSwgc28uLi4gKi9cblx0XHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5wZXJzaXN0Q29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYob3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUFKT1IsICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2JlZm9yZXVubG9hZCBldmVudCBoYXMgdHJpZ2dlcmVkIHRoZSBjb25uZWN0aW9uIHRvIGNsb3NlIGFzIGNsb3NlT25VbmxvYWQgaXMgdHJ1ZScpO1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nsb3NpbmcnfSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBMaXN0ZW4gZm9yIG9ubGluZSBhbmQgb2ZmbGluZSBldmVudHMgKi9cblx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLnN0YXRlID09IHNlbGYuc3RhdGVzLmRpc2Nvbm5lY3RlZCB8fCBzZWxmLnN0YXRlID09IHNlbGYuc3RhdGVzLnN1c3BlbmRlZCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvbmxpbmXigJkgZXZlbnQnLCAncmVhdHRlbXB0aW5nIGNvbm5lY3Rpb24nKTtcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb2ZmbGluZeKAmSBldmVudCcsICdkaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQnKTtcblx0XHRcdFx0XHQvLyBOb3Qgc3VmZmljaWVudCB0byBqdXN0IGdvIHRvIHRoZSAnZGlzY29ubmVjdGVkJyBzdGF0ZSwgd2FudCB0b1xuXHRcdFx0XHRcdC8vIGZvcmNlIGFsbCB0cmFuc3BvcnRzIHRvIHJlYXR0ZW1wdCB0aGUgY29ubmVjdGlvbi4gV2lsbCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdC8vIHJldHJ5LlxuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoQ29ubmVjdGlvbk1hbmFnZXIsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIHRyYW5zcG9ydCBtYW5hZ2VtZW50XG5cdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xuXG5cdE9iamVjdChfd2Vic29ja2V0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShDb25uZWN0aW9uTWFuYWdlcik7XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChwbGF0Zm9ybV90cmFuc3BvcnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLCBmdW5jdGlvbiAoaW5pdEZuKSB7XG5cdFx0aW5pdEZuKENvbm5lY3Rpb25NYW5hZ2VyKTtcblx0fSk7XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uKGhvc3QsIG1vZGUpIHtcblx0XHR2YXIgcGFyYW1zID0gbmV3IFRyYW5zcG9ydFBhcmFtcyh0aGlzLm9wdGlvbnMsIGhvc3QsIG1vZGUsIHRoaXMuY29ubmVjdGlvbktleSk7XG5cdFx0aWYodGhpcy50aW1lU2VyaWFsKSB7XG5cdFx0XHRwYXJhbXMudGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbDtcblx0XHR9IGVsc2UgaWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5jb25uZWN0aW9uU2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRQYXJhbXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGRlY2lkZU1vZGUobW9kZUNiKSB7XG5cdFx0XHRpZihzZWxmLmNvbm5lY3Rpb25LZXkpIHtcblx0XHRcdFx0bW9kZUNiKCdyZXN1bWUnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0eXBlb2Ygc2VsZi5vcHRpb25zLnJlY292ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG1vZGVDYigncmVjb3ZlcicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWNvdmVyRm4gPSBzZWxmLm9wdGlvbnMucmVjb3Zlcixcblx0XHRcdFx0bGFzdFNlc3Npb25EYXRhID0gZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCk7XG5cdFx0XHRpZihsYXN0U2Vzc2lvbkRhdGEgJiYgdHlwZW9mKHJlY292ZXJGbikgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ0NhbGxpbmcgY2xpZW50T3B0aW9ucy1wcm92aWRlZCByZWNvdmVyIGZ1bmN0aW9uIHdpdGggbGFzdCBzZXNzaW9uIGRhdGEnKTtcblx0XHRcdFx0cmVjb3ZlckZuKGxhc3RTZXNzaW9uRGF0YSwgZnVuY3Rpb24oc2hvdWxkUmVjb3Zlcikge1xuXHRcdFx0XHRcdGlmKHNob3VsZFJlY292ZXIpIHtcblx0XHRcdFx0XHRcdHNlbGYub3B0aW9ucy5yZWNvdmVyID0gbGFzdFNlc3Npb25EYXRhLnJlY292ZXJ5S2V5O1xuXHRcdFx0XHRcdFx0bW9kZUNiKCdyZWNvdmVyJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1vZGVDYignY2xlYW4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRtb2RlQ2IoJ2NsZWFuJyk7XG5cdFx0fVxuXG5cdFx0ZGVjaWRlTW9kZShmdW5jdGlvbihtb2RlKSB7XG5cdFx0XHR2YXIgdHJhbnNwb3J0UGFyYW1zID0gc2VsZi5jcmVhdGVUcmFuc3BvcnRQYXJhbXMobnVsbCwgbW9kZSk7XG5cdFx0XHRpZihtb2RlID09PSAncmVjb3ZlcicpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCByZWNvdmVyeSBtb2RlID0gcmVjb3ZlcjsgcmVjb3ZlcnlLZXkgPSAnICsgc2VsZi5vcHRpb25zLnJlY292ZXIpO1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSBzZWxmLm9wdGlvbnMucmVjb3Zlci5zcGxpdCgnOicpO1xuXHRcdFx0XHRpZihtYXRjaCAmJiBtYXRjaFsyXSkge1xuXHRcdFx0XHRcdHNlbGYubXNnU2VyaWFsID0gbWF0Y2hbMl07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcGFyYW1zID0gJyArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgdG8gY29ubmVjdCB1c2luZyBhIGdpdmVuIHRyYW5zcG9ydFxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqIEBwYXJhbSBjYW5kaWRhdGUsIHRoZSB0cmFuc3BvcnQgdG8gdHJ5XG5cdCAqIEBwYXJhbSBjYWxsYmFja1xuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyeUFUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIGhvc3QgPSB0cmFuc3BvcnRQYXJhbXMuaG9zdDtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyeWluZyAnICsgY2FuZGlkYXRlKTtcblx0XHQoQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdKS50cnlDb25uZWN0KHRoaXMsIHRoaXMucmVhbHRpbWUuYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBmdW5jdGlvbih3cmFwcGVkRXJyLCB0cmFuc3BvcnQpIHtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuc3RhdGU7XG5cdFx0XHRpZihzdGF0ZSA9PSBzZWxmLnN0YXRlcy5jbG9zaW5nIHx8IHN0YXRlID09IHNlbGYuc3RhdGVzLmNsb3NlZCB8fCBzdGF0ZSA9PSBzZWxmLnN0YXRlcy5mYWlsZWQpIHtcblx0XHRcdFx0aWYodHJhbnNwb3J0KSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uICcgKyBzdGF0ZS5zdGF0ZSArICcgd2hpbGUgd2Ugd2VyZSBhdHRlbXB0aW5nIHRoZSB0cmFuc3BvcnQ7IGNsb3NpbmcgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0dHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYod3JhcHBlZEVycikge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJyAnICsgd3JhcHBlZEVyci5ldmVudCArICcsIGVycjogJyArIHdyYXBwZWRFcnIuZXJyb3IudG9TdHJpbmcoKSk7XG5cblx0XHRcdFx0LyogQ29tZXQgdHJhbnNwb3J0IG9uY29ubmVjdCB0b2tlbiBlcnJvcnMgY2FuIGJlIGRlYWx0IHdpdGggaGVyZS5cblx0XHRcdFx0KiBXZWJzb2NrZXQgb25lcyBvbmx5IGhhcHBlbiBhZnRlciB0aGUgdHJhbnNwb3J0IGNsYWltcyB0byBiZSB2aWFibGUsXG5cdFx0XHRcdCogc28gYXJlIGRlYWx0IHdpdGggYXMgbm9uLW9uY29ubmVjdCB0b2tlbiBlcnJvcnMgKi9cblx0XHRcdFx0aWYoX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIod3JhcHBlZEVyci5lcnJvcikgJiYgIShzZWxmLmVycm9yUmVhc29uICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHNlbGYuZXJyb3JSZWFzb24pKSkge1xuXHRcdFx0XHRcdHNlbGYuZXJyb3JSZWFzb24gPSB3cmFwcGVkRXJyLmVycm9yO1xuXHRcdFx0XHRcdC8qIHJlLWdldCBhIHRva2VuIGFuZCB0cnkgYWdhaW4gKi9cblx0XHRcdFx0XHRzZWxmLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRcdFx0LyogRXJyb3IgdGhhdCdzIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG5cdFx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvcn0pO1xuXHRcdFx0XHRcdGNhbGxiYWNrKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYod3JhcHBlZEVyci5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcblx0XHRcdFx0XHRpZighX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1JldHJpYWJsZSh3cmFwcGVkRXJyLmVycm9yKSkge1xuXHRcdFx0XHRcdFx0LyogRXJyb3IgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIHRoYXQgZG9lcyBub3QgY2FsbCBmb3IgdHJ5aW5nIGEgZmFsbGJhY2sgaG9zdCwgZWcgYSByYXRlIGxpbWl0ICovXG5cdFx0XHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogc2VsZi5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yfSk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogRXJyb3Igd2l0aCB0aGF0IHRyYW5zcG9ydCBvbmx5OyBjb250aW51ZSB0cnlpbmcgb3RoZXIgZmFsbGJhY2sgaG9zdHMgKi9cblx0XHRcdFx0XHRcdGNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICc7IHNldHRpbmcgcGVuZGluZycpO1xuXHRcdFx0c2VsZi5zZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgaW5kaWNhdGVkIHRvIGJlIHZpYWJsZSwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlclxuXHQgKiBleHBlY3RzIHRvIGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0IGFzIHNvb24gYXMgaXQgaXMgY29ubmVjdGVkLlxuXHQgKiBAcGFyYW0gaG9zdFxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VHJhbnNwb3J0UGVuZGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIG1vZGUgPSB0cmFuc3BvcnRQYXJhbXMubW9kZTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhbnNwb3J0UGVuZGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBtb2RlID0gJyArIG1vZGUpO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0cmFuc3BvcnQub25jZSgnY29ubmVjdGVkJywgZnVuY3Rpb24oZXJyb3IsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbikge1xuXHRcdFx0aWYobW9kZSA9PSAndXBncmFkZScgJiYgc2VsZi5hY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0XHQvKiAgaWYgd3MgYW5kIHhocnMgYXJlIGNvbm5lY3RpbmcgaW4gcGFyYWxsZWwsIGRlbGF5IHhocnMgYWN0aXZhdGlvbiB0byBsZXQgd3MgZ28gYWhlYWQgKi9cblx0XHRcdFx0aWYodHJhbnNwb3J0LnNob3J0TmFtZSAhPT0gb3B0aW1hbFRyYW5zcG9ydCAmJiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHNlbGYuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMoKSwgb3B0aW1hbFRyYW5zcG9ydCkpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKTtcblx0XHRcdFx0XHR9LCBzZWxmLm9wdGlvbnMudGltZW91dHMucGFyYWxsZWxVcGdyYWRlRGVsYXkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKTtcblxuXHRcdFx0XHQvKiBhbGxvdyBjb25uZWN0SW1wbCB0byBzdGFydCB0aGUgdXBncmFkZSBwcm9jZXNzIGlmIG5lZWRlZCwgYnV0IGFsbG93XG5cdFx0XHRcdCAqIG90aGVyIGV2ZW50IGhhbmRsZXJzLCBpbmNsdWRpbmcgYWN0aXZhdGluZyB0aGUgdHJhbnNwb3J0LCB0byBydW4gZmlyc3QgKi9cblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihtb2RlID09PSAncmVjb3ZlcicgJiYgc2VsZi5vcHRpb25zLnJlY292ZXIpIHtcblx0XHRcdFx0LyogQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlY292ZXJ5LCB3ZSB1bnBlcnNpc3QsIGFzIGEgcmVjb3Zlcnkga2V5IGNhbm5vdFxuXHRcdFx0XHQqIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UgKi9cblx0XHRcdFx0c2VsZi5vcHRpb25zLnJlY292ZXIgPSBudWxsO1xuXHRcdFx0XHRzZWxmLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRyYW5zcG9ydC5vbihbJ2Rpc2Nvbm5lY3RlZCcsICdjbG9zZWQnLCAnZmFpbGVkJ10sIGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRzZWxmLmRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCB0aGlzLmV2ZW50LCBlcnJvcik7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5wZW5kaW5nJywgdHJhbnNwb3J0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYW4gdXBncmFkZSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLFxuXHQgKiB0byBzY2hlZHVsZSB0aGUgYWN0aXZhdGlvbiBvZiB0aGF0IHRyYW5zcG9ydC5cblx0ICogQHBhcmFtIGVycm9yXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRcblx0ICogQHBhcmFtIGNvbm5lY3Rpb25JZFxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHNcblx0ICogQHBhcmFtIGNvbm5lY3RlZE1lc3NhZ2Vcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24gPSBmdW5jdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCB1cGdyYWRlQ29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0Y3VycmVudFRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSxcblx0XHRcdGFiYW5kb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZShzZWxmLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fTtcblxuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG5cdFx0XHQvKiBUaGlzIGlzIG1vc3QgbGlrZWx5IHRvIGhhcHBlbiBmb3IgdGhlIGRlbGF5ZWQgeGhycywgd2hlbiB4aHJzIGFuZCB3cyBhcmUgc2NoZWR1bGVkIGluIHBhcmFsbGVsKi9cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgKCcgKyB0aGlzLnN0YXRlLnN0YXRlICsgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgPyAnLCBidXQgd2l0aCBhbiB1cGdyYWRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnIDogJycpICsgJykgaXMgbm90IHZhbGlkIHRvIHVwZ3JhZGUgaW47IGFiYW5kb25pbmcgdXBncmFkZSB0byAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG5cdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoY3VycmVudFRyYW5zcG9ydCAmJiAhYmV0dGVyVHJhbnNwb3J0VGhhbih0cmFuc3BvcnQsIGN1cnJlbnRUcmFuc3BvcnQpKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJyBpcyBubyBiZXR0ZXIgdGhhbiBjdXJyZW50IGFjdGl2ZSB0cmFuc3BvcnQgJyArIGN1cnJlbnRUcmFuc3BvcnQuc2hvcnROYW1lICsgJyAtIGFiYW5kb25pbmcgdXBncmFkZScpO1xuXHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTY2hlZHVsaW5nIHRyYW5zcG9ydCB1cGdyYWRlOyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblxuXHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25jZU5vcGVuZGluZyhmdW5jdGlvbihlcnIpIHtcblx0XHRcdHZhciBvbGRQcm90b2NvbDtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnVW5hYmxlIHRvIGFjdGl2YXRlIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IGVyciA9ICcgKyBlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcblx0XHRcdFx0LyogVGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSB4aHIgc3RyZWFtaW5nIHRyYW5zcG9ydCB3YXMgZGlzY29ubmVjdGVkIGR1cmluZyB0aGUgcGFyYWxsZWxVcGdyYWRlRGVsYXkgKi9cblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICdpcyBubyBsb25nZXIgY29ubmVjdGVkOyBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcblx0XHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLmNvbm5lY3RlZCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudGx5IGNvbm5lY3RlZCwgc28gdGVtcG9yYXJpbHkgcGF1c2luZyBldmVudHMgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUnKTtcblx0XHRcdFx0c2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmc7XG5cdFx0XHRcdG9sZFByb3RvY29sID0gc2VsZi5hY3RpdmVQcm90b2NvbDtcblx0XHRcdH0gZWxzZSBpZihzZWxmLnN0YXRlICE9PSBzZWxmLnN0YXRlcy5jb25uZWN0aW5nKSB7XG5cdFx0XHRcdC8qIE5vdGU6IHVwZ3JhZGluZyBmcm9tIHRoZSBjb25uZWN0aW5nIHN0YXRlIGlzIHZhbGlkIGlmIHRoZSBvbGQgYWN0aXZlXG5cdFx0XHRcdCogdHJhbnNwb3J0IHdhcyBkZWFjdGl2YXRlZCBhZnRlciB0aGUgdXBncmFkZSB0cmFuc3BvcnQgZmlyc3QgY29ubmVjdGVkO1xuXHRcdFx0XHQqIHNlZSBsb2dpYyBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgKCcgKyBzZWxmLnN0YXRlLnN0YXRlICsgKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcgPyAnLCBidXQgd2l0aCBhbiB1cGdyYWRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnIDogJycpICsgJykgaXMgbm90IHZhbGlkIHRvIHVwZ3JhZGUgaW47IGFiYW5kb25pbmcgdXBncmFkZSB0byAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG5cdFx0XHRcdGFiYW5kb24oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBJZiB0aGUgY29ubmVjdGlvbklkIGhhcyBjaGFuZ2VkLCB0aGUgdXBncmFkZSBoYXNuJ3Qgd29ya2VkLiBCdXQgYXNcblx0XHRcdCogaXQncyBzdGlsbCBhbiB1cGdyYWRlLCByZWFsdGltZSBzdGlsbCBleHBlY3RzIGEgc3luYyAtIGl0IGp1c3QgbmVlZHMgdG9cblx0XHRcdCogYmUgYSBzeW5jIHdpdGggdGhlIG5ldyBjb25uZWN0aW9uIHBvc2l0aW9uLiAoQW5kIGl0XG5cdFx0XHQqIG5lZWRzIHRvIGJlIHNldCBpbiB0aGUgbGlicmFyeSwgd2hpY2ggaXMgZG9uZSBieSBhY3RpdmF0ZVRyYW5zcG9ydCkuICovXG5cdFx0XHR2YXIgY29ubmVjdGlvblJlc2V0ID0gY29ubmVjdGlvbklkICE9PSBzZWxmLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0c3luY1Bvc2l0aW9uID0gY29ubmVjdGlvblJlc2V0ID8gdXBncmFkZUNvbm5lY3Rpb25Qb3NpdGlvbiA6IHNlbGY7XG5cblx0XHRcdGlmKGNvbm5lY3Rpb25SZXNldCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnVXBncmFkZSByZXN1bHRlZCBpbiBuZXcgY29ubmVjdGlvbklkOyByZXNldHRpbmcgbGlicmFyeSBjb25uZWN0aW9uIHBvc2l0aW9uIGZyb20gJyArIChzZWxmLnRpbWVTZXJpYWwgfHwgc2VsZi5jb25uZWN0aW9uU2VyaWFsKSArICcgdG8gJyArIChzeW5jUG9zaXRpb24udGltZVNlcmlhbCB8fCBzeW5jUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbCkgKyAnOyB1cGdyYWRlIGVycm9yIHdhcyAnICsgZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnU3luY2luZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0c2VsZi5zeW5jKHRyYW5zcG9ydCwgc3luY1Bvc2l0aW9uLCBmdW5jdGlvbihzeW5jRXJyLCBjb25uZWN0aW9uSWQsIHBvc3RTeW5jUG9zaXRpb24pIHtcblx0XHRcdFx0LyogSWYgdGhlcmUncyBiZWVuIHNvbWUgcHJvYmxlbSB3aXRoIHN5bmNpbmcgKGFuZCB0aGUgY29ubmVjdGlvbiBoYXNuJ3Rcblx0XHRcdFx0ICogY2xvc2VkIG9yIHNvbWV0aGluZyBpbiB0aGUgbWVhbnRpbWUpLCB3ZSBoYXZlIGEgcHJvYmxlbSAtLSB3ZSBjYW4ndFxuXHRcdFx0XHQgKiBqdXN0IGZhbGwgYmFjayBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgYXMgd2UgZG9uJ3Qga25vdyB3aGV0aGVyXG5cdFx0XHRcdCAqIHJlYWx0aW1lIGdvdCB0aGUgc3luYyAtLSBpZiBpdCBkaWQsIHRoZSBvbGQgdHJhbnNwb3J0IGlzIG5vIGxvbmdlclxuXHRcdFx0XHQgKiB2YWxpZC4gVG8gYmUgc2FmZSwgd2UgZGlzY29ubmVjdCBib3RoIGFuZCBzdGFydCBhZ2FpbiBmcm9tIHNjcmF0Y2guICovXG5cdFx0XHRcdGlmKHN5bmNFcnIpIHtcblx0XHRcdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG5cdFx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnVW5leHBlY3RlZCBlcnJvciBhdHRlbXB0aW5nIHRvIHN5bmMgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgZXJyID0gJyArIHN5bmNFcnIpO1xuXHRcdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGZpbmlzaFVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQWN0aXZhdGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0XHRcdHNlbGYuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgcG9zdFN5bmNQb3NpdGlvbik7XG5cdFx0XHRcdFx0LyogUmVzdG9yZSBwcmUtc3luYyBzdGF0ZS4gSWYgc3RhdGUgaGFzIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lLFxuXHRcdFx0XHRcdCAqIGRvbid0IHRvdWNoIGl0IC0tIHNpbmNlIHRoZSB3ZWJzb2NrZXQgdHJhbnNwb3J0IHdhaXRzIGEgdGljayBiZWZvcmVcblx0XHRcdFx0XHQgKiBkaXNwb3NpbmcgaXRzZWxmLCBpdCdzIHBvc3NpYmxlIGZvciBpdCB0byBoYXZlIGhhcHBpbHkgc3luY2VkXG5cdFx0XHRcdFx0ICogd2l0aG91dCBlcnIgd2hpbGUsIHVua25vd24gdG8gaXQsIHRoZSBjb25uZWN0aW9uIGhhcyBjbG9zZWQgaW4gdGhlXG5cdFx0XHRcdFx0ICogbWVhbnRpbWUgYW5kIHRoZSB3cyB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBkZWF0aCAqL1xuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBzZW5kaW5nIHF1ZXVlZCBtZXNzYWdlcyBvbiB1cGdyYWRlZCB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0XHRcdFx0c2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGVzLmNvbm5lY3RlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIGJ1dCBzdGF0ZSBpcyBub3cgJyArIHNlbGYuc3RhdGUuc3RhdGUgKyAnLCBzbyBsZWF2aW5nIHVuY2hhbmdlZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzZWxmLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdFx0XHRcdHNlbGYuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8qIFdhaXQgdW50aWwgc3luYyBpcyBkb25lIGFuZCBvbGQgdHJhbnNwb3J0IGlzIGlkbGUgYmVmb3JlIGFjdGl2YXRpbmcgbmV3IHRyYW5zcG9ydC4gVGhpc1xuXHRcdFx0XHQgKiBndWFyYW50ZWVzIHRoYXQgbWVzc2FnZXMgYXJyaXZlIGF0IHJlYWx0aW1lIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgYXJlIHNlbnQuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIElmIGEgbWVzc2FnZSB0aW1lcyBvdXQgb24gdGhlIG9sZCB0cmFuc3BvcnQsIHNpbmNlIGl0J3Mgc3RpbGwgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgdGhlXG5cdFx0XHRcdCAqIG1lc3NhZ2Ugd2lsbCBiZSByZXF1ZXVlZC4gZGVhY3RpdmF0ZVRyYW5zcG9ydCB3aWxsIHNlZSB0aGUgcGVuZGluZyB0cmFuc3BvcnQgYW5kIG5vdGlmeVxuXHRcdFx0XHQgKiB0aGUgYGNvbm5lY3RpbmdgIHN0YXRlIHdpdGhvdXQgc3RhcnRpbmcgYSBuZXcgY29ubmVjdGlvbiwgc28gdGhlIG5ldyB0cmFuc3BvcnQgY2FuIHRha2Vcblx0XHRcdFx0ICogb3ZlciBvbmNlIGRlYWN0aXZhdGVUcmFuc3BvcnQgY2xlYXJzIHRoZSBvbGQgcHJvdG9jb2wncyBxdWV1ZS5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgdGhlcmUgaXMgbm8gb2xkIHByb3RvY29sLCB0aGF0IG1lYW50IHRoYXQgd2Ugd2VyZW4ndCBpbiB0aGUgY29ubmVjdGVkIHN0YXRlIGF0IHRoZVxuXHRcdFx0XHQgKiBiZWdpbm5pbmcgb2YgdGhlIHN5bmMgLSBsaWtlbHkgdGhlIGJhc2UgdHJhbnNwb3J0IGRpZWQganVzdCBiZWZvcmUgdGhlIHN5bmMuIFNvIGNhbiBqdXN0XG5cdFx0XHRcdCAqIGZpbmlzaCB0aGUgdXBncmFkZS4gSWYgd2UncmUgYWN0dWFsbHkgaW4gY2xvc2luZy9mYWlsZWQgcmF0aGVyIHRoYW4gY29ubmVjdGluZywgdGhhdCdzXG5cdFx0XHRcdCAqIGZpbmUsIGFjdGl2YXRldHJhbnNwb3J0IHdpbGwgZGVhbCB3aXRoIHRoYXQuICovXG5cdFx0XHRcdGlmKG9sZFByb3RvY29sKSB7XG5cdFx0XHRcdCAvKiBNb3N0IG9mIHRoZSB0aW1lIHRoaXMgd2lsbCBiZSBhbHJlYWR5IHRydWU6IHRoZSBuZXctdHJhbnNwb3J0IHN5bmMgd2lsbCBoYXZlIGdpdmVuXG5cdFx0XHRcdCAqIGVub3VnaCB0aW1lIGZvciBpbi1mbGlnaHQgbWVzc2FnZXMgb24gdGhlIG9sZCB0cmFuc3BvcnQgdG8gY29tcGxldGUuICovXG5cdFx0XHRcdFx0b2xkUHJvdG9jb2wub25jZUlkbGUoZmluaXNoVXBncmFkZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmluaXNoVXBncmFkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgY29ubmVjdGVkLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIGRlY2lkZXMgdGhhdFxuXHQgKiBpdCB3aWxsIG5vdyBiZSB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBhY3RpdmF0ZWRcblx0ICogdGhlIHRyYW5zcG9ydCAoaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZy9jbG9zZWQgaXQgd2lsbCBjaG9vc2Ugbm90IHRvKS5cblx0ICogQHBhcmFtIHRyYW5zcG9ydCB0aGUgdHJhbnNwb3J0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uSWQgdGhlIGlkIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cblx0ICogQHBhcmFtIGNvbm5lY3Rpb25EZXRhaWxzIHRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cblx0ICogQHBhcmFtIGNvbm5lY3Rpb25Qb3NpdGlvbiB0aGUgcG9zaXRpb24gYXQgdGhlIHBvaW50IGFjdGl2YXRpb247IGVpdGhlciB7Y29ubmVjdGlvblNlcmlhbDogPHNlcmlhbD59IG9yIHt0aW1lU2VyaWFsOiA8c2VyaWFsPn1cblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdGlmKGVycm9yKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdlcnJvciA9ICcgKyBlcnJvcik7XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25JZCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbklkID0gICcgKyBjb25uZWN0aW9uSWQpO1xuXHRcdH1cblx0XHRpZihjb25uZWN0aW9uRGV0YWlscykge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbkRldGFpbHMgPSAgJyArIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb25EZXRhaWxzKSk7XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25Qb3NpdGlvbikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnc2VyaWFsID0gICcgKyAoY29ubmVjdGlvblBvc2l0aW9uLnRpbWVTZXJpYWwgfHwgY29ubmVjdGlvblBvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwpKTtcblx0XHR9XG5cblx0XHR0aGlzLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydCk7XG5cblx0XHQvKiBpZiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgbW92ZWQgdG8gdGhlIGNsb3NpbmcvY2xvc2VkIHN0YXRlIGJlZm9yZSB0aGlzXG5cdFx0ICogY29ubmVjdGlvbiBldmVudCwgdGhlbiB3ZSB3b24ndCBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCAqL1xuXHRcdHZhciBleGlzdGluZ1N0YXRlID0gdGhpcy5zdGF0ZSxcblx0XHRcdGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2N1cnJlbnQgc3RhdGUgPSAnICsgZXhpc3RpbmdTdGF0ZS5zdGF0ZSk7XG5cdFx0aWYoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zaW5nLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkLnN0YXRlIHx8IGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuZmFpbGVkLnN0YXRlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEaXNjb25uZWN0aW5nIHRyYW5zcG9ydCBhbmQgYWJhbmRvbmluZycpO1xuXHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiByZW1vdmUgdGhpcyB0cmFuc3BvcnQgZnJvbSBwZW5kaW5nIHRyYW5zcG9ydHMgKi9cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiBpZiB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjb25uZWN0ZWQgKGVnIGJlY2F1c2UgaXQgZmFpbGVkIGR1cmluZyBhXG5cdFx0ICogc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uI29uY2VOb1BlbmRpbmcgd2FpdCkgdGhlbiBkb24ndCBhY3RpdmF0ZSBpdCAqL1xuXHRcdGlmKCF0cmFuc3BvcnQuaXNDb25uZWN0ZWQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0RlY2xpbmluZyB0byBhY3RpdmF0ZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCArICcgc2luY2UgaXQgYXBwZWFycyB0byBubyBsb25nZXIgYmUgY29ubmVjdGVkJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogdGhlIGdpdmVuIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQ7IHRoaXMgd2lsbCBpbW1lZGlhdGVseVxuXHRcdCAqIHRha2Ugb3ZlciBhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCAqL1xuXHRcdHZhciBleGlzdGluZ0FjdGl2ZVByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbDtcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IF9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRyYW5zcG9ydCk7XG5cdFx0dGhpcy5ob3N0ID0gdHJhbnNwb3J0LnBhcmFtcy5ob3N0O1xuXG5cdFx0dmFyIGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuXHRcdGlmKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpICB7XG5cdFx0XHR0aGlzLnNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uLCAhIWVycm9yKTtcblx0XHR9XG5cblx0XHQvKiBSZWJyb2FkY2FzdCBhbnkgbmV3IGNvbm5lY3Rpb25EZXRhaWxzIGZyb20gdGhlIGFjdGl2ZSB0cmFuc3BvcnQsIHdoaWNoXG5cdFx0ICogY2FuIGNvbWUgYXQgYW55IHRpbWUgKGVnIGZvbGxvd2luZyBhIHJlYXV0aCksIGFuZCBlbWl0IGFuIFJUTjI0IFVQREFURVxuXHRcdCAqIGV2ZW50LiAoTGlzdGVuZXIgYWRkZWQgb24gbmV4dFRpY2sgYmVjYXVzZSB3ZSdyZSBpbiBhIHRyYW5zcG9ydC5vbignY29ubmVjdGVkJylcblx0XHQgKiBjYWxsYmFjayBhdCB0aGUgbW9tZW50OyBpZiB3ZSBhZGQgaXQgbm93IHdlJ2xsIGJlIGFkZGluZyBpdCB0byB0aGUgZW5kXG5cdFx0ICogb2YgdGhlIGxpc3RlbmVycyBhcnJheSBhbmQgaXQnbGwgYmUgY2FsbGVkIGltbWVkaWF0ZWx5KSAqL1xuXHRcdHRoaXMub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdHRyYW5zcG9ydC5vbignY29ubmVjdGVkJywgZnVuY3Rpb24oY29ubmVjdGVkRXJyLCBfY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuXHRcdFx0XHRzZWxmLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCk7XG5cdFx0XHRcdHNlbGYuZW1pdCgndXBkYXRlJywgbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0oY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBjb25uZWN0ZWRFcnIpKTtcblx0XHRcdH0pO1xuXHRcdH0pXG5cblx0XHQvKiBJZiBwcmV2aW91c2x5IG5vdCBjb25uZWN0ZWQsIG5vdGlmeSB0aGUgc3RhdGUgY2hhbmdlIChpbmNsdWRpbmcgYW55XG5cdFx0ICogZXJyb3IpLiAqL1xuXHRcdGlmKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuXHRcdFx0aWYoZXJyb3IpIHtcblx0XHRcdFx0LyogaWYgdXBncmFkaW5nIHdpdGhvdXQgZXJyb3IsIGxlYXZlIGFueSBleGlzdGluZyBlcnJvclJlYXNvbiBhbG9uZSAqL1xuXHRcdFx0XHR0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XG5cdFx0XHRcdC8qIE9ubHkgYm90aGVyIGVtaXR0aW5nIGFuIHVwZ3JhZGUgaWYgdGhlcmUncyBhbiBlcnJvcjsgb3RoZXJ3aXNlIGl0J3Ncblx0XHRcdFx0ICoganVzdCBhIHRyYW5zcG9ydCB1cGdyYWRlLCBzbyBhdXRoIGRldGFpbHMgd29uJ3QgaGF2ZSBjaGFuZ2VkICovXG5cdFx0XHRcdHRoaXMuZW1pdCgndXBkYXRlJywgbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0oY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RlZCcsIGVycm9yOiBlcnJvcn0pO1xuXHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yIHx8IG51bGw7XG5cdFx0fVxuXG5cdFx0LyogU2VuZCBhZnRlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB1cGRhdGUsIGFzIENoYW5uZWxzIGhvb2tzIGludG8gdGhpcyB0b1xuXHRcdCAqIHJlc2VuZCBhdHRhY2hlcyBvbiBhIG5ldyB0cmFuc3BvcnQgaWYgbmVjZXNzYXJ5ICovXG5cdFx0dGhpcy5lbWl0KCd0cmFuc3BvcnQuYWN0aXZlJywgdHJhbnNwb3J0KTtcblxuXHRcdC8qIEdyYWNlZnVsbHkgdGVybWluYXRlIGV4aXN0aW5nIHByb3RvY29sICovXG5cdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSA+IDApIHtcblx0XHRcdFx0LyogV2UgY291bGQganVzdCByZXF1ZXVlIHBlbmRpbmcgbWVzc2FnZXMgb24gdGhlIG5ldyB0cmFuc3BvcnQsIGJ1dFxuXHRcdFx0XHQgKiBhY3R1YWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW46IHRyYW5zcG9ydHMgc2hvdWxkIG9ubHkgdGFrZSBvdmVyXG5cdFx0XHRcdCAqIGZyb20gb3RoZXIgYWN0aXZlIHRyYW5zcG9ydHMgd2hlbiB1cGdyYWRpbmcsIGFuZCB1cGdyYWRpbmcgd2FpdHMgZm9yXG5cdFx0XHRcdCAqIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGJlIGlkbGUuIFNvIGxvZyBhbiBlcnJvci4gKi9cblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnUHJldmlvdXMgYWN0aXZlIHByb3RvY29sIChmb3IgdHJhbnNwb3J0ICcgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnLCBuZXcgb25lIGlzICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJykgZmluaXNoaW5nIHdpdGggJyArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyAnIG1lc3NhZ2VzIHN0aWxsIHBlbmRpbmcnKTtcblx0XHRcdH1cblx0XHRcdGlmKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgd2FzIGFsc28gdGhlIHRyYW5zcG9ydCBmb3IgdGhlIHByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnOyBzdGFjayA9ICcgKyBuZXcgRXJyb3IoKS5zdGFjaztcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCBtc2cpO1xuXHRcdFx0XHRfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlcG9ydCgnZXJyb3InLCBtc2csICd0cmFuc3BvcnQtcHJldmlvdXNseS1hY3RpdmUnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wuZmluaXNoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogVGVybWluYXRlIGFueSBvdGhlciBwZW5kaW5nIHRyYW5zcG9ydChzKSwgYW5kXG5cdFx0ICogYWJvcnQgYW55IG5vdC15ZXQtcGVuZGluZyB0cmFuc3BvcnQgYXR0ZW1wdHMgKi9cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uKHBlbmRpbmdUcmFuc3BvcnQpIHtcblx0XHRcdGlmKHBlbmRpbmdUcmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCBpcyBzdGlsbCBtYXJrZWQgYXMgYSBwZW5kaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnOyBzdGFjayA9ICcgKyBuZXcgRXJyb3IoKS5zdGFjaztcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCBtc2cpO1xuXHRcdFx0XHRfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlcG9ydCgnZXJyb3InLCBtc2csICd0cmFuc3BvcnQtYWN0aXZhdGluZy1wZW5kaW5nJyk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBlbmRpbmdUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uKHByb3Bvc2VkVHJhbnNwb3J0KSB7XG5cdFx0XHRpZihwcm9wb3NlZFRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHByb3Bvc2VkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnOyBzdGFjayA9ICcgKyBuZXcgRXJyb3IoKS5zdGFjaztcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCBtc2cpO1xuXHRcdFx0XHRfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlcG9ydCgnZXJyb3InLCBtc2csICd0cmFuc3BvcnQtYWN0aXZhdGluZy1wcm9wb3NlZCcpO1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHNlbGYucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvcG9zZWRUcmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIG5vIGxvbmdlciB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gVGhpcyBjYW4gb2NjdXJcblx0ICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0XG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgc3RhdGUsIGVycm9yKSB7XG5cdFx0dmFyIGN1cnJlbnRQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wsXG5cdFx0XHR3YXNBY3RpdmUgPSBjdXJyZW50UHJvdG9jb2wgJiYgY3VycmVudFByb3RvY29sLmdldFRyYW5zcG9ydCgpID09PSB0cmFuc3BvcnQsXG5cdFx0XHR3YXNQZW5kaW5nID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpLFxuXHRcdFx0d2FzUHJvcG9zZWQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpLFxuXHRcdFx0bm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3N0YXRlID0gJyArIHN0YXRlICsgKHdhc0FjdGl2ZSA/ICc7IHdhcyBhY3RpdmUnIDogd2FzUGVuZGluZyA/ICc7IHdhcyBwZW5kaW5nJyA6IHdhc1Byb3Bvc2VkID8gJzsgd2FzIHByb3Bvc2VkJyA6ICcnKSArIChub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID8gJycgOiAnOyBhbm90aGVyIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24nKSk7XG5cdFx0aWYoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSlcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAncmVhc29uID0gICcgKyBlcnJvci5tZXNzYWdlKTtcblxuXHRcdGlmKHdhc0FjdGl2ZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdHZXR0aW5nLCBjbGVhcmluZywgYW5kIHJlcXVldWluZyAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArICcgcGVuZGluZyBtZXNzYWdlcycpO1xuXHRcdFx0dGhpcy5xdWV1ZVBlbmRpbmdNZXNzYWdlcyhjdXJyZW50UHJvdG9jb2wuZ2V0UGVuZGluZ01lc3NhZ2VzKCkpO1xuXHRcdFx0LyogQ2xlYXIgYW55IG1lc3NhZ2VzIHdlIHJlcXVldWUgdG8gYWxsb3cgdGhlIHByb3RvY29sIHRvIGJlY29tZSBpZGxlLlxuXHRcdFx0ICogSW4gY2FzZSBvZiBhbiB1cGdyYWRlLCB0aGlzIHdpbGwgdHJpZ2dlciBhbiBpbW1lZGlhdGUgYWN0aXZhdGlvbiBvZlxuXHRcdFx0ICogdGhlIHVwZ3JhZGUgdHJhbnNwb3J0LCBzbyBkZWxheSBhIHRpY2sgc28gdGhpcyB0cmFuc3BvcnQgY2FuIGZpbmlzaFxuXHRcdFx0ICogZGVhY3RpdmF0aW5nICovXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJyZW50UHJvdG9jb2wuY2xlYXJQZW5kaW5nTWVzc2FnZXMoKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbCA9IHRoaXMuaG9zdCA9IG51bGw7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5jaGFubmVsUmVzdW1lQ2hlY2tUaW1lcik7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbWl0KCd0cmFuc3BvcnQuaW5hY3RpdmUnLCB0cmFuc3BvcnQpO1xuXG5cdFx0LyogdGhpcyB0cmFuc3BvcnQgc3RhdGUgY2hhbmdlIGlzIGEgc3RhdGUgY2hhbmdlIGZvciB0aGUgY29ubmVjdGlvbm1hbmFnZXIgaWZcblx0XHQgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0c1xuXHRcdCAqICAgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBqdXN0IHdhaXRpbmcgZm9yIHRoZVxuXHRcdCAqICAgYWN0aXZlIHRyYW5zcG9ydCB0byBmaW5pc2ggd2hhdCBpdHMgZG9pbmc7IG9yXG5cdFx0ICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlIGVycm9yIHdhcyBmYXRhbCAoc29cblx0XHQgKiAgIHVuaGVhbGFibGUgYnkgYW5vdGhlciB0cmFuc3BvcnQpOyBvclxuXHRcdCAqIC0gdGhlcmUgaXMgbm8gYWN0aXZlIHRyYW5zcG9ydCwgYW5kIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nXG5cdFx0ICogICBwZW5kaW5nIHRyYW5zcG9ydCAoc28gd2Ugd2VyZSBpbiB0aGUgY29ubmVjdGluZyBzdGF0ZSlcblx0XHQgKi9cblx0XHRpZigod2FzQWN0aXZlICYmIG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24pIHx8XG5cdFx0XHQod2FzQWN0aXZlICYmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHx8IChzdGF0ZSA9PT0gJ2Nsb3NlZCcpKSB8fFxuXHRcdFx0KGN1cnJlbnRQcm90b2NvbCA9PT0gbnVsbCAmJiB3YXNQZW5kaW5nICYmIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoID09PSAwKSkge1xuXG5cdFx0XHQvKiBJZiB3ZSdyZSBkaXNjb25uZWN0ZWQgd2l0aCBhIDV4eCB3ZSBuZWVkIHRvIHRyeSBmYWxsYmFjayBob3N0c1xuXHRcdFx0ICogKFJUTjE0ZCksIGJ1dCAoYSkgZHVlIHRvIGhvdyB0aGUgdXBncmFkZSBzZXF1ZW5jZSB3b3JrcywgdGhlXG5cdFx0XHQgKiBob3N0L3RyYW5zcG9ydCBzZWxlY3Rpb24gc2VxdWVuY2Ugb25seSBjYXJlcyBhYm91dCBnZXR0aW5nIHRvXG5cdFx0XHQgKiBgcHJlY29ubmVjdGAgKGVnIGVzdGFibGlzaGluZyBhIHdlYnNvY2tldCkgZ2V0dGluZyBhIGBkaXNjb25uZWN0ZWRgXG5cdFx0XHQgKiBwcm90b2NvbCBtZXNzYWdlIGFmdGVyd2FyZHMgaXMgdG9vIGxhdGU7IGFuZCAoYikgaG9zdCByZXRyeSBvbmx5XG5cdFx0XHQgKiBhcHBsaWVzIHRvIGNvbm5lY3RCYXNlIHVubGVzcyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgdHJhbnNwb3J0IGRvZXNuJ3Rcblx0XHRcdCAqIHdvcmsuIFdlIHNvbHZlIHRoaXMgYnkgdW5wZXJzaXN0aW5nIHRoZSB0cmFuc3BvcnQgcHJlZmVyZW5jZSBhbmRcblx0XHRcdCAqIHNldHRpbmcgYW4gaW5zdGFuY2UgdmFyaWFibGUgdG8gZm9yY2UgZmFsbGJhY2sgaG9zdHMgdG8gYmUgdXNlZCAoaWZcblx0XHRcdCAqIGFueSkgaGVyZS4gQml0IG9mIGEga2x1ZGdlLCBidXQgbm8gcmVhbCBiZXR0ZXIgYWx0ZXJuYXRpdmVzIHdpdGhvdXRcblx0XHRcdCAqIHJld3JpdGluZyB0aGUgZW50aXJlIHRoaW5nICovXG5cdFx0XHRpZihzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgZXJyb3IgJiYgZXJyb3Iuc3RhdHVzQ29kZSA+IDUwMCAmJiB0aGlzLmh0dHBIb3N0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0XHR0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gdHJ1ZTtcblx0XHRcdFx0LyogYW5kIHRyeSB0byBjb25uZWN0IGFnYWluIHRvIHRyeSBhIGZhbGxiYWNrIGhvc3Qgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgdXN1YWwgMTVzIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAqL1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogc3RhdGUsIGVycm9yOiBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZX0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFRPRE8gcmVtb3ZlIGJlbG93IGxpbmUgb25jZSByZWFsdGltZSBzZW5kcyB0b2tlbiBlcnJvcnMgYXMgRElTQ09OTkVDVEVEcyAqL1xuXHRcdFx0dmFyIG5ld0Nvbm5lY3Rpb25TdGF0ZSA9IChzdGF0ZSA9PT0gJ2ZhaWxlZCcgJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoZXJyb3IpKSA/ICdkaXNjb25uZWN0ZWQnIDogc3RhdGU7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogbmV3Q29ubmVjdGlvblN0YXRlLCBlcnJvcjogZXJyb3J9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZih3YXNBY3RpdmUgJiYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykgJiYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcpKSB7XG5cdFx0XHQvKiBJZiB3ZSB3ZXJlIGFjdGl2ZSBidXQgdGhlcmUgaXMgYW5vdGhlciB0cmFuc3BvcnQgc2NoZWR1bGVkIGZvclxuXHRcdFx0KiBhY3RpdmF0aW9uLCBnbyBpbnRvIHRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIHRoYXQgdHJhbnNwb3J0XG5cdFx0XHQqIGFjdGl2YXRlcyBhbmQgc2V0cyB1cyBiYWNrIHRvIGNvbm5lY3RlZC4gKG1hbnVhbGx5IHN0YXJ0aW5nIHRoZVxuXHRcdFx0KiB0cmFuc2l0aW9uIHRpbWVycyBpbiBjYXNlIHRoYXQgbmV2ZXIgaGFwcGVucykuIChJZiB3ZSB3ZXJlIGluIHRoZVxuXHRcdFx0KiBzeW5jaHJvbml6aW5nIHN0YXRlLCB0aGVuIHRoYXQncyBmaW5lLCB0aGUgb2xkIHRyYW5zcG9ydCBqdXN0IGdvdCBpdHNcblx0XHRcdCogZGlzY29ubmVjdGVkIGJlZm9yZSB0aGUgbmV3IG9uZSBnb3QgdGhlIHN5bmMgLS0gaWdub3JlIGl0IGFuZCBrZWVwXG5cdFx0XHQqIHdhaXRpbmcgZm9yIHRoZSBzeW5jLiBJZiBpdCBmYWlscyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3luYyB0aW1lciB0aGF0XG5cdFx0XHQqIHdpbGwgZXhwaXJlKS4gKi9cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnd2FzQWN0aXZlIGJ1dCBhbm90aGVyIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQgYW5kIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbiwgc28gZ29pbmcgaW50byB0aGUgY29ubmVjdGluZyBzdGF0ZSB1bnRpbCBpdCBhY3RpdmF0ZXMnKTtcblx0XHRcdHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcblx0XHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY29ubmVjdGluZyk7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnLCBlcnJvcjogZXJyb3J9KTtcblx0XHR9XG5cdH07XG5cblx0LyogSGVscGVyIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIHdoaWNoIGFyZSBwZW5kaW5nLFxuXHQqIGhhdmUgYmVlbiBjb25uZWN0ZWQsIGFuZCBhcmUganVzdCB3YWl0aW5nIGZvciBvbmNlTm9QZW5kaW5nIHRvIGZpcmUgYmVmb3JlXG5cdCogYmVpbmcgYWN0aXZhdGVkICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzKSB8fFxuXHRcdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5ldmVyeShmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdFx0cmV0dXJuICF0cmFuc3BvcnQuaXNDb25uZWN0ZWQ7XG5cdFx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYWN0aXZhdGluZyBhIG5ldyB0cmFuc3BvcnQsIHRvIGVuc3VyZSBtZXNzYWdlIGRlbGl2ZXJ5XG5cdCAqIG9uIHRoZSBuZXcgdHJhbnNwb3J0IHN5bmNocm9uaXNlcyB3aXRoIHRoZSBtZXNzYWdlcyBhbHJlYWR5IHJlY2VpdmVkXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgcmVxdWVzdGVkU3luY1Bvc2l0aW9uLCBjYWxsYmFjaykge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKCdzeW5jJyk7XG5cdFx0XHRjYWxsYmFjayhuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVGltZW91dCB3YWl0aW5nIGZvciBzeW5jIHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcblxuXHRcdC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG5cdFx0dmFyIHN5bmNNZXNzYWdlID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uOiBhY3Rpb25zLlNZTkMsXG5cdFx0XHRjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXlcblx0XHR9KTtcblxuXHRcdGlmKHJlcXVlc3RlZFN5bmNQb3NpdGlvbi50aW1lU2VyaWFsKSB7XG5cdFx0XHRzeW5jTWVzc2FnZS50aW1lU2VyaWFsID0gcmVxdWVzdGVkU3luY1Bvc2l0aW9uLnRpbWVTZXJpYWw7XG5cdFx0fSBlbHNlIGlmKHJlcXVlc3RlZFN5bmNQb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHN5bmNNZXNzYWdlLmNvbm5lY3Rpb25TZXJpYWwgPSByZXF1ZXN0ZWRTeW5jUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbDtcblx0XHR9XG5cdFx0dHJhbnNwb3J0LnNlbmQoc3luY01lc3NhZ2UpO1xuXG5cdFx0dHJhbnNwb3J0Lm9uY2UoJ3N5bmMnLCBmdW5jdGlvbihjb25uZWN0aW9uSWQsIHN5bmNQb3NpdGlvbikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgY29ubmVjdGlvbklkLCBzeW5jUG9zaXRpb24pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcblx0XHQvKiBpZiBjb25uZWN0aW9uS2V5IGNoYW5nZXMgYnV0IGNvbm5lY3Rpb25JZCBzdGF5cyB0aGUgc2FtZSwgdGhlbiBqdXN0IGFcblx0XHQgKiB0cmFuc3BvcnQgY2hhbmdlIG9uIHRoZSBzYW1lIGNvbm5lY3Rpb24uIElmIGNvbm5lY3Rpb25JZCBjaGFuZ2VzLCB3ZSdyZVxuXHRcdCAqIG9uIGEgbmV3IGNvbm5lY3Rpb24sIHdpdGggaW1wbGljYXRpb25zIGZvciBtc2dTZXJpYWwgYW5kIGNoYW5uZWwgc3RhdGUsXG5cdFx0ICogYW5kIHJlc2V0dGluZyB0aGUgY29ubmVjdGlvblNlcmlhbCBwb3NpdGlvbiAqL1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHQvKiBJZiBubyBwcmV2aW91cyBjb25uZWN0aW9uSWQsIGRvbid0IHJlc2V0IHRoZSBtc2dTZXJpYWwgYXMgaXQgbWF5IGhhdmVcblx0XHQgKiBiZWVuIHNldCBieSByZWNvdmVyIGRhdGEgKHVubGVzcyB0aGUgcmVjb3ZlciBmYWlsZWQpICovXG5cdFx0dmFyIHByZXZDb25uSWQgPSB0aGlzLmNvbm5lY3Rpb25pZCxcblx0XHRcdGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIChwcmV2Q29ubklkICE9PSBjb25uZWN0aW9uSWQpLFxuXHRcdFx0cmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG5cdFx0aWYoY29ubklkQ2hhbmdlZCB8fCByZWNvdmVyRmFpbHVyZSkgIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnUmVzZXR0aW5nIG1zZ1NlcmlhbCcpO1xuXHRcdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdH1cblx0XHQvKiBidXQgZG8gbmVlZCB0byByZWF0dGFjaCBjaGFubmVscywgZm9yIGNoYW5uZWxzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluXG5cdFx0ICogdGhlIGF0dGFjaGVkIHN0YXRlIGV2ZW4gdGhvdWdoIHRoZSBjb25uZWN0aW9uIG1vZGUgd2FzICdjbGVhbicgZHVlIHRvIGFcblx0XHQgKiBmcmVzaG5lc3MgY2hlY2sgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMzk0ICovXG5cdFx0aWYodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkgIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnTmV3IGNvbm5lY3Rpb25JZDsgcmVhdHRhY2hpbmcgYW55IGF0dGFjaGVkIGNoYW5uZWxzJyk7XG5cdFx0XHQvKiBXYWl0IHRpbGwgbmV4dCB0aWNrIGJlZm9yZSByZWF0dGFjaGluZyBjaGFubmVscywgc28gdGhhdCBjb25uZWN0aW9uXG5cdFx0XHQgKiBzdGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYW5kIHNvIHRoYXQgaXQgd2lsbCBiZSBhcHBsaWVkIGFmdGVyXG5cdFx0XHQgKiBDaGFubmVscyNvblRyYW5zcG9ydFVwZGF0ZSwgZWxzZSBjaGFubmVscyB3aWxsIG5vdCBoYXZlIGFuIEFUVEFDSEVEXG5cdFx0XHQgKiBzZW50IHR3aWNlIChvbmNlIGZyb20gdGhpcyBhbmQgb25jZSBmcm9tIHRoYXQpLiAqL1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZWFsdGltZS5jaGFubmVscy5yZWF0dGFjaCgpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmKHRoaXMub3B0aW9ucy5jaGVja0NoYW5uZWxzT25SZXN1bWUpIHtcblx0XHRcdC8qIEZvciBhdHRhY2hlZCBjaGFubmVscywgc2V0IHRoZSBhdHRhY2hlZCBtc2cgaW5kaWNhdG9yIHZhcmlhYmxlIHRvIGZhbHNlLFxuXHRcdFx0ICogd2FpdCAzMHMsIGFuZCBjaGVjayB3ZSBnb3QgYW4gYXR0YWNoZWQgZm9yIGVhY2ggb25lLlxuXHRcdFx0ICogMzBzIHdhcyBjaG9zZW4gdG8gYmUgNXMgbG9uZ2VyIHRoYW4gdGhlIHRyYW5zcG9ydCBpZGxlIHRpbWVvdXQgZXhwaXJlXG5cdFx0XHQgKiB0aW1lLCBpbiBhbiBhdHRlbXB0IHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyBkdWUgdG8gYSB0cmFuc3BvcnRcblx0XHRcdCAqIHNpbGVudGx5IGZhaWxpbmcgaW1tZWRpYXRlbHkgYWZ0ZXIgYSByZXN1bWUgKi9cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnU2FtZSBjb25uZWN0aW9uSWQ7IGNoZWNrQ2hhbm5lbHNPblJlc3VtZSBpcyBlbmFibGVkJyk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5jaGFubmVsUmVzdW1lQ2hlY2tUaW1lcik7XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnJlc2V0QXR0YWNoZWRNc2dJbmRpY2F0b3JzKCk7XG5cdFx0XHR0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5yZWFsdGltZS5jaGFubmVscy5jaGVja0F0dGFjaGVkTXNnSW5kaWNhdG9ycyhjb25uZWN0aW9uSWQpO1xuXHRcdFx0fSwgMzAwMDApO1xuXHRcdH1cblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcblx0XHR2YXIgZm9yY2VSZXNldE1lc3NhZ2VTZXJpYWwgPSBjb25uSWRDaGFuZ2VkIHx8ICFwcmV2Q29ubklkO1xuXHRcdHRoaXMuc2V0Q29ubmVjdGlvblNlcmlhbChjb25uZWN0aW9uUG9zaXRpb24sIGZvcmNlUmVzZXRNZXNzYWdlU2VyaWFsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvblNlcmlhbCgpO1xuXHRcdHRoaXMubXNnU2VyaWFsID0gMDtcblx0XHR0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcblx0fTtcblxuXHQvKiBmb3JjZTogc2V0IHRoZSBjb25uZWN0aW9uU2VyaWFsIGV2ZW4gaWYgaXQncyBsZXNzIHRoYW4gdGhlIGN1cnJlbnRcblx0ICogY29ubmVjdGlvblNlcmlhbC4gVXNlZCBmb3IgbmV3IGNvbm5lY3Rpb25zLlxuXHQgKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBtZXNzYWdlIHdhcyByZWplY3RlZCBhcyBhIGR1cGxpY2F0ZS4gKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb25TZXJpYWwgPSBmdW5jdGlvbihjb25uZWN0aW9uUG9zaXRpb24sIGZvcmNlKSB7XG5cdFx0dmFyIHRpbWVTZXJpYWwgPSBjb25uZWN0aW9uUG9zaXRpb24udGltZVNlcmlhbCxcblx0XHRcdGNvbm5lY3Rpb25TZXJpYWwgPSBjb25uZWN0aW9uUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbDtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ1VwZGF0aW5nIGNvbm5lY3Rpb24gc2VyaWFsOyBzZXJpYWwgPSAnICsgY29ubmVjdGlvblNlcmlhbCArICc7IHRpbWVTZXJpYWwgPSAnICsgdGltZVNlcmlhbCArICc7IGZvcmNlID0gJyArIGZvcmNlICsgJzsgcHJldmlvdXMgPSAnICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsKTtcblx0XHRpZih0aW1lU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHRpbWVTZXJpYWwgPD0gdGhpcy50aW1lU2VyaWFsICYmICFmb3JjZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2Ugd2l0aCB0aW1lU2VyaWFsICcgKyB0aW1lU2VyaWFsICsgJywgYnV0IGN1cnJlbnQgdGltZVNlcmlhbCBpcyAnICsgdGhpcy50aW1lU2VyaWFsICsgJzsgYXNzdW1pbmcgbWVzc2FnZSBpcyBhIGR1cGxpY2F0ZSBhbmQgZGlzY2FyZGluZyBpdCcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsID0gdGltZVNlcmlhbDtcblx0XHRcdHRoaXMuc2V0UmVjb3ZlcnlLZXkoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZihjb25uZWN0aW9uU2VyaWFsIDw9IHRoaXMuY29ubmVjdGlvblNlcmlhbCAmJiAhZm9yY2UpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb25TZXJpYWwoKScsICdyZWNlaXZlZCBtZXNzYWdlIHdpdGggY29ubmVjdGlvblNlcmlhbCAnICsgY29ubmVjdGlvblNlcmlhbCArICcsIGJ1dCBjdXJyZW50IGNvbm5lY3Rpb25TZXJpYWwgaXMgJyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCArICc7IGFzc3VtaW5nIG1lc3NhZ2UgaXMgYSBkdXBsaWNhdGUgYW5kIGRpc2NhcmRpbmcgaXQnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblNlcmlhbDtcblx0XHRcdHRoaXMuc2V0UmVjb3ZlcnlLZXkoKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyQ29ubmVjdGlvblNlcmlhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5zZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnRpbWVTZXJpYWwgPSB0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGVhclJlY292ZXJ5S2V5KCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFJlY292ZXJ5S2V5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ICsgJzonICsgKHRoaXMudGltZVNlcmlhbCB8fCB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpICsgJzonICsgdGhpcy5tc2dTZXJpYWw7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyUmVjb3ZlcnlLZXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXkgPSBudWxsO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKCF0aGlzLmxhc3RBY3Rpdml0eSB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgc2luY2VMYXN0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5O1xuXHRcdGlmKHNpbmNlTGFzdCA+IHRoaXMuY29ubmVjdGlvblN0YXRlVHRsICsgdGhpcy5tYXhJZGxlSW50ZXJ2YWwpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpJywgJ0xhc3Qga25vd24gYWN0aXZpdHkgZnJvbSByZWFsdGltZSB3YXMgJyArIHNpbmNlTGFzdCArICdtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZScpO1xuXHRcdFx0dGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcblx0XHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ3N1c3BlbmRlZCc7XG5cdFx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcblx0ICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wZXJzaXN0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKGhhdmVTZXNzaW9uU3RvcmFnZSkge1xuXHRcdFx0dmFyIHJlY292ZXJ5S2V5ID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5O1xuXHRcdFx0aWYocmVjb3ZlcnlLZXkpIHtcblx0XHRcdFx0c2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcblx0XHRcdFx0XHRyZWNvdmVyeUtleTogcmVjb3ZlcnlLZXksXG5cdFx0XHRcdFx0ZGlzY29ubmVjdGVkQXQ6IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCksXG5cdFx0XHRcdFx0bG9jYXRpb246IGdsb2JhbC5sb2NhdGlvbixcblx0XHRcdFx0XHRjbGllbnRJZDogdGhpcy5yZWFsdGltZS5hdXRoLmNsaWVudElkXG5cdFx0XHRcdH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuXHQgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0XHRjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKipcblx0ICogc3RhdGUgbWFuYWdlbWVudFxuXHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVycm9yUmVhc29uIHx8IHRoaXMuZ2V0U3RhdGVFcnJvcigpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0ZUVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bdGhpcy5zdGF0ZS5zdGF0ZV07XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUucXVldWVFdmVudHMgfHwgdGhpcy5zdGF0ZS5zZW5kRXZlbnRzO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmFjdFN0YXRlQ2hhbmdlID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHR2YXIgbG9nTGV2ZWwgPSBzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJyA/IF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiA6IF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24obG9nTGV2ZWwsICdDb25uZWN0aW9uIHN0YXRlJywgc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyAoJzsgcmVhc29uOiAnICsgc3RhdGVDaGFuZ2UucmVhc29uKSA6ICcnKSk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmVuYWN0U3RhdGVDaGFuZ2UnLCAnc2V0dGluZyBuZXcgc3RhdGU6ICcgKyBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgJzsgcmVhc29uID0gJyArIChzdGF0ZUNoYW5nZS5yZWFzb24gJiYgc3RhdGVDaGFuZ2UucmVhc29uLm1lc3NhZ2UpKTtcblx0XHR2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVDaGFuZ2UuY3VycmVudF07XG5cdFx0aWYoc3RhdGVDaGFuZ2UucmVhc29uKSB7XG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gc3RhdGVDaGFuZ2UucmVhc29uO1xuXHRcdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gc3RhdGVDaGFuZ2UucmVhc29uO1xuXHRcdH1cblx0XHRpZihuZXdTdGF0ZS50ZXJtaW5hbCB8fCBuZXdTdGF0ZS5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdC8qIHN1c3BlbmRlZCBpcyBub250ZXJtaW5hbCwgYnV0IG9uY2UgaW4gdGhlIHN1c3BlbmRlZCBzdGF0ZSwgcmVhbHRpbWVcblx0XHRcdCAqIHdpbGwgaGF2ZSBkaXNjYXJkZWQgb3VyIGNvbm5lY3Rpb24gc3RhdGUsIHNvIGZ1dGhlciBjb25uZWN0aW9uXG5cdFx0XHQgKiBhdHRlbXB0cyBzaG91bGQgc3RhcnQgZnJvbSBzY3JhdGNoICovXG5cdFx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuXHRcdH1cblx0XHR0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25zdGF0ZScsIHN0YXRlQ2hhbmdlKTtcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBDb25uZWN0aW9uTWFuYWdlciBjb25uZWN0aW9uIGxpZmVjeWNsZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRUcmFuc2l0aW9uVGltZXIgPSBmdW5jdGlvbih0cmFuc2l0aW9uU3RhdGUpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICd0cmFuc2l0aW9uU3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUpO1xuXG5cdFx0aWYodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ2NsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lcicpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy50cmFuc2l0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoc2VsZi50cmFuc2l0aW9uVGltZXIpIHtcblx0XHRcdFx0c2VsZi50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgJyArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSArICcgdGltZXIgZXhwaXJlZCcsICdyZXF1ZXN0aW5nIG5ldyBzdGF0ZTogJyArIHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGUpO1xuXHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZX0pO1xuXHRcdFx0fVxuXHRcdH0sIHRyYW5zaXRpb25TdGF0ZS5yZXRyeURlbGF5KTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsVHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpJywgJycpO1xuXHRcdGlmKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRTdXNwZW5kVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoc2VsZi5zdXNwZW5kVGltZXIpIHtcblx0XHRcdFx0c2VsZi5zdXNwZW5kVGltZXIgPSBudWxsO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgc3VzcGVuZCB0aW1lciBleHBpcmVkJywgJ3JlcXVlc3RpbmcgbmV3IHN0YXRlOiBzdXNwZW5kZWQnKTtcblx0XHRcdFx0c2VsZi5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcblx0XHRcdFx0c2VsZi5zdGF0ZXMuY29ubmVjdGluZy5xdWV1ZUV2ZW50cyA9IGZhbHNlO1xuXHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ3N1c3BlbmRlZCd9KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrU3VzcGVuZFRpbWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRpZihzdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgc3RhdGUgIT09ICdzdXNwZW5kZWQnICYmIHN0YXRlICE9PSAnY29ubmVjdGluZycpXG5cdFx0XHR0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxTdXNwZW5kVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuXHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcucXVldWVFdmVudHMgPSB0cnVlO1xuXHRcdGlmKHRoaXMuc3VzcGVuZFRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5zdXNwZW5kVGltZXIpO1xuXHRcdFx0dGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkJywgJ3JldHJ5aW5nJyk7XG5cdFx0XHRzZWxmLnJldHJ5VGltZXIgPSBudWxsO1xuXHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHR9LCBpbnRlcnZhbCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLnJldHJ5VGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuXHRcdFx0dGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vdGlmeVN0YXRlID0gZnVuY3Rpb24oaW5kaWNhdGVkKSB7XG5cdFx0dmFyIHN0YXRlID0gaW5kaWNhdGVkLnN0YXRlLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHQvKiBXZSByZXRyeSBpbW1lZGlhdGVseSBpZjpcblx0XHQgKiAtIHNvbWV0aGluZyBkaXNjb25uZWN0cyB1cyB3aGlsZSB3ZSdyZSBjb25uZWN0ZWQsIG9yXG5cdFx0ICogLSBhIHZpYWJsZSAoYnV0IG5vdCB5ZXQgYWN0aXZlKSB0cmFuc3BvcnQgZmFpbHMgZHVlIHRvIGEgdG9rZW4gZXJyb3IgKHNvXG5cdFx0ICogICB0aGlzLmVycm9yUmVhc29uIHdpbGwgYmUgc2V0LCBhbmQgc3RhcnRDb25uZWN0IHdpbGwgZG8gYSBmb3JjZWRcblx0XHQgKiAgIGF1dGhvcml6ZSkuIElmIHRoaXMuZXJyb3JSZWFzb24gaXMgYWxyZWFkeSBzZXQgKHRvIGEgdG9rZW4gZXJyb3IpLFxuXHRcdCAqICAgdGhlbiB0aGVyZSBoYXMgYmVlbiBhdCBsZWFzdCBvbmUgcHJldmlvdXMgYXR0ZW1wdCB0byBjb25uZWN0IHRoYXQgYWxzb1xuXHRcdCAqICAgZmFpbGVkIGZvciBhIHRva2VuIGVycm9yLCBzbyBieSBSVE4xNGIgd2UgZ28gdG8gRElTQ09OTkVDVEVEIGFuZCB3YWl0XG5cdFx0ICogICBiZWZvcmUgdHJ5aW5nIGFnYWluICovXG5cdFx0dmFyIHJldHJ5SW1tZWRpYXRlbHkgPSAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmXG5cdFx0XHQodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkICAgICB8fFxuXHRcdFx0IHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgfHxcblx0XHRcdCBpbmRpY2F0ZWQucmV0cnlJbW1lZGlhdGVseSAgICAgICAgICAgICAgIHx8XG5cdFx0XHRcdCh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nICYmXG5cdFx0XHRcdFx0aW5kaWNhdGVkLmVycm9yICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKGluZGljYXRlZC5lcnJvcikgJiZcblx0XHRcdFx0XHQhKHRoaXMuZXJyb3JSZWFzb24gJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpKSkpO1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnbmV3IHN0YXRlOiAnICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/ICc7IHdpbGwgcmV0cnkgY29ubmVjdGlvbiBpbW1lZGlhdGVseScgOiAnJykpO1xuXHRcdC8qIGRvIG5vdGhpbmcgaWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgaW5kaWNhdGVkIHN0YXRlICovXG5cdFx0aWYoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcblx0XHRcdHJldHVybjtcblxuXHRcdC8qIGtpbGwgdGltZXJzIChwb3NzaWJseSBleGNlcHRpbmcgc3VzcGVuZCB0aW1lciBkZXBlbmRpbmcgb24gdGhlIG5vdGlmaWVkXG5cdFx0KiBzdGF0ZSksIGFzIHRoZXNlIGFyZSBzdXBlcnNlZGVkIGJ5IHRoaXMgbm90aWZpY2F0aW9uICovXG5cdFx0dGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcblx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcblx0XHR0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKGluZGljYXRlZC5zdGF0ZSk7XG5cblx0XHQvKiBkbyBub3RoaW5nIGlmIHdlJ3JlIHVuYWJsZSB0byBtb3ZlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgKi9cblx0XHRpZih0aGlzLnN0YXRlLnRlcm1pbmFsKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0LyogcHJvY2VzcyBuZXcgc3RhdGUgKi9cblx0XHR2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tpbmRpY2F0ZWQuc3RhdGVdLFxuXHRcdFx0Y2hhbmdlID0gbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0odGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIG5ld1N0YXRlLnJldHJ5RGVsYXksIChpbmRpY2F0ZWQuZXJyb3IgfHwgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXVtuZXdTdGF0ZS5zdGF0ZV0pKTtcblxuXHRcdGlmKHJldHJ5SW1tZWRpYXRlbHkpIHtcblx0XHRcdHZhciBhdXRvUmVjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xuXHRcdFx0XHRcdHNlbGYubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKTtcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIChfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxKTtcblx0XHRcdGlmKHNpbmNlTGFzdCAmJiAoc2luY2VMYXN0IDwgMTAwMCkpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnTGFzdCByZWNvbm5lY3QgYXR0ZW1wdCB3YXMgb25seSAnICsgc2luY2VMYXN0ICsgJ21zIGFnbywgd2FpdGluZyBhbm90aGVyICcgKyAoMTAwMCAtIHNpbmNlTGFzdCkgKyAnbXMgYmVmb3JlIHRyeWluZyBhZ2FpbicpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDEwMDAgLSBzaW5jZUxhc3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhhdXRvUmVjb25uZWN0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0dGhpcy5zdGFydFJldHJ5VGltZXIobmV3U3RhdGUucmV0cnlEZWxheSk7XG5cdFx0fVxuXG5cdFx0IC8qIElmIGdvaW5nIGludG8gZGlzY29ubmVjdC9zdXNwZW5kZWQgKGFuZCBub3QgcmV0cnlpbmcgaW1tZWRpYXRlbHkpLCBvciBhXG5cdFx0XHQqIHRlcm1pbmFsIHN0YXRlLCBlbnN1cmUgdGhlcmUgYXJlIG5vIG9ycGhhbmVkIHRyYW5zcG9ydHMgaGFuZ2luZyBhcm91bmQuICovXG5cdFx0aWYoKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiAhcmV0cnlJbW1lZGlhdGVseSkgfHxcblx0XHRcdCAoc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB8fFxuXHRcdFx0IG5ld1N0YXRlLnRlcm1pbmFsKSB7XG5cdFx0XHRcdCAvKiBXYWl0IHRpbGwgdGhlIG5leHQgdGljayBzbyB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2UgaXMgZW5hY3RlZCxcblx0XHRcdFx0ICogc28gYWJvcnRpbmcgdHJhbnNwb3J0cyBkb2Vzbid0IHRyaWdnZXIgcmVkdW5kYW50IHN0YXRlIGNoYW5nZXMgKi9cblx0XHRcdFx0IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0IHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0IH0pO1xuXHRcdCB9XG5cblx0XHRpZihzdGF0ZSA9PSAnY29ubmVjdGVkJyAmJiAhdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnQnJva2VuIGludmFyaWFudDogYXR0ZW1wdGVkIHRvIGdvIGludG8gY29ubmVjdGVkIHN0YXRlLCBidXQgdGhlcmUgaXMgbm8gYWN0aXZlIHByb3RvY29sJyk7XG5cdFx0fVxuXG5cdFx0LyogaW1wbGVtZW50IHRoZSBjaGFuZ2UgYW5kIG5vdGlmeSAqL1xuXHRcdHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuXHRcdGlmKHRoaXMuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0dGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcblx0XHR9IGVsc2UgaWYoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbihzdGF0ZSwgY2hhbmdlLnJlYXNvbik7XG5cdFx0XHR0aGlzLmZhaWxRdWV1ZWRNZXNzYWdlcyhjaGFuZ2UucmVhc29uKTsgLy8gUlRON2Ncblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RTdGF0ZSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcblx0XHR2YXIgc3RhdGUgPSByZXF1ZXN0LnN0YXRlLCBzZWxmID0gdGhpcztcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKCknLCAncmVxdWVzdGVkIHN0YXRlOiAnICsgc3RhdGUgKyAnOyBjdXJyZW50IHN0YXRlOiAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG5cdFx0aWYoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcblx0XHRcdHJldHVybjsgLyogc2lsZW50bHkgZG8gbm90aGluZyAqL1xuXG5cdFx0Lyoga2lsbCBydW5uaW5nIHRpbWVycywgYXMgdGhpcyByZXF1ZXN0IHN1cGVyc2VkZXMgdGhlbSAqL1xuXHRcdHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG5cdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG5cdFx0LyogZm9yIHN1c3BlbmQgdGltZXIgY2hlY2sgcmF0aGVyIHRoYW4gY2FuY2VsIC0tIGVnIHJlcXVlc3RpbmcgYSBjb25uZWN0aW5nXG5cdFx0KiBzdGF0ZSBzaG91bGQgbm90IHJlc2V0IHRoZSBzdXNwZW5kIHRpbWVyICovXG5cdFx0dGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG5cblx0XHRpZihzdGF0ZSA9PSAnY29ubmVjdGluZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY29ubmVjdGVkJykgcmV0dXJuO1xuXHRcdGlmKHN0YXRlID09ICdjbG9zaW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjbG9zZWQnKSByZXR1cm47XG5cblx0XHR2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sXG5cdFx0XHRjaGFuZ2UgPSBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXSh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgbnVsbCwgKHJlcXVlc3QuZXJyb3IgfHwgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXVtuZXdTdGF0ZS5zdGF0ZV0pKTtcblxuXHRcdHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xuXG5cdFx0aWYoc3RhdGUgPT0gJ2Nvbm5lY3RpbmcnKSB7XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLnN0YXJ0Q29ubmVjdCgpOyB9KTtcblx0XHR9XG5cdFx0aWYoc3RhdGUgPT0gJ2Nsb3NpbmcnKSB7XG5cdFx0XHR0aGlzLmNsb3NlSW1wbCgpO1xuXHRcdH1cblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydENvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBhdXRoID0gdGhpcy5yZWFsdGltZS5hdXRoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHQvKiBUaGUgcG9pbnQgb2YgdGhlIGNvbm5lY3RDb3VudGVyIG1lY2hhbmlzbSBpcyB0byBlbnN1cmUgdGhhdCB0aGVcblx0XHQgKiBjb25uZWN0aW9uIHByb2NlZHVyZSBjYW4gYmUgY2FuY2VsbGVkLiBXZSB3YW50IGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzXG5cdFx0ICogdG8gYmUgYWJsZSB0byBzdG9wIGFueSBpbi1wcm9ncmVzcyBjb25uZWN0aW9uLCBldmVuIGJlZm9yZSBpdCBnZXRzIHRvXG5cdFx0ICogdGhlIHN0YWdlIG9mIGhhdmluZyBhIHBlbmRpbmcgKG9yIGV2ZW4gYSBwcm9wb3NlZCkgdHJhbnNwb3J0IHRoYXQgaXQgY2FuXG5cdFx0ICogZGlzcG9zZSgpIG9mLiBTbyB3ZSBjaGVjayB0aGF0IGl0J3Mgc3RpbGwgY3VycmVudCBhZnRlciBhbnkgYXN5bmMgc3RhZ2UsXG5cdFx0ICogdXAgdW50aWwgdGhlIHN0YWdlIHRoYXQgaXMgc3luY2hyb25vdXMgd2l0aCBpbnN0YW50aWF0aW5nIGEgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGNvbm5lY3RDb3VudCA9ICsrdGhpcy5jb25uZWN0Q291bnRlcjtcblxuXHRcdHZhciBjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XG5cdFx0XHRzZWxmLmdldFRyYW5zcG9ydFBhcmFtcyhmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdzdGFydGluZyBjb25uZWN0aW9uJyk7XG5cdFx0dGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuXHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY29ubmVjdGluZyk7XG5cblx0XHRpZihhdXRoLm1ldGhvZCA9PT0gJ2Jhc2ljJykge1xuXHRcdFx0Y29ubmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYXV0aENiID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGNvbm5lY3RDb3VudCAhPT0gc2VsZi5jb25uZWN0Q291bnRlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29ubmVjdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0aWYodGhpcy5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkge1xuXHRcdFx0XHQvKiBGb3JjZSBhIHJlZmV0Y2ggb2YgYSBuZXcgdG9rZW4gKi9cblx0XHRcdFx0YXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBhdXRoQ2IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGF1dGhDYik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGVyZSBhcmUgdGhyZWUgc3RhZ2VzIGluIGNvbm5lY3Rpbmc6XG5cdCAqIC0gcHJlZmVyZW5jZTogaWYgdGhlcmUgaXMgYSBjYWNoZWQgdHJhbnNwb3J0IHByZWZlcmVuY2UsIHdlIHRyeSB0byBjb25uZWN0XG5cdCAqICAgb24gdGhhdC4gSWYgdGhhdCBmYWlscyBvciB0aW1lcyBvdXQgd2UgYWJvcnQgdGhlIGF0dGVtcHQsIHJlbW92ZSB0aGVcblx0ICogICBwcmVmZXJlbmNlIGFuZCBmYWxsIGJhY2sgdG8gYmFzZS4gSWYgaXQgc3VjY2VlZHMsIHdlIHRyeSB1cGdyYWRpbmcgaXQgaWZcblx0ICogICBuZWVkZWQgKHdpbGwgb25seSBiZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgcHJlZmVyZW5jZSBpcyB4aHJzIGFuZCB0aGVcblx0ICogICBicm93c2VyIHN1cHBvcnRzIHdzKS5cblx0ICogLSBiYXNlOiB3ZSB0cnkgdG8gY29ubmVjdCB3aXRoIHRoZSBiZXN0IHRyYW5zcG9ydCB0aGF0IHdlIHRoaW5rIHdpbGxcblx0ICogICBuZXZlciBmYWlsIGZvciB0aGlzIGJyb3dzZXIgKHVzdWFsbHkgdGhpcyBpcyB4aHJfcG9sbGluZzsgZm9yIHZlcnkgb2xkXG5cdCAqICAgYnJvd3NlcnMgd2lsbCBiZSBqc29ucCwgZm9yIG5vZGUgd2lsbCBiZSBjb21ldCkuIElmIGl0IGRvZXNuJ3Qgd29yaywgd2Vcblx0ICogICB0cnkgZmFsbGJhY2sgaG9zdHMuXG5cdCAqIC0gdXBncmFkZTogZ2l2ZW4gYSBjb25uZWN0ZWQgdHJhbnNwb3J0LCB3ZSBzZWUgaWYgdGhlcmUgYXJlIGFueSBiZXR0ZXJcblx0ICogICBvbmVzLCBhbmQgaWYgc28sIHRyeSB0byB1cGdyYWRlIHRvIHRoZW0uXG5cdCAqXG5cdCAqIGNvbm5lY3RJbXBsIHdvcmtzIG91dCB3aGF0IHN0YWdlIHlvdSdyZSBhdCAod2hpY2ggaXMgcHVyZWx5IGEgZnVuY3Rpb24gb2Zcblx0ICogdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBhbmQgd2hldGhlciB0aGVyZSBhcmUgYW55IHN0b3JlZCBwcmVmZXJlbmNlcyksXG5cdCAqIGFuZCBkaXNwYXRjaGVzIGFjY29yZGluZ2x5LiBBZnRlciBhIHRyYW5zcG9ydCBoYXMgYmVlbiBzZXQgcGVuZGluZyxcblx0ICogdHJ5QVRyYW5zcG9ydCBjYWxscyBjb25uZWN0SW1wbCB0byBzZWUgaWYgdGhlcmUncyBhbm90aGVyIHN0YWdlIHRvIGJlIGRvbmUuXG5cdCAqICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0SW1wbCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5zdGF0ZTtcblxuXHRcdGlmKHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnN0YXRlICYmIHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdC8qIE9ubHkga2VlcCB0cnlpbmcgYXMgbG9uZyBhcyBpbiB0aGUgJ2Nvbm5lY3RpbmcnIHN0YXRlIChvciAnY29ubmVjdGVkJ1xuXHRcdFx0ICogZm9yIHVwZ3JhZGluZykuIEFueSBvcGVyYXRpb24gY2FuIHB1dCB1cyBpbnRvICdkaXNjb25uZWN0ZWQnIHRvIGNhbmNlbFxuXHRcdFx0ICogY29ubmVjdGlvbiBhdHRlbXB0cyBhbmQgd2FpdCBiZWZvcmUgcmV0cnlpbmcsIG9yICdmYWlsZWQnIHRvIGZhaWwuICovXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKScsICdNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCAob3IgY29ubmVjdGVkIHRvIHVwZ3JhZGUpLCBidXQgd2FzICcgKyBzdGF0ZSk7XG5cdFx0fSBlbHNlIGlmKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKScsICdUcmFuc3BvcnRzICcgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzWzBdLnRvU3RyaW5nKCkgKyAnIGN1cnJlbnRseSBwZW5kaW5nOyB0YWtpbmcgbm8gYWN0aW9uJyk7XG5cdFx0fSBlbHNlIGlmKHN0YXRlID09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuXHRcdFx0dGhpcy51cGdyYWRlSWZOZWVkZWQodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9IGVsc2UgaWYodGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiYgdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkpIHtcblx0XHRcdHRoaXMuY29ubmVjdFByZWZlcmVuY2UodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RQcmVmZXJlbmNlID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIHByZWZlcmVuY2UgPSB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0cHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gZmFsc2U7XG5cblx0XHRpZighX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbih0aGlzLnRyYW5zcG9ydHMsIHByZWZlcmVuY2UpKSB7XG5cdFx0XHR0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblx0XHRcdHRoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFByZWZlcmVuY2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIHN0b3JlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSAnICsgcHJlZmVyZW5jZSk7XG5cblx0XHR2YXIgcHJlZmVyZW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0cHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcblx0XHRcdGlmKCEoc2VsZi5zdGF0ZS5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFByZWZlcmVuY2UoKScsICdTaG9ydGNpcmN1aXQgY29ubmVjdGlvbiBhdHRlbXB0IHdpdGggJyArIHByZWZlcmVuY2UgKyAnIGZhaWxlZDsgY2xlYXJpbmcgcHJlZmVyZW5jZSBhbmQgdHJ5aW5nIGZyb20gc2NyYXRjaCcpO1xuXHRcdFx0XHQvKiBBYm9ydCBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cy4gKFRoaXMgYWxzbyBkaXNjb25uZWN0cyB0aGUgYWN0aXZlXG5cdFx0XHRcdCAqIHByb3RvY29sLCBidXQgbm9uZSBleGlzdHMgaWYgd2UncmUgbm90IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUpICovXG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0LyogQmUgcXVpdGUgYWdyZXNzaXZlIGFib3V0IGNsZWFyaW5nIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSBpZiBldmVyIGl0IGRvZXNuJ3Qgd29yayAqL1xuXHRcdFx0XHRzZWxmLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9LCB0aGlzLm9wdGlvbnMudGltZW91dHMucHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0KTtcblxuXHRcdC8qIEZvciBjb25uZWN0UHJlZmVyZW5jZSwganVzdCB1c2UgdGhlIG1haW4gaG9zdC4gSWYgaG9zdCBmYWxsYmFjayBpcyBuZWVkZWQsIGRvIGl0IGluIGNvbm5lY3RCYXNlLlxuXHRcdCAqIFRoZSB3c3RyYW5zcG9ydCBpdCB3aWxsIHN1YnN0aXR1dGUgdGhlIGh0dHBob3N0IGZvciBhbiBhcHByb3ByaWF0ZSB3c2hvc3QgKi9cblx0XHR0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IHNlbGYuaHR0cEhvc3RzWzBdO1xuXHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHByZWZlcmVuY2UsIGZ1bmN0aW9uKGZhdGFsLCB0cmFuc3BvcnQpIHtcblx0XHRcdGNsZWFyVGltZW91dChwcmVmZXJlbmNlVGltZW91dCk7XG5cdFx0XHRpZihwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgJiYgdHJhbnNwb3J0KSB7XG5cdFx0XHRcdC8qIFZpYWJsZSwgYnV0IHRvbyBsYXRlIC0gY29ubmVjdEltcGwoKSB3aWxsIGFscmVhZHkgYmUgdHJ5aW5nXG5cdFx0XHRcdCogY29ubmVjdEJhc2UsIGFuZCB3ZSB3ZXJlbid0IGluIHVwZ3JhZGUgbW9kZS4gSnVzdCByZW1vdmUgdGhlXG5cdFx0XHRcdCogb25jb25uZWN0ZWQgbGlzdGVuZXIgYW5kIGdldCByaWQgb2YgaXQgKi9cblx0XHRcdFx0dHJhbnNwb3J0Lm9mZigpO1xuXHRcdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9IGVsc2UgaWYoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcblx0XHRcdFx0LyogUHJlZmVyZW5jZSBmYWlsZWQgaW4gYSB0cmFuc3BvcnQtc3BlY2lmaWMgd2F5LiBUcnkgbW9yZSAqL1xuXHRcdFx0XHRzZWxmLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblx0XHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0LyogSWYgc3VjZWVkZWQsIG9yIGZhaWxlZCBmYXRhbGx5LCBub3RoaW5nIHRvIGRvICovXG5cdFx0fSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogVHJ5IHRvIGVzdGFibGlzaCBhIHRyYW5zcG9ydCBvbiB0aGUgYmFzZSB0cmFuc3BvcnQgKHRoZSBiZXN0IHRyYW5zcG9ydFxuXHQgKiBzdWNoIHRoYXQgaWYgaXQgZG9lc24ndCB3b3JrLCBub3RoaW5nIHdpbGwgd29yaykgYXMgZGV0ZXJtaW5lZCB0aHJvdWdoXG5cdCAqIHN0YXRpYyBmZWF0dXJlIGRldGVjdGlvbiwgY2hlY2tpbmcgZm9yIG5ldHdvcmsgY29ubmVjdGl2aXR5IGFuZCB0cnlpbmdcblx0ICogZmFsbGJhY2sgaG9zdHMgaWYgYXBwbGljYWJsZS5cblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RCYXNlID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRnaXZlVXAgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6IHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogZXJyfSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2FuZGlkYXRlSG9zdHMgPSB0aGlzLmh0dHBIb3N0cy5zbGljZSgpLFxuXHRcdFx0aG9zdEF0dGVtcHRDYiA9IGZ1bmN0aW9uKGZhdGFsLCB0cmFuc3BvcnQpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG5cdFx0XHRcdFx0dHJ5RmFsbGJhY2tIb3N0cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RCYXNlKCknLCAnVHJ5aW5nIHRvIGNvbm5lY3Qgd2l0aCBiYXNlIHRyYW5zcG9ydCAnICsgdGhpcy5iYXNlVHJhbnNwb3J0KTtcblxuXHRcdC8qIGZpcnN0IHRyeSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHByaW9yaXR5IGhvc3Qgd2l0aCBodHRwIHRyYW5zcG9ydCAqL1xuXHRcdHZhciBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcblx0XHRpZighaG9zdCkge1xuXHRcdFx0Z2l2ZVVwKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpJywgODAwMDMsIDQwNCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IGhvc3Q7XG5cblx0XHQvKiB0aGlzIGlzIHdoYXQgd2UnbGwgYmUgZG9pbmcgaWYgdGhlIGF0dGVtcHQgZm9yIHRoZSBtYWluIGhvc3QgZmFpbHMgKi9cblx0XHRmdW5jdGlvbiB0cnlGYWxsYmFja0hvc3RzKCkge1xuXHRcdFx0LyogaWYgdGhlcmUgYXJlbid0IGFueSBmYWxsYmFjayBob3N0cywgZmFpbCAqL1xuXHRcdFx0aWYoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpJywgODAwMDMsIDQwNCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBiZWZvcmUgdHJ5aW5nIGFueSBmYWxsYmFjayAob3IgYW55IHJlbWFpbmluZyBmYWxsYmFjaykgd2UgZGVjaWRlIGlmXG5cdFx0XHQgKiB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgYWJseSBob3N0LCBvciB0aGVyZSBpcyBhIGdlbmVyYWwgY29ubmVjdGl2aXR5XG5cdFx0XHQgKiBwcm9ibGVtICovXG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWNrQ29ubmVjdGl2aXR5KGZ1bmN0aW9uKGVyciwgY29ubmVjdGl2aXR5KSB7XG5cdFx0XHRcdGlmKGNvbm5lY3RDb3VudCAhPT0gc2VsZi5jb25uZWN0Q291bnRlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiB3ZSBrbm93IGVyciB3b24ndCBoYXBwZW4gYnV0IGhhbmRsZSBpdCBoZXJlIGFueXdheSAqL1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRnaXZlVXAoZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWNvbm5lY3Rpdml0eSkge1xuXHRcdFx0XHRcdC8qIHRoZSBpbnRlcm5ldCBpc24ndCByZWFjaGFibGUsIHNvIGRvbid0IHRyeSB0aGUgZmFsbGJhY2sgaG9zdHMgKi9cblx0XHRcdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKScsIDgwMDAzLCA0MDQpKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogdGhlIG5ldHdvcmsgaXMgdGhlcmUsIHNvIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIG1haW4gaG9zdCwgb3Jcblx0XHRcdFx0ICogaXRzIGRucy4gVHJ5IHRoZSBmYWxsYmFjayBob3N0cy4gV2UgY291bGQgdHJ5IHRoZW0gc2ltdWx0YW5lb3VzbHkgYnV0XG5cdFx0XHRcdCAqIHRoYXQgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgYSBodWdlIHNwaWtlIGluIGxvYWQgb24gdGhlIGxvYWQgYmFsYW5jZXIgKi9cblx0XHRcdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyclBvcFJhbmRvbUVsZW1lbnQoY2FuZGlkYXRlSG9zdHMpO1xuXHRcdFx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBzZWxmLmJhc2VUcmFuc3BvcnQsIGhvc3RBdHRlbXB0Q2IpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcblx0XHRcdHRyeUZhbGxiYWNrSG9zdHMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0aGlzLmJhc2VUcmFuc3BvcnQsIGhvc3RBdHRlbXB0Q2IpO1xuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogcmV0dXJucyB0aGUgc3Vic2V0IG9mIHVwZ3JhZGVUcmFuc3BvcnRzIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxuXHRcdCAqIHRyYW5zcG9ydCBpbiB1cGdyYWRlVHJhbnNwb3J0cyAoaWYgaXQncyBpbiB0aGVyZSAtIGlmIG5vdCwgY3VycmVudFBvc2l0aW9uXG5cdFx0ICogd2lsbCBiZSAtMSwgc28gcmV0dXJuIHVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKDApID09IHVwZ3JhZGVUcmFuc3BvcnRzICovXG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnNob3J0TmFtZTtcblx0XHR2YXIgY3VycmVudFBvc2l0aW9uID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKHRoaXMudXBncmFkZVRyYW5zcG9ydHMsIGN1cnJlbnQpO1xuXHRcdHJldHVybiB0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKGN1cnJlbnRQb3NpdGlvbiArIDEpO1xuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZ3JhZGVJZk5lZWRlZCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdHZhciB1cGdyYWRlUG9zc2liaWxpdGllcyA9IHRoaXMuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMoKSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci51cGdyYWRlSWZOZWVkZWQoKScsICd1cGdyYWRlIHBvc3NpYmlsaXRpZXM6ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QodXBncmFkZVBvc3NpYmlsaXRpZXMpKTtcblxuXHRcdGlmKCF1cGdyYWRlUG9zc2liaWxpdGllcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2godXBncmFkZVBvc3NpYmlsaXRpZXMsIGZ1bmN0aW9uKHVwZ3JhZGVUcmFuc3BvcnQpIHtcblx0XHRcdC8qIE5vdGU6IHRoZSB0cmFuc3BvcnQgbWF5IG11dGF0ZSB0aGUgcGFyYW1zLCBzbyBnaXZlIGVhY2ggdHJhbnNwb3J0IGEgZnJlc2ggb25lICovXG5cdFx0XHR2YXIgdXBncmFkZVRyYW5zcG9ydFBhcmFtcyA9IHNlbGYuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKHRyYW5zcG9ydFBhcmFtcy5ob3N0LCAndXBncmFkZScpO1xuXHRcdFx0c2VsZi50cnlBVHJhbnNwb3J0KHVwZ3JhZGVUcmFuc3BvcnRQYXJhbXMsIHVwZ3JhZGVUcmFuc3BvcnQsIG5vb3ApO1xuXHRcdH0pO1xuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlSW1wbCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdjbG9zaW5nIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xuXHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY2xvc2luZyk7XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuY2xvc2UoKTtcblx0XHR9KTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Rpc3Bvc2luZyBvZiBwcm9wb3NlZCB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0aWYodGhpcy5hY3RpdmVQcm90b2NvbCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgYWN0aXZlIHRyYW5zcG9ydDogJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkpO1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5jbG9zZSgpO1xuXHRcdH1cblxuXHRcdC8qIElmIHRoZXJlIHdhcyBhbiBhY3RpdmUgdHJhbnNwb3J0LCB0aGlzIHdpbGwgcHJvYmFibHkgYmVcblx0XHQgKiBwcmVlbXB0ZWQgYnkgdGhlIG5vdGlmeVN0YXRlIGNhbGwgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xuXHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY2xvc2VkJ30pO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24odG9rZW5EZXRhaWxzLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzd2l0Y2godGhpcy5zdGF0ZS5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsICdTZW5kaW5nIEFVVEggbWVzc2FnZSBvbiBhY3RpdmUgdHJhbnNwb3J0Jyk7XG5cdFx0XHRcdC8qIElmIHRoZXJlIGFyZSBhbnkgcHJvcG9zZWQvcGVuZGluZyB0cmFuc3BvcnRzIChlZyBhbiB1cGdyYWRlIHRoYXRcblx0XHRcdFx0ICogaXNuJ3QgeWV0IHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbikgdGhhdCBoYXNuJ3QgeWV0IHN0YXJ0ZWQgc3luY2luZyxcblx0XHRcdFx0ICoganVzdCB0byBnZXQgcmlkIG9mIHRoZW0gJiByZXN0YXJ0IHRoZSB1cGdyYWRlIHdpdGggdGhlIG5ldyB0b2tlbiwgdG9cblx0XHRcdFx0ICogYXZvaWQgYSByYWNlIGNvbmRpdGlvbi4gKElmIGl0IGhhcyBzdGFydGVkIHN5bmNpbmcsIHRoZSBBVVRIIHdpbGwgYmVcblx0XHRcdFx0ICogcXVldWVkIHVudGlsIHRoZSB1cGdyYWRlIGlzIGNvbXBsZXRlLCBzbyBldmVyeXRoaW5nJ3MgZmluZSkgKi9cblx0XHRcdFx0aWYoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoIHx8IHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLmxlbmd0aCkgJiZcblx0XHRcdFx0XHRzZWxmLnN0YXRlICE9PSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygvKiBleGNlcHRBY3RpdmU6ICovdHJ1ZSk7XG5cdFx0XHRcdFx0dmFyIHRyYW5zcG9ydFBhcmFtcyA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkucGFyYW1zO1xuXHRcdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZihzZWxmLnN0YXRlLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnVwZ3JhZGVJZk5lZWRlZCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogRG8gYW55IHRyYW5zcG9ydC1zcGVjaWZpYyBuZXctdG9rZW4gYWN0aW9uICovXG5cdFx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMpO1xuXG5cdFx0XHRcdHZhciBhdXRoTXNnID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRcdGFjdGlvbjogYWN0aW9ucy5BVVRILFxuXHRcdFx0XHRcdGF1dGg6IHtcblx0XHRcdFx0XHRcdGFjY2Vzc1Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLnNlbmQoYXV0aE1zZyk7XG5cblx0XHRcdFx0LyogVGhlIGFuc3dlciB3aWxsIGNvbWUgYmFjayBhcyBlaXRoZXIgYSBjb25uZWN0aW9uZGV0YWlscyBldmVudFxuXHRcdFx0XHQgKiAocmVhbHRpbWUgc2VuZHMgYSBDT05ORUNURUQgdG8gYXNrbm93bGVkZ2UgdGhlIHJlYXV0aCkgb3IgYVxuXHRcdFx0XHQgKiBzdGF0ZWNoYW5nZSB0byBmYWlsZWQgKi9cblx0XHRcdFx0dmFyIHN1Y2Nlc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIGZhaWx1cmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0aWYoc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdFx0XHRcdHNlbGYub2ZmKHN1Y2Nlc3NMaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRzZWxmLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHNlbGYuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMub25jZSgnY29ubmVjdGlvbmRldGFpbHMnLCBzdWNjZXNzTGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmYWlsdXJlTGlzdGVuZXIpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnY29ubmVjdGluZyc6XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLFxuXHRcdFx0XHRcdCdBYm9ydGluZyBjdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHMgaW4gb3JkZXIgdG8gc3RhcnQgYWdhaW4gd2l0aCB0aGUgbmV3IGF1dGggZGV0YWlscycpO1xuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdC8qIGZhbGx0aHJvdWdoIHRvIGFkZCBzdGF0ZWNoYW5nZSBsaXN0ZW5lciAqL1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJyxcblx0XHRcdFx0XHQnQ29ubmVjdGlvbiBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICc7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQnKTtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRzd2l0Y2goc3RhdGVDaGFuZ2UuY3VycmVudCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnY29ubmVjdGVkJzpcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdjbG9zZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgc2VsZi5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8qIGlnbm9yZSB0aWxsIHdlIGdldCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCAqL1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHNlbGYub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGxpc3RlbmVyKTtcblx0XHRcdFx0aWYodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG5cdFx0XHRcdFx0LyogY2FuIGhhcHBlbiBpZiBpbiB0aGUgY29ubmVjdGluZyBzdGF0ZSBidXQgbm8gdHJhbnNwb3J0IHdhcyBwZW5kaW5nXG5cdFx0XHRcdFx0ICogeWV0LCBzbyBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cyBkaWQgbm90IHRyaWdnZXIgYSBkaXNjb25uZWN0ZWQgc3RhdGUgKi9cblx0XHRcdFx0XHRzZWxmLnN0YXJ0Q29ubmVjdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzID0gZnVuY3Rpb24oZXhjZXB0QWN0aXZlKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBhbGwgdHJhbnNwb3J0cycgKyAoZXhjZXB0QWN0aXZlID8gJyBleGNlcHQgdGhlIGFjdGl2ZSB0cmFuc3BvcnQnIDogJycpKTtcblxuXHRcdC8qIFRoaXMgd2lsbCBwcmV2ZW50IGFueSBjb25uZWN0aW9uIHByb2NlZHVyZSBpbiBhbiBhc3luYyBwYXJ0IG9mIG9uZSBvZiBpdHMgZWFybHkgc3RhZ2VzIGZyb20gY29udGludWluZyAqL1xuXHRcdHRoaXMuY29ubmVjdENvdW50ZXIrKztcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcblx0XHRcdGlmKHRyYW5zcG9ydCkgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHR9KTtcblx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzID0gW107XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc3Bvc2luZyBvZiBwcm9wb3NlZCB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzcG9zZSgpO1xuXHRcdH0pO1xuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG5cblx0XHRpZih0aGlzLmFjdGl2ZVByb3RvY29sICYmICFleGNlcHRBY3RpdmUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydDogJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkpO1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5kaXNjb25uZWN0KCk7XG5cdFx0fVxuXHRcdC8qIE5vIG5lZWQgdG8gbm90aWZ5IHN0YXRlIGRpc2Nvbm5lY3RlZDsgZGlzY29ubmVjdGluZyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuXHRcdCAqIHdpbGwgaGF2ZSB0aGF0IGVmZmVjdCAqL1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKipcblx0ICogZXZlbnQgcXVldWVpbmdcblx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZywgcXVldWVFdmVudCwgY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuXHRcdGlmKHN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAnc2VuZGluZyBldmVudCcpO1xuXHRcdFx0dGhpcy5zZW5kSW1wbChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc2hvdWxkUXVldWUgPSAocXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cykgfHwgc3RhdGUuZm9yY2VRdWV1ZUV2ZW50cztcblx0XHRpZighc2hvdWxkUXVldWUpIHtcblx0XHRcdHZhciBlcnIgPSAncmVqZWN0aW5nIGV2ZW50LCBxdWV1ZUV2ZW50IHdhcyAnICsgcXVldWVFdmVudCArICcsIHN0YXRlIHdhcyAnICsgc3RhdGUuc3RhdGU7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgZXJyKTtcblx0XHRcdGNhbGxiYWNrKHRoaXMuZXJyb3JSZWFzb24gfHwgbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oZXJyLCA5MDAwMCwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNob3VsZExvZyhfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgJ3F1ZXVlaW5nIG1zZzsgJyArIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdpZnkobXNnKSk7XG5cdFx0fVxuXHRcdHRoaXMucXVldWUobXNnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmRJbXBsID0gZnVuY3Rpb24ocGVuZGluZ01lc3NhZ2UpIHtcblx0XHR2YXIgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcblx0XHQvKiBJZiBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHNlbmQgdGhpcywgcmVzZW5kIHdpdGggdGhlIHNhbWUgbXNnU2VyaWFsLFxuXHRcdCAqIHNvIEFibHkgY2FuIGRlZHVwIGlmIHRoZSBwcmV2aW91cyBzZW5kIHN1Y2NlZWRlZCAqL1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkICYmICFwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkKSB7XG5cdFx0XHRtc2cubXNnU2VyaWFsID0gdGhpcy5tc2dTZXJpYWwrKztcblx0XHRcdHRoaXMuc2V0UmVjb3ZlcnlLZXkoKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuc2VuZChwZW5kaW5nTWVzc2FnZSk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZEltcGwoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBpbiB0cmFuc3BvcnQuc2VuZCgpOiAnICsgZS5zdGFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGJ1bmRsZVdpdGgoZGVzdCwgc3JjLCBtYXhTaXplKSB7XG5cdFx0dmFyIGFjdGlvbjtcblx0XHRpZihkZXN0LmNoYW5uZWwgIT09IHNyYy5jaGFubmVsKSB7XG5cdFx0XHQvKiBSVEw2ZDMgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSAhPT0gYWN0aW9ucy5QUkVTRU5DRSAmJiBhY3Rpb24gIT09IGFjdGlvbnMuTUVTU0FHRSkge1xuXHRcdFx0LyogUlRMNmQgLSBjYW4gb25seSBidW5kbGUgbWVzc2FnZXMgb3IgcHJlc2VuY2UgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYoYWN0aW9uICE9PSBzcmMuYWN0aW9uKSB7XG5cdFx0XHQvKiBSVEw2ZDQgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dmFyIGtpbmQgPSAoYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFKSA/ICdwcmVzZW5jZScgOiAnbWVzc2FnZXMnLFxuXHRcdFx0cHJvcG9zZWQgPSBkZXN0W2tpbmRdLmNvbmNhdChzcmNba2luZF0pLFxuXHRcdFx0c2l6ZSA9IF90eXBlc19tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldE1lc3NhZ2VzU2l6ZShwcm9wb3NlZCk7XG5cdFx0aWYoc2l6ZSA+IG1heFNpemUpIHtcblx0XHRcdC8qIFJUTDZkMSAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZighX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hbGxTYW1lKHByb3Bvc2VkLCAnY2xpZW50SWQnKSkge1xuXHRcdFx0LyogUlRMNmQyICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckV2ZXJ5KHByb3Bvc2VkLCBmdW5jdGlvbihtc2cpIHtcblx0XHRcdHJldHVybiAhbXNnLmlkO1xuXHRcdH0pKSB7XG5cdFx0XHQvKiBSVEw2ZDcgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Lyogd2UncmUgZ29vZCB0byBnbyEgKi9cblx0XHRkZXN0W2tpbmRdID0gcHJvcG9zZWQ7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24obXNnLCBjYWxsYmFjaykge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZSgpJywgJ3F1ZXVlaW5nIGV2ZW50Jyk7XG5cdFx0dmFyIGxhc3RRdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmxhc3QoKTtcblx0XHR2YXIgbWF4U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcblx0XHQvKiBJZiBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHNlbmQgYSBtZXNzYWdlLCBkb24ndCBtZXJnZSBtb3JlIG1lc3NhZ2VzXG5cdFx0ICogaW50byBpdCwgYXMgaWYgdGhlIHByZXZpb3VzIHNlbmQgYWN0dWFsbHkgc3VjY2VlZGVkIGFuZCByZWFsdGltZSBpZ25vcmVzXG5cdFx0ICogdGhlIGR1cCwgdGhleSdsbCBiZSBsb3N0ICovXG5cdFx0aWYobGFzdFF1ZXVlZCAmJiAhbGFzdFF1ZXVlZC5zZW5kQXR0ZW1wdGVkICYmIGJ1bmRsZVdpdGgobGFzdFF1ZXVlZC5tZXNzYWdlLCBtc2csIG1heFNpemUpKSB7XG5cdFx0XHRpZighbGFzdFF1ZXVlZC5tZXJnZWQpIHtcblx0XHRcdFx0bGFzdFF1ZXVlZC5jYWxsYmFjayA9IE9iamVjdChfdXRpbF9tdWx0aWNhc3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoW2xhc3RRdWV1ZWQuY2FsbGJhY2tdKTtcblx0XHRcdFx0bGFzdFF1ZXVlZC5tZXJnZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFF1ZXVlZC5jYWxsYmFjay5wdXNoKGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5wdXNoKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKCknLCAnc2VuZGluZyAnICsgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpICsgJyBxdWV1ZWQgbWVzc2FnZXMnKTtcblx0XHR2YXIgcGVuZGluZ01lc3NhZ2U7XG5cdFx0d2hpbGUocGVuZGluZ01lc3NhZ2UgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnNoaWZ0KCkpXG5cdFx0XHR0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWVQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZXMpIHtcblx0XHRpZihwZW5kaW5nTWVzc2FnZXMgJiYgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKCknLCAncXVldWVpbmcgJyArIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggKyAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcblx0XHRcdHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZmFpbFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0dmFyIG51bVF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKTtcblx0XHRpZihudW1RdWV1ZWQgPiAwKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZmFpbFF1ZXVlZE1lc3NhZ2VzKCknLCAnZmFpbGluZyAnICsgbnVtUXVldWVkICsgJyBxdWV1ZWQgbWVzc2FnZXMsIGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdHRoaXMucXVldWVkTWVzc2FnZXMuY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRyYW5zcG9ydCkge1xuXHRcdHZhciBvbkFjdGl2ZVRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdHJhbnNwb3J0ID09PSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLFxuXHRcdFx0b25VcGdyYWRlVHJhbnNwb3J0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbih0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpICYmIHRoaXMuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyxcblx0XHRcdG5vdENvbnRyb2xNc2cgPSBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFO1xuXG5cdFx0LyogQXMgdGhlIGxpYiBub3cgaGFzIGEgcGVyaW9kIHdoZXJlIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBpcyBzeW5jZWQgYnV0XG5cdFx0ICogYmVmb3JlIGl0J3MgYmVjb21lIGFjdGl2ZSAod2hpbGUgd2FpdGluZyBmb3IgdGhlIG9sZCBvbmUgdG8gYmVjb21lXG5cdFx0ICogaWRsZSksIG1lc3NhZ2UgY2FuIHZhbGlkbHkgYXJyaXZlIG9uIGl0IGV2ZW4gdGhvdWdoIGl0IGlzbid0IGFjdGl2ZSAqL1xuXHRcdGlmKG9uQWN0aXZlVHJhbnNwb3J0IHx8IG9uVXBncmFkZVRyYW5zcG9ydCkge1xuXHRcdFx0aWYobm90Q29udHJvbE1zZykge1xuXHRcdFx0XHR2YXIgc3VwcHJlc3NlZCA9IHRoaXMuc2V0Q29ubmVjdGlvblNlcmlhbChtZXNzYWdlKTtcblx0XHRcdFx0aWYoc3VwcHJlc3NlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNEdXBsaWNhdGUobWVzc2FnZSwgdGhpcy5tb3N0UmVjZW50TXNnKSkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSB3aXRoIGRpZmZlcmVudCBjb25uZWN0aW9uU2VyaWFsLCBidXQgc2FtZSBtZXNzYWdlIGlkIGFzIGEgcHJldmlvdXM7IGRpc2NhcmRpbmc7IGlkID0gJyArIG1lc3NhZ2UuaWQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm1vc3RSZWNlbnRNc2cgPSBtZXNzYWdlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBNZXNzYWdlIGNhbWUgaW4gb24gYSBkZWZ1bmN0IHRyYW5zcG9ydC4gQWxsb3cgb25seSBhY2tzLCBuYWNrcywgJiBlcnJvcnMgZm9yIG91dHN0YW5kaW5nXG5cdFx0XHQvLyBtZXNzYWdlcywgIG5vIG5ldyBtZXNzYWdlcyAoYXMgc3luYyBoYXMgYmVlbiBzZW50IG9uIG5ldyB0cmFuc3BvcnQgc28gbmV3IG1lc3NhZ2VzIHdpbGxcblx0XHRcdC8vIGJlIHJlc2VudCB0aGVyZSwgb3IgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgc28gZG9uJ3Qgd2FudCBuZXcgbWVzc2FnZXMpXG5cdFx0XHRpZihfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YoW2FjdGlvbnMuQUNLLCBhY3Rpb25zLk5BQ0ssIGFjdGlvbnMuRVJST1JdLCBtZXNzYWdlLmFjdGlvbikgPiAtMSkge1xuXHRcdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UgJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpICsgJ29uIGRlZnVuY3QgdHJhbnNwb3J0OyBkaXNjYXJkaW5nJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCBjYWxsYmFjaykge1xuXHRcdC8qIGlmIHRyYW5zcG9ydCBpcyBzcGVjaWZpZWQsIHRyeSB0aGF0ICovXG5cdFx0aWYodHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXG5cdFx0XHR2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdUaW1lb3V0IHdhaXRpbmcgZm9yIGhlYXJ0YmVhdCByZXNwb25zZScsIDUwMDAwLCA1MDApKTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBwaW5nU3RhcnQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpLFxuXHRcdFx0XHRpZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlYXBSYW5kU3RyKCk7XG5cblx0XHRcdHZhciBvbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uIChyZXNwb25zZUlkKSB7XG5cdFx0XHRcdGlmKHJlc3BvbnNlSWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0dHJhbnNwb3J0Lm9mZignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHRcdFx0dmFyIHJlc3BvbnNlVGltZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSBwaW5nU3RhcnQ7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzcG9uc2VUaW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChvblRpbWVvdXQsIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcblxuXHRcdFx0dHJhbnNwb3J0Lm9uKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG5cdFx0XHR0cmFuc3BvcnQucGluZyhpZCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogaWYgd2UncmUgbm90IGNvbm5lY3RlZCwgZG9uJ3QgYXR0ZW1wdCAqL1xuXHRcdGlmKHRoaXMuc3RhdGUuc3RhdGUgIT09ICdjb25uZWN0ZWQnKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIHBpbmcgc2VydmljZTsgbm90IGNvbm5lY3RlZCcsIDQwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBubyB0cmFuc3BvcnQgd2FzIHNwZWNpZmllZCwgc28gdXNlIHRoZSBjdXJyZW50IChjb25uZWN0ZWQpIG9uZVxuXHRcdCAqIGJ1dCBlbnN1cmUgdGhhdCB3ZSByZXRyeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHN1cGVyc2VkZWQgYmVmb3JlIHdlIGNvbXBsZXRlICovXG5cdFx0dmFyIGNvbXBsZXRlZCA9IGZhbHNlLCBzZWxmID0gdGhpcztcblxuXHRcdHZhciBvblBpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUaW1lKSB7XG5cdFx0XHRzZWxmLm9mZigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcblx0XHRcdGlmKCFjb21wbGV0ZWQpIHtcblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0Y2FsbGJhY2soZXJyLCByZXNwb25zZVRpbWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgb25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCFjb21wbGV0ZWQpIHtcblx0XHRcdFx0LyogZW5zdXJlIHRoYXQgbm8gY2FsbGJhY2sgaGFwcGVucyBmb3IgdGhlIGN1cnJlbnRseSBvdXRzdGFuZGluZyBvcGVyYXRpb24gKi9cblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0LyogcmVwZWF0IGJ1dCBwaWNraW5nIHVwIHRoZSBuZXcgdHJhbnNwb3J0ICovXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5waW5nKG51bGwsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG5cdFx0dGhpcy5waW5nKHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksIG9uUGluZ0NvbXBsZXRlKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbihlcnJvcikge1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZmFpbChlcnJvcik7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlIHx8IChoYXZlV2ViU3RvcmFnZSAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldCh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSkpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51cGdyYWRlVHJhbnNwb3J0cywgdHJhbnNwb3J0LnNob3J0TmFtZSkpIHtcblx0XHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG5cdFx0XHRpZihoYXZlV2ViU3RvcmFnZSkge1xuXHRcdFx0XHRwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNldCh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcblx0XHRpZihoYXZlV2ViU3RvcmFnZSkge1xuXHRcdFx0cGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZW1vdmUodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuXHRcdH1cblx0fTtcblxuXHQvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLFxuXHQgKiBSU0E0YzIsIGFuZCBSU0E0ZC4gSW4gcGFydGljdWxhciBpdCBpcyBub3QgaW52b2tlZCBmb3Jcblx0ICogc2VydmVyc2lkZS10cmlnZ2VyZWQgcmVhdXRocyBvciBtYW51YWwgcmVhdXRocywgc28gUlNBNGMzIGRvZXMgbm90IGFwcGx5ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSA9IGZ1bmN0aW9uKGVycikge1xuXHRcdGlmKGVyci5jb2RlID09PSA0MDE3MSkge1xuXHRcdFx0LyogTm8gd2F5IHRvIHJlYXV0aCAqL1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogZXJyfSk7XG5cdFx0fSBlbHNlIGlmKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcblx0XHRcdHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmV0dXJuZWQgNDAzOyBmYWlsaW5nIHRoZSBjb25uZWN0aW9uJztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpJywgbXNnKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgODAwMTksIDQwMywgZXJyKX0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJlcXVlc3QgZmFpbGVkJztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZScsIG1zZyk7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogdGhpcy5zdGF0ZS5mYWlsU3RhdGUsIGVycm9yOiBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDE5LCA0MDEsIGVycil9KTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUgPSBmdW5jdGlvbihjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG5cdFx0aWYoIWNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSBjb25uZWN0aW9uRGV0YWlscztcblx0XHRpZihjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XG5cdFx0fVxuXHRcdHZhciBjbGllbnRJZCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNsaWVudElkO1xuXHRcdGlmKGNsaWVudElkKSB7XG5cdFx0XHR2YXIgZXJyID0gdGhpcy5yZWFsdGltZS5hdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoKScsIGVyci5tZXNzYWdlKTtcblx0XHRcdFx0LyogRXJyb3JzIHNldHRpbmcgdGhlIGNsaWVudElkIGFyZSBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0XHR0cmFuc3BvcnQuZmFpbChlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBjb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uU3RhdGVUdGw7XG5cdFx0aWYoY29ubmVjdGlvblN0YXRlVHRsKSB7XG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcblx0XHR9XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG5cdFx0dGhpcy5lbWl0KCdjb25uZWN0aW9uZGV0YWlscycsIGNvbm5lY3Rpb25EZXRhaWxzKTtcblx0fTtcblxuXHRyZXR1cm4gQ29ubmVjdGlvbk1hbmFnZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbm5lY3Rpb25NYW5hZ2VyKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuXG52YXIgTWVzc2FnZVF1ZXVlID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBNZXNzYWdlUXVldWUoKSB7XG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLm1lc3NhZ2VzID0gW107XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhNZXNzYWdlUXVldWUsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvcHlBbGwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5zbGljZSgpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHR0aGlzLm1lc3NhZ2VzLnB1c2guYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvbXBsZXRlTWVzc2FnZXMgPSBmdW5jdGlvbihzZXJpYWwsIGNvdW50LCBlcnIpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuXHRcdGVyciA9IGVyciB8fCBudWxsO1xuXHRcdHZhciBtZXNzYWdlcyA9IHRoaXMubWVzc2FnZXM7XG5cdFx0dmFyIGZpcnN0ID0gbWVzc2FnZXNbMF07XG5cdFx0aWYoZmlyc3QpIHtcblx0XHRcdHZhciBzdGFydFNlcmlhbCA9IGZpcnN0Lm1lc3NhZ2UubXNnU2VyaWFsO1xuXHRcdFx0dmFyIGVuZFNlcmlhbCA9IHNlcmlhbCArIGNvdW50OyAvKiB0aGUgc2VyaWFsIG9mIHRoZSBmaXJzdCBtZXNzYWdlIHRoYXQgaXMgKm5vdCogdGhlIHN1YmplY3Qgb2YgdGhpcyBjYWxsICovXG5cdFx0XHRpZihlbmRTZXJpYWwgPiBzdGFydFNlcmlhbCkge1xuXHRcdFx0XHR2YXIgY29tcGxldGVNZXNzYWdlcyA9IG1lc3NhZ2VzLnNwbGljZSgwLCAoZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpKTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvbXBsZXRlTWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb21wbGV0ZU1lc3NhZ2VzW2ldLmNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKG1lc3NhZ2VzLmxlbmd0aCA9PSAwKVxuXHRcdFx0XHR0aGlzLmVtaXQoJ2lkbGUnKTtcblx0XHR9XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZUFsbE1lc3NhZ2VzID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0dGhpcy5jb21wbGV0ZU1lc3NhZ2VzKDAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE51bWJlci5NQVhfVkFMVUUsIGVycik7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY2xlYXIoKScsICdjbGVhcmluZyAnICsgdGhpcy5tZXNzYWdlcy5sZW5ndGggKyAnIG1lc3NhZ2VzJyk7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IFtdO1xuXHRcdHRoaXMuZW1pdCgnaWRsZScpO1xuXHR9O1xuXG5cdHJldHVybiBNZXNzYWdlUXVldWU7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE1lc3NhZ2VRdWV1ZSk7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RvbWV2ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxuXG5cblxuXG5cblxuXG5cblxudmFyIFhIUlJlcXVlc3QgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0dmFyIGlkQ291bnRlciA9IDA7XG5cdHZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fTtcblxuXHR2YXIgUkVRX1NFTkQgPSAwLFxuXHRcdFJFUV9SRUNWID0gMSxcblx0XHRSRVFfUkVDVl9QT0xMID0gMixcblx0XHRSRVFfUkVDVl9TVFJFQU0gPSAzO1xuXG5cdGZ1bmN0aW9uIGNsZWFyUGVuZGluZ1JlcXVlc3RzKCkge1xuXHRcdGZvcih2YXIgaWQgaW4gcGVuZGluZ1JlcXVlc3RzKVxuXHRcdFx0cGVuZGluZ1JlcXVlc3RzW2lkXS5kaXNwb3NlKCk7XG5cdH1cblxuXHR2YXIgaXNJRSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5YRG9tYWluUmVxdWVzdDtcblxuXHRmdW5jdGlvbiBpZVZlcnNpb24oKSB7XG5cdFx0dmFyIG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLyk7XG5cdFx0cmV0dXJuIG1hdGNoICYmIE51bWJlcihtYXRjaFsxXSk7XG5cdH1cblxuXHRmdW5jdGlvbiBuZWVkSnNvbkVudmVsb3BlKCkge1xuXHRcdC8qIElFIDEwIHhociBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MzIwMzM5ICovXG5cdFx0dmFyIHZlcnNpb247XG5cdFx0cmV0dXJuIGlzSUUgJiYgKHZlcnNpb24gPSBpZVZlcnNpb24oKSkgJiYgdmVyc2lvbiA9PT0gMTA7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIZWFkZXIoeGhyLCBoZWFkZXIpIHtcblx0XHRyZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuXHR9XG5cblx0LyogU2FmYXJpIG15c3RlcmlvdXNseSByZXR1cm5zICdJZGVudGl0eScgZm9yIHRyYW5zZmVyLWVuY29kaW5nIHdoZW4gaW4gZmFjdFxuXHQgKiBpdCBpcyAnY2h1bmtlZCcuIFNvIGluc3RlYWQsIGRlY2lkZSB0aGF0IGl0IGlzIGNodW5rZWQgd2hlblxuXHQgKiB0cmFuc2Zlci1lbmNvZGluZyBpcyBwcmVzZW50IG9yIGNvbnRlbnQtbGVuZ3RoIGlzIGFic2VudC4gICgnb3InIGJlY2F1c2Vcblx0ICogd2hlbiB1c2luZyBodHRwMiBzdHJlYW1pbmcsIHRoZXJlJ3Mgbm8gdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyLCBidXQgY2FuXG5cdCAqIHN0aWxsIGRlZHVjZSBzdHJlYW1pbmcgZnJvbSBsYWNrIG9mIGNvbnRlbnQtbGVuZ3RoKSAqL1xuXHRmdW5jdGlvbiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpIHtcblx0XHRyZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyXG5cdFx0XHQmJiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpXG5cdFx0XHR8fCAheGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhlYWRlcnNBc09iamVjdCh4aHIpIHtcblx0XHR2YXIgaGVhZGVyUGFpcnMgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udHJpbSh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLnNwbGl0KCdcXHJcXG4nKSxcblx0XHRcdGhlYWRlcnMgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyTWFwKGhlYWRlclBhaXJzW2ldLnNwbGl0KCc6JyksIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmltKTtcblx0XHRcdGhlYWRlcnNbcGFydHNbMF0udG9Mb3dlckNhc2UoKV0gPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGhlYWRlcnM7XG5cdH1cblxuXHRmdW5jdGlvbiBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0cGFyYW1zLnJuZCA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcblx0XHRpZihuZWVkSnNvbkVudmVsb3BlKCkgJiYgIXBhcmFtcy5lbnZlbG9wZSlcblx0XHRcdHBhcmFtcy5lbnZlbG9wZSA9ICdqc29uJztcblx0XHR0aGlzLnVyaSA9IHVyaSArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcblx0XHR0aGlzLmJvZHkgPSBib2R5O1xuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAoX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoYm9keSkgPyAnR0VUJyA6ICdQT1NUJyk7XG5cdFx0dGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuXHRcdHRoaXMudGltZW91dHMgPSB0aW1lb3V0cztcblx0XHR0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XG5cdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcblx0XHRwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZCA9IFN0cmluZygrK2lkQ291bnRlcildID0gdGhpcztcblx0fVxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoWEhSUmVxdWVzdCwgX2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0dmFyIGNyZWF0ZVJlcXVlc3QgPSBYSFJSZXF1ZXN0LmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcblx0XHQvKiBYSFIgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuXHRcdCAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG5cdFx0ICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cblx0XHR0aW1lb3V0cyA9IHRpbWVvdXRzIHx8IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5USU1FT1VUUztcblx0XHRyZXR1cm4gbmV3IFhIUlJlcXVlc3QodXJpLCBoZWFkZXJzLCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XG5cdH07XG5cblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRpZighZXJyICYmIGJvZHkpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCdkYXRhJywgYm9keSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHR9XG5cdH07XG5cblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSAodGhpcy5yZXF1ZXN0TW9kZSA9PSBSRVFfU0VORCkgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQsXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdHRpbWVyID0gdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYudGltZWRPdXQgPSB0cnVlO1xuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdH0sIHRpbWVvdXQpLFxuXHRcdFx0Ym9keSA9IHRoaXMuYm9keSxcblx0XHRcdG1ldGhvZCA9IHRoaXMubWV0aG9kLFxuXHRcdFx0aGVhZGVycyA9IHRoaXMuaGVhZGVycyxcblx0XHRcdHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG5cdFx0XHRhY2NlcHQgPSBoZWFkZXJzWydhY2NlcHQnXSxcblx0XHRcdHJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcblxuXHRcdGlmKCFhY2NlcHQpIHtcblx0XHRcdGhlYWRlcnNbJ2FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXHRcdH0gZWxzZSBpZihhY2NlcHQuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPT09IDApIHtcblx0XHRcdHJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdFx0fVxuXG5cdFx0aWYoYm9keSkge1xuXHRcdFx0dmFyIGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHRcdGlmKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xICYmIHR5cGVvZihib2R5KSAhPSAnc3RyaW5nJylcblx0XHRcdFx0Ym9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHRcdH1cblxuXHRcdHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG5cblx0XHRpZiAoJ2F1dGhvcml6YXRpb24nIGluIGhlYWRlcnMpIHtcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZvcih2YXIgaCBpbiBoZWFkZXJzKVxuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSk7XG5cblx0XHR2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyb3JFdmVudCwgbWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSkge1xuXHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UgKyAnIChldmVudCB0eXBlOiAnICsgZXJyb3JFdmVudC50eXBlICsgJyknICsgKHNlbGYueGhyLnN0YXR1c1RleHQgPyAnLCBjdXJyZW50IHN0YXR1c1RleHQgaXMgJyArIHNlbGYueGhyLnN0YXR1c1RleHQgOiAnJyk7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1JlcXVlc3Qub24nICsgZXJyb3JFdmVudC50eXBlICsgJygpJywgZXJyb3JNZXNzYWdlKTtcblx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKGVycm9yTWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSkpO1xuXHRcdH07XG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1hIUiBlcnJvciBvY2N1cnJlZCcsIG51bGwsIDQwMCk7XG5cdFx0fVxuXHRcdHhoci5vbmFib3J0ID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuXHRcdFx0aWYoc2VsZi50aW1lZE91dCkge1xuXHRcdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgYWJvcnRlZCBkdWUgdG8gcmVxdWVzdCB0aW1lb3V0IGV4cGlyaW5nJywgbnVsbCwgNDA4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCBjYW5jZWxsZWQnLCBudWxsLCA0MDApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0eGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCB0aW1lZCBvdXQnLCBudWxsLCA0MDgpO1xuXHRcdH07XG5cblx0XHR2YXIgc3RyZWFtaW5nLFxuXHRcdFx0c3RhdHVzQ29kZSxcblx0XHRcdHJlc3BvbnNlQm9keSxcblx0XHRcdGNvbnRlbnRUeXBlLFxuXHRcdFx0c3VjY2Vzc1Jlc3BvbnNlLFxuXHRcdFx0c3RyZWFtUG9zID0gMCxcblx0XHRcdHVucGFja2VkID0gZmFsc2U7XG5cblx0XHRmdW5jdGlvbiBvblJlc3BvbnNlKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdHN1Y2Nlc3NSZXNwb25zZSA9IChzdGF0dXNDb2RlIDwgNDAwKTtcblx0XHRcdGlmKHN0YXR1c0NvZGUgPT0gMjA0KSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgc3RhdHVzQ29kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHN0cmVhbWluZyA9IChzZWxmLnJlcXVlc3RNb2RlID09IFJFUV9SRUNWX1NUUkVBTSAmJiBzdWNjZXNzUmVzcG9uc2UgJiYgaXNFbmNvZGluZ0NodW5rZWQoeGhyKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25FbmQoKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgY29udGVudFR5cGUgPSBnZXRIZWFkZXIoeGhyLCAnY29udGVudC10eXBlJyksXG5cdFx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0XHRyZXNwb25zZUJvZHksXG5cdFx0XHRcdFx0LyogQmUgbGliZXJhbCBpbiB3aGF0IHdlIGFjY2VwdDsgYnVnZ3kgYXV0aCBzZXJ2ZXJzIG1heSByZXNwb25kXG5cdFx0XHRcdFx0ICogd2l0aG91dCB0aGUgY29ycmVjdCBjb250ZW50dHlwZSwgYnV0IGFzc3VtZSB0aGV5J3JlIHN0aWxsXG5cdFx0XHRcdFx0ICogcmVzcG9uZGluZyB3aXRoIGpzb24gKi9cblx0XHRcdFx0XHRqc29uID0gY29udGVudFR5cGUgPyAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID49IDApIDogKHhoci5yZXNwb25zZVR5cGUgPT0gJ3RleHQnKTtcblxuXHRcdFx0XHRpZihqc29uKSB7XG5cdFx0XHRcdFx0LyogSWYgd2UgcmVxdWVzdGVkIG1zZ3BhY2sgYnV0IHNlcnZlciByZXNwb25kZWQgd2l0aCBqc29uLCB0aGVuIHNpbmNlXG5cdFx0XHRcdFx0ICogd2Ugc2V0IHRoZSByZXNwb25zZVR5cGUgZXhwZWN0aW5nIG1zZ3BhY2ssIHRoZSByZXNwb25zZSB3aWxsIGJlXG5cdFx0XHRcdFx0ICogYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBqc29uICovXG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0gKHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpID8gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RGVjb2RlKHhoci5yZXNwb25zZSkgOiBTdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdFx0aWYocmVzcG9uc2VCb2R5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0gSlNPTi5wYXJzZShyZXNwb25zZUJvZHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR1bnBhY2tlZCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0geGhyLnJlc3BvbnNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYocmVzcG9uc2VCb2R5LnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvKiB1bndyYXAgSlNPTiBlbnZlbG9wZSAqL1xuXHRcdFx0XHRcdHN0YXR1c0NvZGUgPSByZXNwb25zZUJvZHkuc3RhdHVzQ29kZTtcblx0XHRcdFx0XHRzdWNjZXNzUmVzcG9uc2UgPSAoc3RhdHVzQ29kZSA8IDQwMCk7XG5cdFx0XHRcdFx0aGVhZGVycyA9IHJlc3BvbnNlQm9keS5oZWFkZXJzO1xuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keS5yZXNwb25zZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJzID0gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocik7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIElmIHJlc3BvbnNlIGlzIGFuIGFycmF5LCBpdCdzIGFuIGFycmF5IG9mIHByb3RvY29sIG1lc3NhZ2VzIC0tIGV2ZW4gaWZcblx0XHRcdCAqIGlzIGNvbnRhaW5zIGFuIGVycm9yIGFjdGlvbiAoaGVuY2UgdGhlIG5vbnN1Y2Nlc3Mgc3RhdHVzY29kZSksIHdlIGNhblxuXHRcdFx0ICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuXHRcdFx0ICogb25Qcm90b2NvbE1lc3NhZ2UgdG8gZGVjaWRlIHdoYXQgdG8gZG8gKi9cblx0XHRcdGlmKHN1Y2Nlc3NSZXNwb25zZSB8fCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShyZXNwb25zZUJvZHkpKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGVyciA9IHJlc3BvbnNlQm9keS5lcnJvciAmJiBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHJlc3BvbnNlQm9keS5lcnJvcik7XG5cdFx0XHRpZighZXJyKSB7XG5cdFx0XHRcdGVyciA9IG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgKyBzdGF0dXNDb2RlICsgJyBib2R5IHdhczogJyArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KHJlc3BvbnNlQm9keSksIG51bGwsIHN0YXR1c0NvZGUpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5jb21wbGV0ZShlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG5cdFx0XHRyZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0dmFyIGJvZHlFbmQgPSByZXNwb25zZUJvZHkubGVuZ3RoIC0gMSwgaWR4LCBjaHVuaztcblx0XHRcdHdoaWxlKChzdHJlYW1Qb3MgPCBib2R5RW5kKSAmJiAoaWR4ID0gcmVzcG9uc2VCb2R5LmluZGV4T2YoJ1xcbicsIHN0cmVhbVBvcykpID4gLTEpIHtcblx0XHRcdFx0Y2h1bmsgPSByZXNwb25zZUJvZHkuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xuXHRcdFx0XHRzdHJlYW1Qb3MgPSBpZHggKyAxO1xuXHRcdFx0XHRvbkNodW5rKGNodW5rKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkNodW5rKGNodW5rKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuZW1pdCgnZGF0YScsIGNodW5rKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblN0cmVhbUVuZCgpIHtcblx0XHRcdG9uUHJvZ3Jlc3MoKTtcblx0XHRcdHNlbGYuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXHRcdFx0aWYocmVhZHlTdGF0ZSA8IDMpIHJldHVybjtcblx0XHRcdGlmKHhoci5zdGF0dXMgIT09IDApIHtcblx0XHRcdFx0aWYoc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdFx0LyogSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTAgKi9cblx0XHRcdFx0XHRpZihzdGF0dXNDb2RlID09PSAxMjIzKSBzdGF0dXNDb2RlID0gMjA0O1xuXHRcdFx0XHRcdG9uUmVzcG9uc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihyZWFkeVN0YXRlID09IDMgJiYgc3RyZWFtaW5nKSB7XG5cdFx0XHRcdFx0b25Qcm9ncmVzcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYocmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHRcdFx0aWYoc3RyZWFtaW5nKVxuXHRcdFx0XHRcdFx0b25TdHJlYW1FbmQoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRvbkVuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIuc2VuZChib2R5KTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHhociA9IHRoaXMueGhyO1xuXHRcdGlmKHhocikge1xuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID0gbm9vcDtcblx0XHRcdHRoaXMueGhyID0gbnVsbDtcblx0XHRcdHZhciB0aW1lciA9IHRoaXMudGltZXI7XG5cdFx0XHRpZih0aW1lcikge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0XHR0aGlzLnRpbWVyID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcblx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0fVxuXHRcdGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG5cdH07XG5cblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS54aHJTdXBwb3J0ZWQpIHtcblx0XHRpZih0eXBlb2YgX3V0aWxfZG9tZXZlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdF91dGlsX2RvbWV2ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWRkVW5sb2FkTGlzdGVuZXIoY2xlYXJQZW5kaW5nUmVxdWVzdHMpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YocGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdXBwb3J0c0F1dGhIZWFkZXJzID0gdHJ1ZTtcblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHJlcSA9IGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIFJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcblx0XHRcdFx0cmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXEuZXhlYygpO1xuXHRcdFx0XHRyZXR1cm4gcmVxO1xuXHRcdFx0fTtcblxuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHVwVXJsID0gX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmludGVybmV0VXBVcmw7XG5cdFx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyB1cFVybCk7XG5cdFx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRVcmkobnVsbCwgdXBVcmwsIG51bGwsIG51bGwsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUZXh0KSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9ICghZXJyICYmIHJlc3BvbnNlVGV4dC5yZXBsYWNlKC9cXG4vLCAnJykgPT0gJ3llcycpO1xuXHRcdFx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBYSFJSZXF1ZXN0O1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChYSFJSZXF1ZXN0KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNiksIF9fd2VicGFja19yZXF1aXJlX18oMjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMSksIF9fd2VicGFja19yZXF1aXJlX18oNDcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNyksIF9fd2VicGFja19yZXF1aXJlX18oMjkpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMzApKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXG5cblx0ICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0oKSlcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDFcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcblx0ICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBkZWNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaXY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIENCQztcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG1vZGU6IENCQyxcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcblx0ICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPT0gbW9kZUNyZWF0b3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuaW5pdCh0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWxpemVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG5cdCAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuXHQgICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG5cdCAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXG5cdCAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkQXJyYXk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gRm9ybWF0XG5cdCAgICAgICAgICAgIGlmIChzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcblx0ICAgICAgICAgICAgdmFyIHNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcblx0ICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcblx0ICAgICAgICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcblx0ICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuXHQgICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuXHQgICAgICAgICAgICBpZiAoIXNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuXHQgICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcblx0ICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuSGV4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0Zjg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cblxudmFyIFByb3RvY29sID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XG5cblx0ZnVuY3Rpb24gUHJvdG9jb2wodHJhbnNwb3J0KSB7XG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblx0XHR0aGlzLm1lc3NhZ2VRdWV1ZSA9IG5ldyBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oKTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dHJhbnNwb3J0Lm9uKCdhY2snLCBmdW5jdGlvbihzZXJpYWwsIGNvdW50KSB7IHNlbGYub25BY2soc2VyaWFsLCBjb3VudCk7IH0pO1xuXHRcdHRyYW5zcG9ydC5vbignbmFjaycsIGZ1bmN0aW9uKHNlcmlhbCwgY291bnQsIGVycikgeyBzZWxmLm9uTmFjayhzZXJpYWwsIGNvdW50LCBlcnIpOyB9KTtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFByb3RvY29sLCBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLm9uQWNrID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdQcm90b2NvbC5vbkFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50KTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25OYWNrID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1Byb3RvY29sLm9uTmFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCArICc7IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRpZighZXJyKSB7XG5cdFx0XHRlcnIgPSBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gc2VuZCBtZXNzYWdlOyBjaGFubmVsIG5vdCByZXNwb25kaW5nJywgNTAwMDEsIDUwMCk7XG5cdFx0fVxuXHRcdHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCwgZXJyKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25jZUlkbGUgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdHZhciBtZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZTtcblx0XHRpZihtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xuXHRcdFx0bGlzdGVuZXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bWVzc2FnZVF1ZXVlLm9uY2UoJ2lkbGUnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZSkge1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkKSB7XG5cdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcblx0XHR9XG5cdFx0aWYgKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNob3VsZExvZyhfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUHJvdG9jb2wuc2VuZCgpJywgJ3NlbmRpbmcgbXNnOyAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKSk7XG5cdFx0fVxuXHRcdHBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQgPSB0cnVlO1xuXHRcdHRoaXMudHJhbnNwb3J0LnNlbmQocGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmdldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zcG9ydDtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuZ2V0UGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNvcHlBbGwoKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuY2xlYXJQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY2xlYXIoKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0O1xuXHRcdHRoaXMub25jZUlkbGUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFBlbmRpbmdNZXNzYWdlKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0dGhpcy5tZXJnZWQgPSBmYWxzZTtcblx0XHR2YXIgYWN0aW9uID0gbWVzc2FnZS5hY3Rpb247XG5cdFx0dGhpcy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5hY2tSZXF1aXJlZCA9IChhY3Rpb24gPT0gYWN0aW9ucy5NRVNTQUdFIHx8IGFjdGlvbiA9PSBhY3Rpb25zLlBSRVNFTkNFKTtcblx0fVxuXHRQcm90b2NvbC5QZW5kaW5nTWVzc2FnZSA9IFBlbmRpbmdNZXNzYWdlO1xuXG5cdHJldHVybiBQcm90b2NvbDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJvdG9jb2wpO1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIERvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBEb21FdmVudCgpIHt9XG5cblx0RG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicrZXZlbnQsIGZ1bmN0aW9uKCkgeyBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7IH0pO1xuXHRcdH1cblx0fTtcblxuXHREb21FdmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYodGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJytldmVudCwgZnVuY3Rpb24oKSB7IGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTsgfSk7XG5cdFx0fVxuXHR9O1xuXG5cdERvbUV2ZW50LmFkZE1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5hZGRMaXN0ZW5lcih0YXJnZXQsICdtZXNzYWdlJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdERvbUV2ZW50LnJlbW92ZU1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0YXJnZXQsICdtZXNzYWdlJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZFVubG9hZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHREb21FdmVudC5hZGRMaXN0ZW5lcihnbG9iYWwsICd1bmxvYWQnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0cmV0dXJuIERvbUV2ZW50O1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChEb21FdmVudCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIEggPSBbXTtcblx0ICAgIHZhciBLID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWUobikge1xuXHQgICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGZhY3RvciA9IDI7IGZhY3RvciA8PSBzcXJ0TjsgZmFjdG9yKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobikge1xuXHQgICAgICAgICAgICByZXR1cm4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBuID0gMjtcblx0ICAgICAgICB2YXIgblByaW1lID0gMDtcblx0ICAgICAgICB3aGlsZSAoblByaW1lIDwgNjQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzUHJpbWUobikpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cblx0ICAgICAgICAgICAgICAgIG5QcmltZSsrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbisrO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjU2IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBmID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIGcgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgaCA9IEhbN107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMHggPDwgMTQpIHwgKGdhbW1hMHggPj4+IDE4KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMSA9ICgoZSA8PCAyNikgfCAoZSA+Pj4gNikpIF4gKChlIDw8IDIxKSB8IChlID4+PiAxMSkpIF4gKChlIDw8IDcpICB8IChlID4+PiAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IHNpZ21hMCArIG1hajtcblxuXHQgICAgICAgICAgICAgICAgaCA9IGc7XG5cdCAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNV0gPSAoSFs1XSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xuXHQgICAgICAgICAgICBIWzddID0gKEhbN10gKyBoKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1NignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyNTYobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTI1NjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNiksIF9fd2VicGFja19yZXF1aXJlX18oMjkpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5IbWFjU0hBMjU2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuXG5cblxuXG5cblxudmFyIEpTT05QVHJhbnNwb3J0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHQvKiBDYW4ndCBqdXN0IHVzZSB3aW5kb3cuQWJseSwgYXMgdGhhdCB3b24ndCBleGlzdCBpZiB1c2luZyB0aGUgY29tbW9uanMgdmVyc2lvbi4gKi9cblx0dmFyIF8gPSBnbG9iYWwuX2FibHlqc19qc29ucCA9IHt9O1xuXG5cdC8qIGV4cHJlc3Mgc3RyaXBzIG91dCBwYXJhbnRoZXNlcyBmcm9tIHRoZSBjYWxsYmFjayFcblx0ICogS2x1ZGdlIHRvIHN0aWxsIGFsb3cgaXRzIHJlc3BvbnNlcyB0byB3b3JrLCB3aGlsZSBub3Qga2VlcGluZyB0aGVcblx0ICogZnVuY3Rpb24gZm9ybSBmb3Igbm9ybWFsIHVzZSBhbmQgbm90IGNsdXR0ZXJpbmcgd2luZG93LkFibHlcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9leHByZXNzL2Jsb2IvNWI0ZDRiNGFiMTMyNDc0MzUzNGZiY2Q0NzA5ZjRlNzViYjRiNGU5ZC9saWIvcmVzcG9uc2UuanMjTDMwNVxuXHQgKi9cblx0Xy5fID0gZnVuY3Rpb24oaWQpIHsgcmV0dXJuIF9bJ18nICsgaWRdIHx8IG5vb3A7IH07XG5cdHZhciBpZENvdW50ZXIgPSAxO1xuXHR2YXIgaGVhZCA9IG51bGw7XG5cdHZhciBzaG9ydE5hbWUgPSAnanNvbnAnO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBKU09OUFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0cGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuXHRcdF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdH1cblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKEpTT05QVHJhbnNwb3J0LCBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0SlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5qc29ucFN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFsbG93Q29tZXQ7XG5cdH07XG5cdGlmKEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBKU09OUFRyYW5zcG9ydDtcblx0fVxuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmpzb25wU3VwcG9ydGVkKSB7XG5cdFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdH1cblxuXHQvKiBjb25uZWN0aXZpdHkgY2hlY2s7IHNpbmNlIHRoaXMgaGFzIGEgaGFyZC1jb2RlZCBjYWxsYmFjayBpZCxcblx0ICogd2UganVzdCBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgY29uY3VycmVudCByZXF1ZXN0cyAoYnV0IHRoZVxuXHQgKiBjb25uZWN0aW9ubWFuYWdlciBzaG91bGQgZW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYW55d2F5ICovXG5cdHZhciBjaGVja3NJblByb2dyZXNzID0gbnVsbDtcblx0Z2xvYmFsLkpTT05QVHJhbnNwb3J0ID0gSlNPTlBUcmFuc3BvcnRcblxuXHRKU09OUFRyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0pTT05QVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0SlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdKU09OUFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcblx0fTtcblxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG5cdFx0LyogSlNPTlAgcmVxdWVzdHMgYXJlIHVzZWQgZWl0aGVyIHdpdGggdGhlIGNvbnRleHQgYmVpbmcgYSByZWFsdGltZVxuXHRcdCAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG5cdFx0ICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cblx0XHR0aW1lb3V0cyA9ICh0aGlzICYmIHRoaXMudGltZW91dHMpIHx8IHRpbWVvdXRzIHx8IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5USU1FT1VUUztcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodW5kZWZpbmVkLCB1cmksIGhlYWRlcnMsIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jb3B5KHBhcmFtcyksIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKTtcblx0fTtcblxuXHRmdW5jdGlvbiBSZXF1ZXN0KGlkLCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0aWYoaWQgPT09IHVuZGVmaW5lZCkgaWQgPSBpZENvdW50ZXIrKztcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy51cmkgPSB1cmk7XG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0dGhpcy5wYXJhbXMucm5kID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWFwUmFuZFN0cigpO1xuXHRcdGlmKGhlYWRlcnMpIHtcblx0XHRcdC8qIEpTT05QIGRvZXNuJ3QgYWxsb3cgaGVhZGVycy4gQ2hlcnJ5LXBpY2sgYSBjb3VwbGUgdG8gdHVybiBpbnRvIHFzIHBhcmFtcyAqL1xuXHRcdFx0aWYoaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXSkgdGhpcy5wYXJhbXMudiA9IGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ107XG5cdFx0XHRpZihoZWFkZXJzWydBYmx5LUFnZW50J10pIHRoaXMucGFyYW1zLmFnZW50ID0gaGVhZGVyc1snQWJseS1BZ2VudCddO1xuXHRcdH1cblx0XHR0aGlzLmJvZHkgPSBib2R5O1xuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kO1xuXHRcdHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcblx0XHR0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG5cdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcblx0fVxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoUmVxdWVzdCwgX2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQsXG5cdFx0XHRib2R5ID0gdGhpcy5ib2R5LFxuXHRcdFx0bWV0aG9kID0gdGhpcy5tZXRob2QsXG5cdFx0XHR1cmkgPSB0aGlzLnVyaSxcblx0XHRcdHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRwYXJhbXMuY2FsbGJhY2sgPSAnX2FibHlqc19qc29ucC5fKCcgKyBpZCArICcpJztcblxuXHRcdHBhcmFtcy5lbnZlbG9wZSA9ICdqc29ucCc7XG5cdFx0aWYoYm9keSkge1xuXHRcdFx0cGFyYW1zLmJvZHkgPSBib2R5O1xuXHRcdH1cblx0XHRpZihtZXRob2QgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xuXHRcdFx0cGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcblx0XHR9XG5cblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHR2YXIgc3JjID0gdXJpICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcblx0XHRzY3JpcHQuc3JjID0gc3JjO1xuXHRcdGlmKHNjcmlwdC5zcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0gIT09IHNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSkge1xuXHRcdFx0LyogVGhlIHNyYyBoYXMgYmVlbiB0cnVuY2F0ZWQuIENhbid0IGFib3J0LCBidXQgY2FuIGF0IGxlYXN0IGVtaXQgYW5cblx0XHRcdCAqIGVycm9yIHNvIHRoZSB1c2VyIGtub3dzIHdoYXQncyBnb25lIHdyb25nLiAoQ2FuJ3QgY29tcGFyZSBzdHJpbmdzXG5cdFx0XHQgKiBkaXJlY3RseSBhcyBzcmMgbWF5IGhhdmUgYSBwb3J0LCBzY3JpcHQuc3JjIHdvbid0KSAqL1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdKU09OUCBSZXF1ZXN0LmV4ZWMoKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciBhcHBlYXJzIHRvIGhhdmUgdHJ1bmNhdGVkIHRoZSBzY3JpcHQgVVJJLiBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiB0aGUgcmVxdWVzdCBmYWlsaW5nIGR1ZSB0byBhbiB1bnBhcnNlYWJsZSBib2R5IHBhcmFtJyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5hc3luYyA9IHRydWU7XG5cdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0Jztcblx0XHRzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdKU09OUCBzY3JpcHQgZXJyb3IgKGV2ZW50OiAnICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QoZXJyKSArICcpJywgbnVsbCwgNDAwKSk7XG5cdFx0fTtcblxuXHRcdF9bJ18nICsgaWRdID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlKSB7XG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBlbnZlbG9wZWQganNvbnAsIGFzIGFsbCBqc29ucCB0cmFuc3BvcnQgdXNlcyBzaG91bGQgYmUgKi9cblx0XHRcdFx0dmFyIHJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZTtcblx0XHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlID09IDIwNCkge1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0fSBlbHNlIGlmKCFyZXNwb25zZSkge1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZTogbm8gZW52ZWxvcGUgZGV0ZWN0ZWQnLCBudWxsLCA1MDApKTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDQwMCB8fCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShyZXNwb25zZSkpIHtcblx0XHRcdFx0XHQvKiBJZiByZXNwb25zZSBpcyBhbiBhcnJheSwgaXQncyBhbiBhcnJheSBvZiBwcm90b2NvbCBtZXNzYWdlcyAtLSBldmVuIGlmXG5cdFx0XHRcdFx0ICogaXQgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG5cdFx0XHRcdFx0ICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuXHRcdFx0XHRcdCAqIG9uUHJvdG9jb2xNZXNzYWdlIHRvIGRlY2lkZSB3aGF0IHRvIGRvICovXG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCByZXNwb25zZSwgbWVzc2FnZS5oZWFkZXJzLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBlcnIgPSByZXNwb25zZS5lcnJvciB8fCBuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyJywgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBub24tZW52ZWxvcGVkIC0tIGFzIHdpbGwgYmUgZWcgZnJvbSBhIGN1c3RvbWVyJ3MgYXV0aFVybCBzZXJ2ZXIgKi9cblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHRpbWVvdXQgPSAodGhpcy5yZXF1ZXN0TW9kZSA9PSBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SRVFfU0VORCkgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQ7XG5cdFx0dGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuYWJvcnQoKTsgfSwgdGltZW91dCk7XG5cdFx0aGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHR9O1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCBzdGF0dXNDb2RlKSB7XG5cdFx0aGVhZGVycyA9IGhlYWRlcnMgfHwge307XG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR2YXIgY29udGVudFR5cGU7XG5cdFx0XHRpZihib2R5KSB7XG5cdFx0XHRcdGNvbnRlbnRUeXBlID0gKHR5cGVvZihib2R5KSA9PSAnc3RyaW5nJykgPyAndGV4dC9wbGFpbicgOiAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0XHRcdGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gY29udGVudFR5cGU7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCAvKiB1bnBhY2tlZDogKi8gdHJ1ZSwgc3RhdHVzQ29kZSk7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHR9XG5cdH07XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0fTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcblx0XHRpZih0aW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xuXHRcdH1cblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG5cdFx0aWYoc2NyaXB0LnBhcmVudE5vZGUpIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZGVsZXRlIF9bdGhpcy5pZF07XG5cdFx0dGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuXHR9O1xuXG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQgJiYgIXBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0KSB7XG5cdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJlcSA9IGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcblx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVxLmV4ZWMoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlcTtcblx0XHR9O1xuXG5cdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdHZhciB1cFVybCA9IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5qc29ucEludGVybmV0VXBVcmw7XG5cblx0XHRcdGlmKGNoZWNrc0luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcyA9IFtjYWxsYmFja107XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcblxuXHRcdFx0dmFyIHJlcSA9IG5ldyBSZXF1ZXN0KCdpc1RoZUludGVybmV0VXAnLCB1cFVybCwgbnVsbCwgbnVsbCwgbnVsbCwgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUkVRX1NFTkQsIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5USU1FT1VUUyk7XG5cdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSAhZXJyICYmIHJlc3BvbnNlO1xuXHRcdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNoZWNrc0luUHJvZ3Jlc3MubGVuZ3RoOyBpKyspIGNoZWNrc0luUHJvZ3Jlc3NbaV0obnVsbCwgcmVzdWx0KTtcblx0XHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVxLmV4ZWMoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gSlNPTlBUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEpTT05QVHJhbnNwb3J0KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG5cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgV2ViU29ja2V0ID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5XZWJTb2NrZXQ7XG5cdHZhciBzaG9ydE5hbWUgPSAnd2ViX3NvY2tldCc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdFx0LyogSWYgaXMgYSBicm93c2VyLCBjYW4ndCBkZXRlY3QgcGluZ3MsIHNvIHJlcXVlc3QgcHJvdG9jb2wgaGVhcnRiZWF0cyAqL1xuXHRcdHBhcmFtcy5oZWFydGJlYXRzID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG5cdFx0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy53c0hvc3QgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3QocGFyYW1zLm9wdGlvbnMsIHBhcmFtcy5ob3N0LCB0cnVlKTtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgX3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISFXZWJTb2NrZXQ7XG5cdH07XG5cblx0aWYoV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpXG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFdlYlNvY2tldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbignd3NvcGVuJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVXZWJTb2NrZXQgPSBmdW5jdGlvbih1cmksIGNvbm5lY3RQYXJhbXMpIHtcblx0XHR0aGlzLnVyaSA9IHVyaSArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKVxuXHRcdHJldHVybiBuZXcgV2ViU29ja2V0KHRoaXMudXJpKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy51cmk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcblx0XHRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cdFx0dmFyIHdzU2NoZW1lID0gb3B0aW9ucy50bHMgPyAnd3NzOi8vJyA6ICd3czovLyc7XG5cdFx0dmFyIHdzVXJpID0gd3NTY2hlbWUgKyB0aGlzLndzSG9zdCArICc6JyArIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UG9ydChvcHRpb25zKSArICcvJztcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyB3c1VyaSk7XG5cdFx0dGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG5cdFx0XHRpZihzZWxmLmlzRGlzcG9zZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcmFtU3RyID0gJyc7IGZvcih2YXIgcGFyYW0gaW4gYXV0aFBhcmFtcykgcGFyYW1TdHIgKz0gJyAnICsgcGFyYW0gKyAnOiAnICsgYXV0aFBhcmFtc1twYXJhbV0gKyAnOyc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdhdXRoUGFyYW1zOicgKyBwYXJhbVN0ciArICcgZXJyOiAnICsgZXJyKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNvbm5lY3RQYXJhbXMgPSBwYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB3c0Nvbm5lY3Rpb24gPSBzZWxmLndzQ29ubmVjdGlvbiA9IHNlbGYuY3JlYXRlV2ViU29ja2V0KHdzVXJpLCBjb25uZWN0UGFyYW1zKTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLmJpbmFyeVR5cGUgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJpbmFyeVR5cGU7XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbm9wZW4gPSBmdW5jdGlvbigpIHsgc2VsZi5vbldzT3BlbigpOyB9O1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uKGV2KSB7IHNlbGYub25Xc0Nsb3NlKGV2KTsgfTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KSB7IHNlbGYub25Xc0RhdGEoZXYuZGF0YSk7IH07XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzRXJyb3IoZXYpOyB9O1xuXHRcdFx0XHRpZih3c0Nvbm5lY3Rpb24ub24pIHtcblx0XHRcdFx0XHQvKiBub2RlOyBicm93c2VycyBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIGdlbmVyYWwgZXZlbnRlbWl0dGVyIGFuZCBjYW4ndCBkZXRlY3Rcblx0XHRcdFx0XHQgKiBwaW5ncy4gQWxzbywgbm8gbmVlZCB0byByZXBseSB3aXRoIGEgcG9uZyBleHBsaWNpdGx5LCB3cyBsaWIgaGFuZGxlcyB0aGF0ICovXG5cdFx0XHRcdFx0d3NDb25uZWN0aW9uLm9uKCdwaW5nJywgZnVuY3Rpb24oKSB7IHNlbGYub25BY3Rpdml0eSgpOyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gJyArIChlLnN0YWNrIHx8IGUubWVzc2FnZSkpO1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRpZighd3NDb25uZWN0aW9uKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsICdObyBzb2NrZXQgY29ubmVjdGlvbicpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0d3NDb25uZWN0aW9uLnNlbmQoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNlcmlhbGl6ZShtZXNzYWdlLCB0aGlzLnBhcmFtcy5mb3JtYXQpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR2YXIgbXNnID0gJ0V4Y2VwdGlvbiBmcm9tIHdzIGNvbm5lY3Rpb24gd2hlbiB0cnlpbmcgdG8gc2VuZDogJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGUpO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5zZW5kKCknLCBtc2cpO1xuXHRcdFx0LyogRG9uJ3QgdHJ5IHRvIHJlcXVlc3QgYSBkaXNjb25uZWN0LCB0aGF0J2xsIGp1c3QgaW52b2x2ZSBzZW5kaW5nIGRhdGFcblx0XHRcdCAqIGRvd24gdGhlIHdlYnNvY2tldCBhZ2Fpbi4gSnVzdCBmaW5pc2ggdGhlIHRyYW5zcG9ydC4gKi9cblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgNTAwMDAsIDUwMCkpO1xuXHRcdH1cblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKScsICdkYXRhIHJlY2VpdmVkOyBsZW5ndGggPSAnICsgZGF0YS5sZW5ndGggKyAnOyB0eXBlID0gJyArIHR5cGVvZihkYXRhKSk7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMuZm9ybWF0KSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBtZXNzYWdlOiAnICsgZS5zdGFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc09wZW4gPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NPcGVuKCknLCAnb3BlbmVkIFdlYlNvY2tldCcpO1xuXHRcdHRoaXMuZW1pdCgnd3NvcGVuJyk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzQ2xvc2UgPSBmdW5jdGlvbihldikge1xuXHRcdHZhciB3YXNDbGVhbiwgY29kZSwgcmVhc29uO1xuXHRcdGlmKHR5cGVvZihldikgPT0gJ29iamVjdCcpIHtcblx0XHRcdC8qIFczQyBzcGVjLWNvbXBhdGlibGUgKi9cblx0XHRcdHdhc0NsZWFuID0gZXYud2FzQ2xlYW47XG5cdFx0XHRjb2RlID0gZXYuY29kZTtcblx0XHR9IGVsc2UgLyppZih0eXBlb2YoZXYpID09ICdudW1iZXInKSovIHtcblx0XHRcdC8qIHdzIGluIG5vZGUgKi9cblx0XHRcdGNvZGUgPSBldjtcblx0XHRcdHdhc0NsZWFuID0gKGNvZGUgPT0gMTAwMCk7XG5cdFx0fVxuXHRcdGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRpZih3YXNDbGVhbikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsICdDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXQnKTtcblx0XHRcdHZhciBlcnIgPSBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdXZWJzb2NrZXQgY2xvc2VkJywgODAwMDMsIDQwMCk7XG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG1zZyA9ICdVbmNsZWFuIGRpc2Nvbm5lY3Rpb24gb2YgV2ViU29ja2V0IDsgY29kZSA9ICcgKyBjb2RlLFxuXHRcdFx0XHRlcnIgPSBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgODAwMDMsIDQwMCk7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgbXNnKTtcblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHRcdH1cblx0XHR0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uRXJyb3IoKScsICdFcnJvciBmcm9tIFdlYlNvY2tldDogJyArIGVyci5tZXNzYWdlKTtcblx0XHQvKiBXYWl0IGEgdGljayBiZWZvcmUgYWJvcnRpbmc6IGlmIHRoZSB3ZWJzb2NrZXQgd2FzIGNvbm5lY3RlZCwgdGhpcyBldmVudFxuXHRcdCAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb25jbG9zZSBldmVudCB3aXRoIGEgY2xvc2UgY29kZS4gQWxsb3dcblx0XHQgKiB0aGF0IHRvIGNsb3NlIGl0IChzbyB3ZSBzZWUgdGhlIGNsb3NlIGNvZGUpIHJhdGhlciB0aGFuIGFudGljaXBhdGluZyBpdCAqL1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0fSk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcblx0XHR2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG5cdFx0aWYod3NDb25uZWN0aW9uKSB7XG5cdFx0XHQvKiBJZ25vcmUgYW55IG1lc3NhZ2VzIHRoYXQgY29tZSB0aHJvdWdoIGFmdGVyIGRpc3Bvc2UoKSBpcyBjYWxsZWQgYnV0IGJlZm9yZVxuXHRcdFx0ICogd2Vic29ja2V0IGlzIGFjdHVhbGx5IGNsb3NlZC4gKG1vc3RseSB3b3VsZCBiZSBoYXJtbGVzcywgYnV0IGlmIGl0J3MgYVxuXHRcdFx0ICogQ09OTkVDVEVELCBpdCdsbCByZS10aWNrIGlzQ29ubmVjdGVkIGFuZCBjYXVzZSBhbGwgc29ydHMgb2YgaGF2b2MpICovXG5cdFx0XHR3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRcdC8qIGRlZmVyIHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgY3ljbGUgYmVmb3JlIGNsb3NpbmcgdGhlIHNvY2tldCxcblx0XHRcdCAqIGdpdmluZyBzb21lIGltcGxlbWVudGF0aW9ucyB0aGUgb3Bwb3J0dW5pdHkgdG8gc2VuZCBhbnkgb3V0c3RhbmRpbmcgY2xvc2UgbWVzc2FnZSAqL1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnY2xvc2luZyB3ZWJzb2NrZXQnKTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIFdlYlNvY2tldFRyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV2ViU29ja2V0VHJhbnNwb3J0KTtcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L2pzb25wdHJhbnNwb3J0LmpzXG52YXIganNvbnB0cmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQuanNcbnZhciBjb21ldHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnJlcXVlc3QuanNcbnZhciB4aHJyZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnBvbGxpbmd0cmFuc3BvcnQuanNcblxuXG5cblxuXG5cbnZhciB4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgc2hvcnROYW1lID0gJ3hocl9wb2xsaW5nJztcblxuXHRmdW5jdGlvbiBYSFJQb2xsaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG5cdFx0Y29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhYSFJQb2xsaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbG93Q29tZXQ7XG5cdH07XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFhIUlBvbGxpbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1hIUlBvbGxpbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnWEhSUG9sbGluZ1RyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcblx0fTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG5cdFx0cmV0dXJuIHhocnJlcXVlc3RbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xuXHR9O1xuXG5cdGlmKHR5cGVvZihjb25uZWN0aW9uTWFuYWdlcikgIT09ICd1bmRlZmluZWQnICYmIFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG5cdH1cblxuXHRyZXR1cm4gWEhSUG9sbGluZ1RyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnBvbGxpbmd0cmFuc3BvcnQgPSAoeGhycG9sbGluZ3RyYW5zcG9ydF9YSFJQb2xsaW5nVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQveGhyc3RyZWFtaW5ndHJhbnNwb3J0LmpzXG5cblxuXG5cblxuXG52YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG5cdHZhciBzaG9ydE5hbWUgPSAneGhyX3N0cmVhbWluZyc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0Y29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhYSFJTdHJlYW1pbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS54aHJTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zdHJlYW1pbmdTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5hbGxvd0NvbWV0O1xuXHR9O1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuXHRcdHJldHVybiB4aHJyZXF1ZXN0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcblx0fTtcblxuXHRpZih0eXBlb2YoY29ubmVjdGlvbk1hbmFnZXIpICE9PSAndW5kZWZpbmVkJyAmJiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcblx0fVxuXG5cdHJldHVybiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnQgPSAoeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L2luZGV4LmpzXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpYl90cmFuc3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChbXG4gIGpzb25wdHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICB4aHJwb2xsaW5ndHJhbnNwb3J0LFxuICB4aHJzdHJlYW1pbmd0cmFuc3BvcnRcbl0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBwcm9jZXNzKSB7KGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNyksIF9fd2VicGFja19yZXF1aXJlX18oNDQpKSlcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmMTZCRSA9IENfZW5jLlV0ZjE2ID0gQ19lbmMuVXRmMTZCRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gdXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIENfZW5jLlV0ZjE2TEUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gc3dhcEVuZGlhbigod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmYpO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgTEUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5wYXJzZSh1dGYxNlN0cik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpIHtcblx0ICAgICAgICByZXR1cm4gKCh3b3JkIDw8IDgpICYgMHhmZjAwZmYwMCkgfCAoKHdvcmQgPj4+IDgpICYgMHgwMGZmMDBmZik7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcztcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleDtcblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0O1xuXG5cdCAgICB2YXIgSGV4Rm9ybWF0dGVyID0gQ19mb3JtYXQuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoZSBjaXBoZXJ0ZXh0IG9mIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKEhleCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIGNpcGhlcnRleHQgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZm9ybWF0LkhleDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCksIF9fd2VicGFja19yZXF1aXJlX18oMzEpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0O1xuXG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMuanMgKyAxIG1vZHVsZXNcbnZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9hdXRoLmpzICsgMSBtb2R1bGVzXG52YXIgYXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvZGV2aWNlZGV0YWlscy5qc1xuXG5cbnZhciBkZXZpY2VkZXRhaWxzX0RldmljZURldGFpbHMgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gRGV2aWNlRGV0YWlscygpIHtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGV2aWNlU2VjcmV0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucGxhdGZvcm0gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5mb3JtRmFjdG9yID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xpZW50SWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRldmljZUlkZW50aXR5VG9rZW4gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wdXNoID0ge1xuXHRcdFx0cmVjaXBpZW50OiB1bmRlZmluZWQsXG5cdFx0XHRzdGF0ZTogdW5kZWZpbmVkLFxuXHRcdFx0ZXJyb3I6IHVuZGVmaW5lZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdERldmljZURldGFpbHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRpZDogdGhpcy5pZCxcblx0XHRcdGRldmljZVNlY3JldDogdGhpcy5kZXZpY2VTZWNyZXQsXG5cdFx0XHRwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcblx0XHRcdGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3Rvcixcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuXHRcdFx0bWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG5cdFx0XHRkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXG5cdFx0XHRwdXNoOiB7XG5cdFx0XHRcdHJlY2lwaWVudDogdGhpcy5wdXNoLnJlY2lwaWVudCxcblx0XHRcdFx0c3RhdGU6IHRoaXMucHVzaC5zdGF0ZSxcblx0XHRcdFx0ZXJyb3I6IHRoaXMucHVzaC5lcnJvclxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0RGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tEZXZpY2VEZXRhaWxzJztcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMucGxhdGZvcm0pXG5cdFx0XHRyZXN1bHQgKz0gJzsgcGxhdGZvcm09JyArIHRoaXMucGxhdGZvcm07XG5cdFx0aWYodGhpcy5mb3JtRmFjdG9yKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGZvcm1GYWN0b3I9JyArIHRoaXMuZm9ybUZhY3Rvcjtcblx0XHRpZih0aGlzLmNsaWVudElkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuXHRcdGlmKHRoaXMubWV0YWRhdGEpXG5cdFx0XHRyZXN1bHQgKz0gJzsgbWV0YWRhdGE9JyArIHRoaXMubWV0YWRhdGE7XG5cdFx0aWYodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGRldmljZUlkZW50aXR5VG9rZW49JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbik7XG5cdFx0aWYodGhpcy5wdXNoLnJlY2lwaWVudClcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLnJlY2lwaWVudD0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLnJlY2lwaWVudCk7XG5cdFx0aWYodGhpcy5wdXNoLnN0YXRlKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2guc3RhdGU9JyArIHRoaXMucHVzaC5zdGF0ZTtcblx0XHRpZih0aGlzLnB1c2guZXJyb3IpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5lcnJvcj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLmVycm9yKTtcblx0XHRpZih0aGlzLnB1c2gubWV0YWRhdGEpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5tZXRhZGF0YT0nICsgdGhpcy5wdXNoLm1ldGFkYXRhO1xuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLnRvUmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5O1xuXG5cdERldmljZURldGFpbHMuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdCkge1xuXHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHR9XG5cblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KGJvZHkpKSB7XG5cdFx0XHRyZXR1cm4gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG5cdFx0fVxuXHR9O1xuXG5cdERldmljZURldGFpbHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhbHVlcy5lcnJvciA9IHZhbHVlcy5lcnJvciAmJiBFcnJvckluZm8uZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpOyBcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4obmV3IERldmljZURldGFpbHMoKSwgdmFsdWVzKTtcblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IERldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIERldmljZURldGFpbHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZXZpY2VkZXRhaWxzID0gKGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2h0dHAuanNcbnZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYnVmZmVydXRpbHMuanNcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVzb3VyY2UuanNcblxuXG5cblxuXG5cblxudmFyIHJlc291cmNlX1Jlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbXNncGFjayA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubXNncGFjaztcblxuXHRmdW5jdGlvbiBSZXNvdXJjZSgpIHt9XG5cblx0ZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgZXJyQ2FsbGJhY2ssIG9wQ2FsbGJhY2spIHtcblx0XHRpZiAoaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0F1dGhIZWFkZXJzKSB7XG5cdFx0XHRyZXN0LmF1dGguZ2V0QXV0aEhlYWRlcnMoZnVuY3Rpb24oZXJyLCBhdXRoSGVhZGVycykge1xuXHRcdFx0XHRpZihlcnIpXG5cdFx0XHRcdFx0ZXJyQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdG9wQ2FsbGJhY2sodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3QuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuXHRcdFx0XHRpZihlcnIpXG5cdFx0XHRcdFx0ZXJyQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdG9wQ2FsbGJhY2soaGVhZGVycywgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB1bmVudmVsb3BlKGNhbGxiYWNrLCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHVucGFja2VkLCBvdXRlclN0YXR1c0NvZGUpIHtcblx0XHRcdGlmKGVyciAmJiAhYm9keSkge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF1bnBhY2tlZCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihib2R5LnN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvKiBFbnZlbG9wZSBhbHJlYWR5IHVud3JhcHBlZCBieSB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB0cnVlLCBvdXRlclN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB3cmFwcGVkU3RhdHVzQ29kZSA9IGJvZHkuc3RhdHVzQ29kZSxcblx0XHRcdFx0cmVzcG9uc2UgPSBib2R5LnJlc3BvbnNlLFxuXHRcdFx0XHR3cmFwcGVkSGVhZGVycyA9IGJvZHkuaGVhZGVycztcblxuXHRcdFx0aWYod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG5cdFx0XHRcdC8qIGhhbmRsZSB3cmFwcGVkIGVycm9ycyAqL1xuXHRcdFx0XHR2YXIgd3JhcHBlZEVyciA9IChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikgfHwgZXJyO1xuXHRcdFx0XHRpZighd3JhcHBlZEVycikge1xuXHRcdFx0XHRcdHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoXCJFcnJvciBpbiB1bmVudmVsb3BpbmcgXCIgKyBib2R5KTtcblx0XHRcdFx0XHR3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayh3cmFwcGVkRXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycywgdHJ1ZSwgd3JhcHBlZFN0YXR1c0NvZGUpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1QYWlycyA9IFtdO1xuXHRcdGlmIChwYXJhbXMpIHtcblx0XHRcdGZvciAodmFyIG5lZWRsZSBpbiBwYXJhbXMpIHtcblx0XHRcdFx0cGFyYW1QYWlycy5wdXNoKG5lZWRsZSArICc9JyArIHBhcmFtc1tuZWVkbGVdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtUGFpcnMuam9pbignJicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSB7XG5cdFx0cmV0dXJuIHBhdGggKyAocGFyYW1zID8gJz8nIDogJycpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBwYXJhbXMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkIEVycm9yOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEVycm9yOiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsXG5cdFx0XHRcdFx0J1JlY2VpdmVkOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEhlYWRlcnM6ICcgKyBwYXJhbVN0cmluZyhoZWFkZXJzKSArICc7IFN0YXR1c0NvZGU6ICcgKyBzdGF0dXNDb2RlICsgJzsgQm9keTogJyArIChidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0J1ZmZlcihib2R5KSA/IGJvZHkudG9TdHJpbmcoKSA6IGJvZHkpKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTsgfVxuXHRcdH1cblx0fVxuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aG91dEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFJlc291cmNlW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIG51bGwsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFJlc291cmNlW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBib2R5LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdFJlc291cmNlWydkbyddID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCBwYXRoLCBib2R5LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIG9yaWdwYXJhbXMpO1xuXHRcdH1cblxuXHRcdGlmKGVudmVsb3BlKSB7XG5cdFx0XHRjYWxsYmFjayA9IChjYWxsYmFjayAmJiB1bmVudmVsb3BlKGNhbGxiYWNrLCBlbnZlbG9wZSkpO1xuXHRcdFx0KG9yaWdwYXJhbXMgPSAob3JpZ3BhcmFtcyB8fCB7fSkpWydlbnZlbG9wZSddID0gZW52ZWxvcGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMsIHBhcmFtcykge1xuXHRcdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhcmdzID0gW3Jlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24oZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRcdGlmKGVyciAmJiBhdXRoW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzVG9rZW5FcnIoZXJyKSkge1xuXHRcdFx0XHRcdC8qIHRva2VuIGhhcyBleHBpcmVkLCBzbyBnZXQgYSBuZXcgb25lICovXG5cdFx0XHRcdFx0cmVzdC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKiByZXRyeSAuLi4gKi9cblx0XHRcdFx0XHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0XHR9XTtcblx0XHRcdGlmICghYm9keSkge1xuXHRcdFx0XHRhcmdzLnNwbGljZSgzLCAxKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdFx0dmFyIGRlY29kZWRCb2R5ID0gYm9keTtcblx0XHRcdFx0aWYgKChoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJykuaW5kZXhPZignbXNncGFjaycpID4gMCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRkZWNvZGVkQm9keSA9IG1zZ3BhY2suZGVjb2RlKGJvZHkpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGRlY29kZUVycikge1xuXHRcdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nIE1zZ1BhY2sgRGVjb2RpbmcgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZGVjb2RlRXJyKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZzsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBCb2R5OiAnICsgZGVjb2RlZEJvZHkpO1xuXHRcdFx0fVxuXHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG5cdH07XG5cblx0cmV0dXJuIFJlc291cmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3Jlc291cmNlID0gKHJlc291cmNlX1Jlc291cmNlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS5qc1xuXG5cblxuXG5cbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV9QYWdpbmF0ZWRSZXNvdXJjZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRSZWxQYXJhbXMobGlua1VybCkge1xuXHRcdHZhciB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xuXHRcdHJldHVybiB1cmxNYXRjaCAmJiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wYXJzZVF1ZXJ5U3RyaW5nKHVybE1hdGNoWzJdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlUmVsTGlua3MobGlua0hlYWRlcikge1xuXHRcdGlmKHR5cGVvZihsaW5rSGVhZGVyKSA9PSAnc3RyaW5nJylcblx0XHRcdGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KCcsJyk7XG5cblx0XHR2YXIgcmVsUGFyYW1zID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsaW5rTWF0Y2ggPSBsaW5rSGVhZGVyW2ldLm1hdGNoKC9eXFxzKjwoLispPjtcXHMqcmVsPVwiKFxcdyspXCIkLyk7XG5cdFx0XHRpZihsaW5rTWF0Y2gpIHtcblx0XHRcdFx0dmFyIHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xuXHRcdFx0XHRpZihwYXJhbXMpXG5cdFx0XHRcdFx0cmVsUGFyYW1zW2xpbmtNYXRjaFsyXV0gPSBwYXJhbXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZWxQYXJhbXM7XG5cdH1cblxuXHRmdW5jdGlvbiBQYWdpbmF0ZWRSZXNvdXJjZShyZXN0LCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgYm9keUhhbmRsZXIsIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcblx0XHR0aGlzLmJvZHlIYW5kbGVyID0gYm9keUhhbmRsZXI7XG5cdFx0dGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG5cdH1cblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhvdXRCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNsaWVudF9yZXNvdXJjZVttZXRob2RdKHNlbGYucmVzdCwgc2VsZi5wYXRoLCBzZWxmLmhlYWRlcnMsIHBhcmFtcywgc2VsZi5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRzZWxmLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSlcblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNsaWVudF9yZXNvdXJjZVttZXRob2RdKHNlbGYucmVzdCwgc2VsZi5wYXRoLCBib2R5LCBzZWxmLmhlYWRlcnMsIHBhcmFtcywgc2VsZi5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCByZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdHNlbGYuaGFuZGxlUGFnZShlcnIsIHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB1c2VIUFIpIHtcblx0XHQvKiBJZiB1c2luZyBodHRwUGFnaW5hdGVkUmVzcG9uc2UsIGVycm9ycyBmcm9tIEFibHkgYXJlIHJldHVybmVkIGFzIHBhcnQgb2Zcblx0XHQgKiB0aGUgSFBSLCBvbmx5IGRvIGNhbGxiYWNrKGVycikgZm9yIG5ldHdvcmsgZXJyb3JzIGV0Yy4gd2hpY2ggZG9uJ3Rcblx0XHQgKiByZXR1cm4gYSBib2R5IGFuZC9vciBoYXZlIG5vIGFibHktb3JpZ2luYXRlZCBlcnJvciBjb2RlIChub24tbnVtZXJpY1xuXHRcdCAqIGVycm9yIGNvZGVzIG9yaWdpbmF0ZSBmcm9tIG5vZGUpICovXG5cdFx0cmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gJ251bWJlcicpKTtcblx0fVxuXG5cdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5oYW5kbGVQYWdlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spIHtcblx0XHRpZihlcnIgJiYgcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyByZXNvdXJjZTogZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuXHRcdHRyeSB7XG5cdFx0XHRpdGVtcyA9IHRoaXMuYm9keUhhbmRsZXIoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0LyogSWYgd2UgZ290IGFuIGVycm9yLCB0aGUgZmFpbHVyZSB0byBwYXJzZSB0aGUgYm9keSBpcyBhbG1vc3QgY2VydGFpbmx5XG5cdFx0XHQgKiBkdWUgdG8gdGhhdCwgc28gY2Igd2l0aCB0aGF0IGluIHByZWZlcmVuY2UgdG8gdGhlIHBhcnNlIGVycm9yICovXG5cdFx0XHRjYWxsYmFjayhlcnIgfHwgZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoaGVhZGVycyAmJiAobGlua0hlYWRlciA9IChoZWFkZXJzWydMaW5rJ10gfHwgaGVhZGVyc1snbGluayddKSkpIHtcblx0XHRcdHJlbFBhcmFtcyA9IHBhcnNlUmVsTGlua3MobGlua0hlYWRlcik7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UodGhpcywgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcykpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBQYWdpbmF0ZWRSZXN1bHQocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcblx0XHR0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG5cdFx0dGhpcy5pdGVtcyA9IGl0ZW1zO1xuXG5cdFx0aWYocmVsUGFyYW1zKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZignZmlyc3QnIGluIHJlbFBhcmFtcykge1xuXHRcdFx0XHR0aGlzLmZpcnN0ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ2ZpcnN0JywgW10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMuZmlyc3QsIGNiKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmKCdjdXJyZW50JyBpbiByZWxQYXJhbXMpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ2N1cnJlbnQnLCBbXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuZ2V0KHJlbFBhcmFtcy5jdXJyZW50LCBjYik7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm5leHQgPSBmdW5jdGlvbihjYikge1xuXHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICduZXh0JywgW10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCduZXh0JyBpbiByZWxQYXJhbXMpIHtcblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMubmV4dCwgY2IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNiKG51bGwsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmhhc05leHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB9O1xuXHRcdFx0dGhpcy5pc0xhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuICF0aGlzLmhhc05leHQoKTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3Npbmdcblx0ICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG5cdFBhZ2luYXRlZFJlc3VsdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXMgPSB0aGlzLnJlc291cmNlO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5nZXQocmVzLnJlc3QsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdHJlcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBIdHRwUGFnaW5hdGVkUmVzcG9uc2UocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuXHRcdFBhZ2luYXRlZFJlc3VsdC5jYWxsKHRoaXMsIHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR0aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcblx0XHR0aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhIdHRwUGFnaW5hdGVkUmVzcG9uc2UsIFBhZ2luYXRlZFJlc3VsdCk7XG5cblx0cmV0dXJuIFBhZ2luYXRlZFJlc291cmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFnaW5hdGVkcmVzb3VyY2UgPSAocGFnaW5hdGVkcmVzb3VyY2VfUGFnaW5hdGVkUmVzb3VyY2UpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcbnZhciBlcnJvcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24uanNcblxuXG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSB7XG5cdFx0dGhpcy5jaGFubmVsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGV2aWNlSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG5cdFx0XHRkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkXG5cdFx0fTtcblx0fTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbic7XG5cdFx0aWYodGhpcy5jaGFubmVsKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNoYW5uZWw9JyArIHRoaXMuY2hhbm5lbDtcblx0XHRpZih0aGlzLmRldmljZUlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGRldmljZUlkPScgKyB0aGlzLmRldmljZUlkO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShib2R5KSkge1xuXHRcdFx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG5cdFx0fVxuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4obmV3IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG5cdH07XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24gPSAocHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3B1c2guanNcblxuXG5cblxuXG5cblxuXG52YXIgcHVzaF9QdXNoID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ZnVuY3Rpb24gUHVzaChyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmFkbWluID0gbmV3IEFkbWluKHJlc3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gQWRtaW4ocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5kZXZpY2VSZWdpc3RyYXRpb25zID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCk7XG5cdFx0dGhpcy5jaGFubmVsU3Vic2NyaXB0aW9ucyA9IG5ldyBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KTtcblx0fVxuXG5cdEFkbWluLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24ocmVjaXBpZW50LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHtyZWNpcGllbnQ6IHJlY2lwaWVudH0sIHBheWxvYWQpLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge307XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keShyZXF1ZXN0Qm9keSwgZm9ybWF0KTtcblx0XHRjbGllbnRfcmVzb3VyY2UucG9zdChyZXN0LCAnL3B1c2gvcHVibGlzaCcsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0fVxuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihkZXZpY2UsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG5cdFx0dmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdHJlcXVlc3RCb2R5ID0gZGV2aWNlZGV0YWlscy5mcm9tVmFsdWVzKGRldmljZSksXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRwYXJhbXMgPSB7fTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5wdXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0Y2FsbGJhY2soZXJyLCAhZXJyICYmIGRldmljZWRldGFpbHMuZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI2dldCBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2UuZ2V0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCB7fSwgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge30sXG5cdFx0XHRkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdGNsaWVudF9yZXNvdXJjZVsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0Y2xpZW50X3Jlc291cmNlWydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0fVxuXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKSxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHkocmVxdWVzdEJvZHksIGZvcm1hdCk7XG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpKTtcblx0XHR9KTtcblx0fTtcblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xpc3QnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2VbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHQvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdENoYW5uZWxzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGlzdENoYW5uZWxzJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9jaGFubmVscycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0dmFyIGYgPSAhdW5wYWNrZWQgJiYgZm9ybWF0O1xuXG5cdFx0XHRpZihmKSB7XG5cdFx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGJvZHlbaV0gPSBTdHJpbmcoYm9keVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdHJldHVybiBQdXNoO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHVzaCA9IChwdXNoX1B1c2gpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2V2ZW50ZW1pdHRlci5qc1xudmFyIGV2ZW50ZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3ByZXNlbmNlbWVzc2FnZS5qc1xudmFyIHByZXNlbmNlbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3ByZXNlbmNlLmpzXG5cblxuXG5cblxuXG5cbnZhciBwcmVzZW5jZV9QcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdGZ1bmN0aW9uIFByZXNlbmNlKGNoYW5uZWwpIHtcblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuXHRcdHRoaXMuYmFzZVBhdGggPSBjaGFubmVsLmJhc2VQYXRoICsgJy9wcmVzZW5jZSc7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUHJlc2VuY2UsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0UHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1ByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHR0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ19oaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0Y2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9oaXN0b3J5JywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRyZXR1cm4gUHJlc2VuY2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcHJlc2VuY2UgPSAocHJlc2VuY2VfUHJlc2VuY2UpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9jcnlwdG8uanNcbnZhciB1dGlsX2NyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9tZXNzYWdlLmpzXG52YXIgdHlwZXNfbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjaGFubmVsX0NoYW5uZWwgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHR2YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDaGFubmVsKHJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMuYmFzZVBhdGggPSAnL2NoYW5uZWxzLycgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyBjbGllbnRfcHJlc2VuY2UodGhpcyk7XG5cdFx0dGhpcy5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDaGFubmVsLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5jaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmKG9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRpZighdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL10pIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG5cdFx0XHR2YXIgY2lwaGVyID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyKTtcblx0XHRcdG9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG5cdFx0fSBlbHNlIGlmKCdjaXBoZXInIGluIG9wdGlvbnMpIHtcblx0XHRcdC8qIERvbid0IGRlYWN0aXZhdGUgYW4gZXhpc3RpbmcgY2lwaGVyIHVubGVzcyBvcHRpb25zXG5cdFx0XHQgKiBoYXMgYSAnY2lwaGVyJyBrZXkgdGhhdCdzIGZhbHNleSAqL1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBudWxsO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0Y2hhbm5lbCA9IHRoaXM7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0ZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRXZlcnkobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRcdHJldHVybiAhbWVzc2FnZS5pZDtcblx0XHR9KTtcblx0fVxuXG5cdENoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0Zmlyc3QgPSBhcmd1bWVudHNbMF0sXG5cdFx0XHRzZWNvbmQgPSBhcmd1bWVudHNbMV0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3VtZW50c1thcmdDb3VudCAtIDFdLFxuXHRcdFx0bWVzc2FnZXMsXG5cdFx0XHRwYXJhbXMsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgZmlyc3QgPT09IG51bGwpIHtcblx0XHRcdC8qIChuYW1lLCBkYXRhLCAuLi4pICovXG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe25hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmR9KV07XG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMl07XG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KGZpcnN0KSkge1xuXHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGZpcnN0KV07XG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMV07XG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoZmlyc3QpKSB7XG5cdFx0XHRtZXNzYWdlcyA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcblx0XHRcdHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgIXBhcmFtcykge1xuXHRcdFx0LyogTm8gcGFyYW1zIHN1cHBsaWVkIChzbyBhZnRlci1tZXNzYWdlIGFyZ3VtZW50IGlzIGp1c3QgdGhlIGNhbGxiYWNrIG9yIHVuZGVmaW5lZCkgKi9cblx0XHRcdHBhcmFtcyA9IHt9O1xuXHRcdH1cblxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0b3B0aW9ucyA9IHJlc3Qub3B0aW9ucyxcblx0XHRcdGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSByZXN0Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYob3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcblx0XHRcdHZhciBtc2dJZEJhc2UgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5yYW5kb21TdHJpbmcoTVNHX0lEX0VOVFJPUFlfQllURVMpO1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChtZXNzYWdlcywgZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcblx0XHRcdFx0bWVzc2FnZS5pZCA9IG1zZ0lkQmFzZSArICc6JyArIGluZGV4LnRvU3RyaW5nKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJTTDFpICovXG5cdFx0XHR2YXIgc2l6ZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSxcblx0XHRcdFx0bWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdFx0aWYoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICsgc2l6ZSArICcgYnl0ZXM7IGxpbWl0IGlzICcgKyBtYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuX3B1Ymxpc2godHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5zZXJpYWxpemUobWVzc2FnZXMsIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24ocmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRjbGllbnRfcmVzb3VyY2UucG9zdCh0aGlzLnJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRyZXR1cm4gQ2hhbm5lbDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9jaGFubmVsID0gKGNoYW5uZWxfQ2hhbm5lbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9zdGF0cy5qc1xuXG5cbnZhciBzdGF0c19TdGF0cyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBNZXNzYWdlQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5jb3VudCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmNvdW50KSB8fCAwO1xuXHRcdHRoaXMuZGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRhdGEpIHx8IDA7XG5cdFx0dGhpcy51bmNvbXByZXNzZWREYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5jb21wcmVzc2VkRGF0YSkgfHwgMDtcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZUNhdGVnb3J5KHZhbHVlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRNZXNzYWdlQ291bnQuY2FsbCh0aGlzLCB2YWx1ZXMpO1xuXHRcdHRoaXMuY2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuY2F0ZWdvcnkpIHtcblx0XHRcdHRoaXMuY2F0ZWdvcnkgPSB7IH07XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5mb3JJbk93bk5vbk51bGxQcm9wcyh2YWx1ZXMuY2F0ZWdvcnksIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0c2VsZi5jYXRlZ29yeVtwcm9wXSA9IG5ldyBNZXNzYWdlQ291bnQodmFsdWVzLmNhdGVnb3J5W3Byb3BdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFJlc291cmNlQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5wZWFrID0gKHZhbHVlcyAmJiB2YWx1ZXMucGVhaykgfHwgMDtcblx0XHR0aGlzLm1pbiA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1pbikgfHwgMDtcblx0XHR0aGlzLm1lYW4gPSAodmFsdWVzICYmIHZhbHVlcy5tZWFuKSB8fCAwO1xuXHRcdHRoaXMub3BlbmVkID0gKHZhbHVlcyAmJiB2YWx1ZXMub3BlbmVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBSZXF1ZXN0Q291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG5cdFx0dGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMpIHtcblx0XHR0aGlzLnBsYWluID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5wbGFpbik7XG5cdFx0dGhpcy50bHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRscyk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlVHlwZXModmFsdWVzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcyk7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5wcmVzZW5jZSk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VUcmFmZmljKHZhbHVlcykge1xuXHRcdHRoaXMucmVhbHRpbWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVhbHRpbWUpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZXN0KTtcblx0XHR0aGlzLndlYmhvb2sgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMud2ViaG9vayk7XG5cdFx0dGhpcy5zaGFyZWRRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5zaGFyZWRRdWV1ZSk7XG5cdFx0dGhpcy5leHRlcm5hbFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmV4dGVybmFsUXVldWUpO1xuXHRcdHRoaXMuaHR0cEV2ZW50ID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmh0dHBFdmVudCk7XG5cdFx0dGhpcy5wdXNoID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2gpO1xuXHRcdHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMpIHtcblx0XHR0aGlzLmFsbCAgICAgICAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0XHR0aGlzLmluYm91bmQgICAgICAgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5pbmJvdW5kKTtcblx0XHR0aGlzLm91dGJvdW5kICAgICAgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5vdXRib3VuZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBYY2hnTWVzc2FnZXModmFsdWVzKSB7XG5cdFx0dGhpcy5hbGwgICAgICAgICAgID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdFx0dGhpcy5wcm9kdWNlclBhaWQgID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMucHJvZHVjZXJQYWlkKTtcblx0XHR0aGlzLmNvbnN1bWVyUGFpZCAgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5jb25zdW1lclBhaWQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHVzaFN0YXRzKHZhbHVlcykge1xuXHRcdHRoaXMubWVzc2FnZXMgPSAodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcykgfHwgMDtcblx0XHR2YXIgbm90aWZpY2F0aW9ucyA9IHZhbHVlcyAmJiB2YWx1ZXMubm90aWZpY2F0aW9ucztcblx0XHR0aGlzLm5vdGlmaWNhdGlvbnMgPSB7XG5cdFx0XHRpbnZhbGlkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuaW52YWxpZCB8fCAwLFxuXHRcdFx0YXR0ZW1wdGVkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuYXR0ZW1wdGVkIHx8IDAsXG5cdFx0XHRzdWNjZXNzZnVsOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuc3VjY2Vzc2Z1bCB8fCAwLFxuXHRcdFx0ZmFpbGVkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuZmFpbGVkIHx8IDBcblx0XHR9O1xuXHRcdHRoaXMuZGlyZWN0UHVibGlzaGVzID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGlyZWN0UHVibGlzaGVzKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHJvY2Vzc2VkQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG5cdFx0dGhpcy5za2lwcGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc2tpcHBlZCkgfHwgMDtcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmRlbHRhID0gdW5kZWZpbmVkO1xuXHRcdGlmICh2YWx1ZXMgJiYgdmFsdWVzLmRlbHRhKSB7XG5cdFx0XHR0aGlzLmRlbHRhID0geyB9O1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZm9ySW5Pd25Ob25OdWxsUHJvcHModmFsdWVzLmRlbHRhLCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdHNlbGYuZGVsdGFbcHJvcF0gPSBuZXcgUHJvY2Vzc2VkQ291bnQodmFsdWVzLmRlbHRhW3Byb3BdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFN0YXRzKHZhbHVlcykge1xuXHRcdE1lc3NhZ2VEaXJlY3Rpb25zLmNhbGwodGhpcywgdmFsdWVzKTtcblx0XHR0aGlzLnBlcnNpc3RlZCAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucGVyc2lzdGVkKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25zICAgPSBuZXcgQ29ubmVjdGlvblR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuY29ubmVjdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgICAgICA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuY2hhbm5lbHMpO1xuXHRcdHRoaXMuYXBpUmVxdWVzdHMgICA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy5hcGlSZXF1ZXN0cyk7XG5cdFx0dGhpcy50b2tlblJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRva2VuUmVxdWVzdHMpO1xuXHRcdHRoaXMueGNoZ1Byb2R1Y2VyICA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnUHJvZHVjZXIpO1xuXHRcdHRoaXMueGNoZ0NvbnN1bWVyICA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnQ29uc3VtZXIpO1xuXHRcdHRoaXMucHVzaCAgICAgICAgICA9IG5ldyBQdXNoU3RhdHModmFsdWVzICYmIHZhbHVlcy5wdXNoU3RhdHMpO1xuXHRcdHRoaXMucHJvY2Vzc2VkICAgICA9IG5ldyBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnByb2Nlc3NlZCk7XG5cdFx0dGhpcy5pblByb2dyZXNzICAgID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW5Qcm9ncmVzcykgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMudW5pdCAgICAgICAgICA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuaXQpIHx8IHVuZGVmaW5lZDtcblx0XHR0aGlzLmludGVydmFsSWQgICAgPSAodmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkKSB8fCB1bmRlZmluZWQ7XG5cdH1cblxuXHRTdGF0cy5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIG5ldyBTdGF0cyh2YWx1ZXMpO1xuXHR9O1xuXG5cdHJldHVybiBTdGF0cztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0YXRzID0gKHN0YXRzX1N0YXRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZXN0LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcmVzdF9SZXN0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIFJlc3Qob3B0aW9ucykge1xuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlc3QpKXtcblx0XHRcdHJldHVybiBuZXcgUmVzdChvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKiBub3JtYWxpc2Ugb3B0aW9ucyAqL1xuXHRcdGlmKCFvcHRpb25zKSB7XG5cdFx0XHR2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0XHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdGlmKG9wdGlvbnMubG9nKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2V0TG9nKG9wdGlvbnMubG9nLmxldmVsLCBvcHRpb25zLmxvZy5oYW5kbGVyKTtcblx0XHR9XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzdCgpJywgJ2luaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdChvcHRpb25zKSk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0LyogcHJvY2VzcyBvcHRpb25zICovXG5cdFx0aWYob3B0aW9ucy5rZXkpIHtcblx0XHRcdHZhciBrZXlNYXRjaCA9IG9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcblx0XHRcdGlmKCFrZXlNYXRjaCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ2ludmFsaWQga2V5IHBhcmFtZXRlcic7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG5cdFx0XHRvcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuXHRcdH1cblxuXHRcdGlmKCdjbGllbnRJZCcgaW4gb3B0aW9ucykge1xuXHRcdFx0aWYoISh0eXBlb2Yob3B0aW9ucy5jbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG5cdFx0XHRlbHNlIGlmKG9wdGlvbnMuY2xpZW50SWQgPT09ICcqJylcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZXN0KCknLCAnc3RhcnRlZDsgdmVyc2lvbiA9ICcgKyBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5saWJzdHJpbmcpO1xuXG5cdFx0dGhpcy5iYXNlVXJpID0gdGhpcy5hdXRob3JpdHkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRIdHRwU2NoZW1lKG9wdGlvbnMpICsgaG9zdCArICc6JyArIGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldFBvcnQob3B0aW9ucywgZmFsc2UpOyB9O1xuXHRcdHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG5cblx0XHR0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuXHRcdHRoaXMuYXV0aCA9IG5ldyBhdXRoW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XG5cdFx0dGhpcy5wdXNoID0gbmV3IHB1c2godGhpcyk7XG5cdH1cblxuXHRSZXN0LnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc3RhdHMnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycygpLFxuXHRcdFx0Zm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG5cblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UodGhpcywgJy9zdGF0cycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0dmFyIHN0YXRzVmFsdWVzID0gKHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSkpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKSBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzLmZyb21WYWx1ZXMoc3RhdHNWYWx1ZXNbaV0pO1xuXHRcdFx0cmV0dXJuIHN0YXRzVmFsdWVzO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAndGltZScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgaGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKCk7XG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciB0aW1lVXJpID0gZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gc2VsZi5hdXRob3JpdHkoaG9zdCkgKyAnL3RpbWUnIH07XG5cdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5nZXQodGhpcywgdGltZVVyaSwgaGVhZGVycywgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighdW5wYWNrZWQpIHJlcyA9IEpTT04ucGFyc2UocmVzKTtcblx0XHRcdHZhciB0aW1lID0gcmVzWzBdO1xuXHRcdFx0aWYoIXRpbWUpIHtcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSknKTtcblx0XHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSA1MDA7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGNhbGN1bGF0ZSB0aW1lIG9mZnNldCBvbmx5IG9uY2UgZm9yIHRoaXMgZGV2aWNlIGJ5IGFkZGluZyB0byB0aGUgcHJvdG90eXBlICovXG5cdFx0XHRzZWxmLnNlcnZlclRpbWVPZmZzZXQgPSAodGltZSAtIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRpbWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFJlc3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycywgY2FsbGJhY2spIHtcblx0XHR2YXIgdXNlQmluYXJ5ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sLFxuXHRcdFx0ZW5jb2RlciA9IHVzZUJpbmFyeSA/IG1zZ3BhY2suZW5jb2RlOiBKU09OLnN0cmluZ2lmeSxcblx0XHRcdGRlY29kZXIgPSB1c2VCaW5hcnkgPyBtc2dwYWNrLmRlY29kZSA6IEpTT04ucGFyc2UsXG5cdFx0XHRmb3JtYXQgPSB1c2VCaW5hcnkgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0bWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIGhlYWRlcnMgPSBtZXRob2QgPT0gJ2dldCcgPyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpIDogdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdCcsIFttZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVyc10pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0Ym9keSA9IGVuY29kZXIoYm9keSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWFkZXJzKSB7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cdFx0fVxuXHRcdGlmKGN1c3RvbUhlYWRlcnMpIHtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuXHRcdH1cblx0XHR2YXIgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgcGFnaW5hdGVkcmVzb3VyY2UodGhpcywgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG5cdFx0fSwgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqLyB0cnVlKTtcblxuXHRcdGlmKCF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHMsIG1ldGhvZCkpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Vuc3VwcG9ydGVkIG1ldGhvZCAnICsgbWV0aG9kLCA0MDUwMCwgNDA1KTtcblx0XHR9XG5cblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgbWV0aG9kKSkge1xuXHRcdFx0cGFnaW5hdGVkUmVzb3VyY2VbbWV0aG9kXShwYXJhbXMsIGJvZHksIGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFnaW5hdGVkUmVzb3VyY2VbbWV0aG9kXShwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUuc2V0TG9nID0gZnVuY3Rpb24obG9nT3B0aW9ucykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zZXRMb2cobG9nT3B0aW9ucy5sZXZlbCwgbG9nT3B0aW9ucy5oYW5kbGVyKTtcblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVscyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdH1cblxuXHRDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRuYW1lID0gU3RyaW5nKG5hbWUpO1xuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG5cdFx0aWYoIWNoYW5uZWwpIHtcblx0XHRcdHRoaXMuYWxsW25hbWVdID0gY2hhbm5lbCA9IG5ldyBjbGllbnRfY2hhbm5lbCh0aGlzLnJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcblx0XHR9IGVsc2UgaWYoY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRcdGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYW5uZWw7XG5cdH07XG5cblx0LyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG5cdCAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLmFsbFtTdHJpbmcobmFtZSldO1xuXHR9O1xuXG5cdHJldHVybiBSZXN0O1xufSkoKTtcblxucmVzdF9SZXN0LlByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuXHRvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcblx0cmV0dXJuIG5ldyByZXN0X1Jlc3Qob3B0aW9ucyk7XG59O1xuXG5yZXN0X1Jlc3QuQ2FsbGJhY2tzID0gcmVzdF9SZXN0O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVzdCA9IChyZXN0X1Jlc3QpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbm1hbmFnZXIuanNcbnZhciBjb25uZWN0aW9ubWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY29ubmVjdGlvbnN0YXRlY2hhbmdlLmpzXG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY29ubmVjdGlvbi5qc1xuXG5cblxuXG5cblxudmFyIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb24oYWJseSwgb3B0aW9ucykge1xuXHRcdGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuYWJseSA9IGFibHk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcltcImFcIiAvKiBkZWZhdWx0ICovXShhYmx5LCBvcHRpb25zKTtcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZTtcblx0XHR0aGlzLmtleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlY292ZXJ5S2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnN0YXRlID0gc3RhdGVDaGFuZ2UuY3VycmVudDtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoc3RhdGUsIHN0YXRlQ2hhbmdlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oJ3VwZGF0ZScsIGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCd1cGRhdGUnLCBzdGF0ZUNoYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDb25uZWN0aW9uLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBsaXN0ZW5lcikge1xuXHRcdHJldHVybiBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlLCBsaXN0ZW5lciwgbmV3IGNvbm5lY3Rpb25zdGF0ZWNoYW5nZVtcImFcIiAvKiBkZWZhdWx0ICovXSh1bmRlZmluZWQsIHN0YXRlKSk7XG5cdH1cblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5jb25uZWN0KCknLCAnJyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0fTtcblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uLnBpbmcoKScsICcnKTtcblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMuYWJseS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3BpbmcnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcobnVsbCwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5jbG9zZSgpJywgJ2Nvbm5lY3Rpb25LZXkgPSAnICsgdGhpcy5rZXkpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nsb3NpbmcnfSk7XG5cdH07XG5cblx0cmV0dXJuIENvbm5lY3Rpb247XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25uZWN0aW9uID0gKGNvbm5lY3Rpb25fQ29ubmVjdGlvbik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3Byb3RvY29sbWVzc2FnZS5qc1xudmFyIHByb3RvY29sbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9uZXJyb3IuanNcbnZhciBjb25uZWN0aW9uZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci5qc1xudmFyIHV0aWxfbXVsdGljYXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9jaGFubmVsc3RhdGVjaGFuZ2UuanNcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENoYW5uZWxTdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmVzdW1lZCwgcmVhc29uKSB7XG5cdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG5cdFx0aWYoY3VycmVudCA9PT0gJ2F0dGFjaGVkJykgdGhpcy5yZXN1bWVkID0gcmVzdW1lZDtcblx0XHRpZihyZWFzb24pIHRoaXMucmVhc29uID0gcmVhc29uO1xuXHR9XG5cblx0cmV0dXJuIENoYW5uZWxTdGF0ZUNoYW5nZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNoYW5uZWxzdGF0ZWNoYW5nZSA9IChDaGFubmVsU3RhdGVDaGFuZ2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lcHJlc2VuY2UuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcmVhbHRpbWVwcmVzZW5jZV9SZWFsdGltZVByZXNlbmNlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ZnVuY3Rpb24gbWVtYmVyS2V5KGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5jbGllbnRJZCArICc6JyArIGl0ZW0uY29ubmVjdGlvbklkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xuXHRcdHJldHVybiByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQW5vbnltb3VzT3JXaWxkY2FyZChyZWFsdGltZVByZXNlbmNlKSB7XG5cdFx0dmFyIHJlYWx0aW1lID0gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lO1xuXHRcdC8qIElmIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkLCB3ZSBjYW4ndCBhc3N1bWUgdGhhdCB3ZSdyZSBhbiBhbm9ueW1vdXNcblx0XHQgKiBjbGllbnQsIGFzIHJlYWx0aW1lIG1heSBpbmZvcm0gdXMgb2Ygb3VyIGNsaWVudElkIGluIHRoZSBDT05ORUNURURcblx0XHQgKiBtZXNzYWdlLiBTbyBhc3N1bWUgd2UncmUgbm90IGFub255bW91cyBhbmQgbGVhdmUgaXQgdG8gcmVhbHRpbWUgdG9cblx0XHQgKiByZXR1cm4gYW4gZXJyb3IgaWYgd2UgYXJlICovXG5cdFx0dmFyIGNsaWVudElkID0gcmVhbHRpbWUuYXV0aC5jbGllbnRJZDtcblx0XHRyZXR1cm4gKCFjbGllbnRJZCB8fCAoY2xpZW50SWQgPT09ICcqJykpICYmIHJlYWx0aW1lLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuXHR9XG5cblx0LyogQ2FsbGJhY2sgaXMgY2FsbGVkIG9ubHkgaW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yICovXG5cdGZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XG5cdFx0c3dpdGNoKGNoYW5uZWwuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdGFjdGlvbigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHRjaGFubmVsLmF0dGFjaChmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRpZihlcnIpIGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0ZWxzZSBhY3Rpb24oKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocmVhbHRpbWVjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKGNoYW5uZWwuc3RhdGUpKSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gUmVhbHRpbWVQcmVzZW5jZShjaGFubmVsLCBvcHRpb25zKSB7XG5cdFx0Y2xpZW50X3ByZXNlbmNlLmNhbGwodGhpcywgY2hhbm5lbCk7XG5cdFx0dGhpcy5zeW5jQ29tcGxldGUgPSBmYWxzZTtcblx0XHR0aGlzLm1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAodGhpcyk7XG5cdFx0dGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lUHJlc2VuY2UsIGNsaWVudF9wcmVzZW5jZSk7XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gZW50ZXIgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0aWYoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YScsIDQwMDEyLCA0MDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXJDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuXHRcdHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGNsaWVudElkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnRlck9yVXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGFjdGlvbiwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdfZW50ZXJPclVwZGF0ZUNsaWVudCcsIFtjbGllbnRJZCwgZGF0YSwgYWN0aW9uXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXHRcdGlmKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS4nICsgYWN0aW9uICsgJ0NsaWVudCgpJyxcblx0XHQgICdjaGFubmVsID0gJyArIGNoYW5uZWwubmFtZSArICcsIGNsaWVudCA9ICcgKyAoY2xpZW50SWQgfHwgJyhpbXBsaWNpdCkgJyArIGdldENsaWVudElkKHRoaXMpKSk7XG5cblx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb24gOiBhY3Rpb24sXG5cdFx0XHRkYXRhICAgOiBkYXRhXG5cdFx0fSk7XG5cdFx0aWYgKGNsaWVudElkKSB7XG5cdFx0XHRwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlKHByZXNlbmNlLCBjaGFubmVsLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoKGNoYW5uZWwuc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRcdGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHRcdGNoYW5uZWwuYXR0YWNoKCk7XG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdFx0c2VsZi5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG5cdFx0XHRcdFx0XHRwcmVzZW5jZSA6IHByZXNlbmNlLFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFja1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byAnICsgYWN0aW9uICsgJyBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluICcgKyBjaGFubmVsLnN0YXRlICsgJyBzdGF0ZScsIDkwMDAxKTtcblx0XHRcdFx0XHRlcnIuY29kZSA9IDkwMDAxO1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5sZWF2ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmICghY2FsbGJhY2spIHtcblx0XHRcdGlmICh0eXBlb2YoZGF0YSk9PT0nZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xlYXZlQ2xpZW50JywgW2NsaWVudElkLCBkYXRhXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXHRcdGlmKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5sZWF2ZUNsaWVudCgpJywgJ2xlYXZpbmc7IGNoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgY2xpZW50SWQpO1xuXHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbiA6ICdsZWF2ZScsXG5cdFx0XHRkYXRhICAgOiBkYXRhXG5cdFx0fSk7XG5cdFx0aWYgKGNsaWVudElkKSB7IHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7IH1cblxuXHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG5cdFx0XHRcdFx0cHJlc2VuY2UgOiBwcmVzZW5jZSxcblx0XHRcdFx0XHRjYWxsYmFjayA6IGNhbGxiYWNrXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdC8qIHdlJ3JlIG5vdCBhdHRhY2hlZDsgdGhlcmVmb3JlIHdlIGxldCBhbnkgZW50ZXJlZCBzdGF0dXNcblx0XHRcdFx0ICogdGltZW91dCBieSBpdHNlbGYgaW5zdGVhZCBvZiBhdHRhY2hpbmcganVzdCBpbiBvcmRlciB0byBsZWF2ZSAqL1xuXHRcdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSknLCA5MDAwMSk7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0LyogdGhlcmUgaXMgbm8gY29ubmVjdGlvbjsgdGhlcmVmb3JlIHdlIGxldFxuXHRcdFx0XHQgKiBhbnkgZW50ZXJlZCBzdGF0dXMgdGltZW91dCBieSBpdHNlbGYgKi9cblx0XHRcdFx0Y2FsbGJhY2soY29ubmVjdGlvbmVycm9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZhaWxlZCk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKC8qIHBhcmFtcywgY2FsbGJhY2sgKi8pIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0aWYoYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YoYXJnc1swXSkgPT0gJ2Z1bmN0aW9uJylcblx0XHRcdGFyZ3MudW5zaGlmdChudWxsKTtcblxuXHRcdHZhciBwYXJhbXMgPSBhcmdzWzBdLFxuXHRcdFx0Y2FsbGJhY2sgPSBhcmdzWzFdLFxuXHRcdFx0d2FpdEZvclN5bmMgPSAhcGFyYW1zIHx8ICgnd2FpdEZvclN5bmMnIGluIHBhcmFtcyA/IHBhcmFtcy53YWl0Rm9yU3luYyA6IHRydWUpO1xuXG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmdzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXR1cm5NZW1iZXJzKG1lbWJlcnMpIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHBhcmFtcyA/IG1lbWJlcnMubGlzdChwYXJhbXMpIDogbWVtYmVycy52YWx1ZXMoKSk7XG5cdFx0fVxuXG5cdFx0LyogU3BlY2lhbC1jYXNlIHRoZSBzdXNwZW5kZWQgc3RhdGU6IGNhbiBzdGlsbCBnZXQgKHN0YWxlKSBwcmVzZW5jZSBzZXQgaWYgd2FpdEZvclN5bmMgaXMgZmFsc2UgKi9cblx0XHRpZih0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHRpZih3YWl0Rm9yU3luYykge1xuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRcdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdFx0XHRcdGNvZGU6IDkxMDA1LFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdQcmVzZW5jZSBzdGF0ZSBpcyBvdXQgb2Ygc3luYyBkdWUgdG8gY2hhbm5lbCBiZWluZyBpbiB0aGUgU1VTUEVOREVEIHN0YXRlJ1xuXHRcdFx0XHR9KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm5NZW1iZXJzKHRoaXMubWVtYmVycyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHdhaXRBdHRhY2hlZCh0aGlzLmNoYW5uZWwsIGNhbGxiYWNrLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZW1iZXJzID0gc2VsZi5tZW1iZXJzO1xuXHRcdFx0aWYod2FpdEZvclN5bmMpIHtcblx0XHRcdFx0bWVtYmVycy53YWl0U3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybk1lbWJlcnMobWVtYmVycyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcblx0XHRcdGlmKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHRkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuXHRcdFx0XHRwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkLCB3YXM6IFwiICsgdGhpcy5jaGFubmVsLnN0YXRlLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xpZW50X3ByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnNldFByZXNlbmNlID0gZnVuY3Rpb24ocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLnNldFByZXNlbmNlKCknLCAncmVjZWl2ZWQgcHJlc2VuY2UgZm9yICcgKyBwcmVzZW5jZVNldC5sZW5ndGggKyAnIHBhcnRpY2lwYW50czsgc3luY0NoYW5uZWxTZXJpYWwgPSAnICsgc3luY0NoYW5uZWxTZXJpYWwpO1xuXHRcdHZhciBzeW5jQ3Vyc29yLCBtYXRjaCwgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLFxuXHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcblxuXHRcdGlmKGlzU3luYykge1xuXHRcdFx0dGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuXHRcdFx0aWYoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3XFwtXSs6KC4qKSQvKSkpIHtcblx0XHRcdFx0c3luY0N1cnNvciA9IG1hdGNoWzFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZVNldC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocHJlc2VuY2VTZXRbaV0pO1xuXHRcdFx0c3dpdGNoKHByZXNlbmNlLmFjdGlvbikge1xuXHRcdFx0XHRjYXNlICdsZWF2ZSc6XG5cdFx0XHRcdFx0aWYobWVtYmVycy5yZW1vdmUocHJlc2VuY2UpKSB7XG5cdFx0XHRcdFx0XHRicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQgJiYgIXByZXNlbmNlLmlzU3ludGhlc2l6ZWQoKSkge1xuXHRcdFx0XHRcdFx0bXlNZW1iZXJzLnJlbW92ZShwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdlbnRlcic6XG5cdFx0XHRcdGNhc2UgJ3ByZXNlbnQnOlxuXHRcdFx0XHRjYXNlICd1cGRhdGUnOlxuXHRcdFx0XHRcdGlmKG1lbWJlcnMucHV0KHByZXNlbmNlKSkge1xuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkKSB7XG5cdFx0XHRcdFx0XHRteU1lbWJlcnMucHV0KHByZXNlbmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIGlmIHRoaXMgaXMgdGhlIGxhc3QgKG9yIG9ubHkpIG1lc3NhZ2UgaW4gYSBzZXF1ZW5jZSBvZiBzeW5jIHVwZGF0ZXMsIGVuZCB0aGUgc3luYyAqL1xuXHRcdGlmKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xuXHRcdFx0bWVtYmVycy5lbmRTeW5jKCk7XG5cdFx0XHQvKiBSVFA1YzI6IHJlLWVudGVyIG91ciBvd24gbWVtYmVycyBpZiB0aGV5IGhhdmVuJ3Qgc2hvd24gdXAgaW4gdGhlIHN5bmMgKi9cblx0XHRcdHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcblx0XHRcdHRoaXMuY2hhbm5lbC5zZXRJblByb2dyZXNzKHJlYWx0aW1lY2hhbm5lbC5wcm9ncmVzc09wcy5zeW5jLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmNoYW5uZWwuc3luY0NoYW5uZWxTZXJpYWwgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qIGJyb2FkY2FzdCB0byBsaXN0ZW5lcnMgKi9cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IGJyb2FkY2FzdE1lc3NhZ2VzW2ldO1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zLmVtaXQocHJlc2VuY2UuYWN0aW9uLCBwcmVzZW5jZSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbihoYXNQcmVzZW5jZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBoYXNQcmVzZW5jZSA9ICcgKyBoYXNQcmVzZW5jZSk7XG5cblx0XHRpZihoYXNQcmVzZW5jZSkge1xuXHRcdFx0dGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG5cdFx0XHR0aGlzLm1lbWJlcnMuY2xlYXIoKTtcblx0XHRcdHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcblx0XHR9XG5cblx0XHQvKiBOQiB0aGlzIG11c3QgYmUgYWZ0ZXIgdGhlIF9lbnN1cmVNeU1lbWJlcnNQcmVzZW50IGNhbGwsIHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gcGVuZGluZ1ByZXNlbmNlICovXG5cdFx0dmFyIHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLFxuXHRcdFx0cGVuZGluZ1ByZXNDb3VudCA9IHBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7XG5cblx0XHRpZihwZW5kaW5nUHJlc0NvdW50KSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuXHRcdFx0dmFyIHByZXNlbmNlQXJyYXkgPSBbXTtcblx0XHRcdHZhciBtdWx0aWNhc3RlciA9IE9iamVjdCh1dGlsX211bHRpY2FzdGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkJywgJ3NlbmRpbmcgJyArIHBlbmRpbmdQcmVzQ291bnQgKyAnIHF1ZXVlZCBwcmVzZW5jZSBtZXNzYWdlcycpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBwZW5kaW5nUHJlc2VuY2VbaV07XG5cdFx0XHRcdHByZXNlbmNlQXJyYXkucHVzaChldmVudC5wcmVzZW5jZSk7XG5cdFx0XHRcdG11bHRpY2FzdGVyLnB1c2goZXZlbnQuY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZUFycmF5LCBtdWx0aWNhc3Rlcik7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmFjdE9uQ2hhbm5lbFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGhhc1ByZXNlbmNlLCBlcnIpIHtcblx0XHRzd2l0Y2goc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0dGhpcy5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHR0aGlzLl9jbGVhck15TWVtYmVycygpO1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuY2xlYXIoKTtcblx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0dGhpcy5mYWlsUGVuZGluZ1ByZXNlbmNlKGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5mYWlsUGVuZGluZ1ByZXNlbmNlID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0aWYodGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZScsICdjaGFubmVsOyBuYW1lID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7IGkrKylcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZVtpXS5jYWxsYmFjayhlcnIpO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZSA9IFtdO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fY2xlYXJNeU1lbWJlcnMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9teU1lbWJlcnMuY2xlYXIoKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcywgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLFxuXHRcdFx0cmVlbnRlckNiID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdHZhciBtc2cgPSAnUHJlc2VuY2UgYXV0by1yZS1lbnRlciBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKTtcblx0XHRcdFx0XHR2YXIgd3JhcHBlZEVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA5MTAwNCwgNDAwKTtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCBtc2cpO1xuXHRcdFx0XHRcdHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlKHNlbGYuY2hhbm5lbC5zdGF0ZSwgc2VsZi5jaGFubmVsLnN0YXRlLCB0cnVlLCB3cmFwcGVkRXJyKTtcblx0XHRcdFx0XHRzZWxmLmNoYW5uZWwuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIG15TWVtYmVycy5tYXApIHtcblx0XHRcdGlmKCEobWVtYmVyS2V5IGluIG1lbWJlcnMubWFwKSkge1xuXHRcdFx0XHR2YXIgZW50cnkgPSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0Jyk7XG5cdFx0XHRcdHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoZW50cnkuY2xpZW50SWQsIGVudHJ5LmRhdGEsICdlbnRlcicsIHJlZW50ZXJDYik7XG5cdFx0XHRcdGRlbGV0ZSBteU1lbWJlcnMubWFwW21lbWJlcktleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9zeW50aGVzaXplTGVhdmVzID0gZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcblx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRcdGFjdGlvbjogJ2xlYXZlJyxcblx0XHRcdFx0Y29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0Y2xpZW50SWQ6IGl0ZW0uY2xpZW50SWQsXG5cdFx0XHRcdGRhdGE6IGl0ZW0uZGF0YSxcblx0XHRcdFx0ZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXG5cdFx0XHRcdHRpbWVzdGFtcDogdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm93KClcblx0XHRcdH0pO1xuXHRcdFx0c3Vic2NyaXB0aW9ucy5lbWl0KCdsZWF2ZScsIHByZXNlbmNlKTtcblx0XHR9KTtcblx0fTtcblxuXHQvKiBEZXByZWNhdGVkICovXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9uJywgJ3ByZXNlbmNlLnN1YnNjcmliZScpO1xuXHRcdHRoaXMuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0LyogRGVwcmVjYXRlZCAqL1xuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgncHJlc2VuY2Uub2ZmJywgJ3ByZXNlbmNlLnVuc3Vic2NyaWJlJyk7XG5cdFx0dGhpcy51bnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG5cdFx0dmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR2YXIgY2FsbGJhY2sgPSBhcmdzWzJdO1xuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc3Vic2NyaWJlJywgW2V2ZW50LCBsaXN0ZW5lcl0pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhyZWFsdGltZWNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoJ2ZhaWxlZCcpKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0Y2hhbm5lbC5hdHRhY2goY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcblx0XHR2YXIgYXJncyA9IHJlYWx0aW1lY2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRmdW5jdGlvbiBQcmVzZW5jZU1hcChwcmVzZW5jZSkge1xuXHRcdGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBwcmVzZW5jZTtcblx0XHR0aGlzLm1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhQcmVzZW5jZU1hcCwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwW2tleV07XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmdldENsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XG5cdFx0XHRpZihpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCxcblx0XHRcdGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCxcblx0XHRcdGNvbm5lY3Rpb25JZCA9IHBhcmFtcyAmJiBwYXJhbXMuY29ubmVjdGlvbklkLFxuXHRcdFx0cmVzdWx0ID0gW107XG5cblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XG5cdFx0XHRpZihpdGVtLmFjdGlvbiA9PT0gJ2Fic2VudCcpIGNvbnRpbnVlO1xuXHRcdFx0aWYoY2xpZW50SWQgJiYgY2xpZW50SWQgIT0gaXRlbS5jbGllbnRJZCkgY29udGludWU7XG5cdFx0XHRpZihjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKSBjb250aW51ZTtcblx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIG5ld2VyVGhhbihpdGVtLCBleGlzdGluZykge1xuXHRcdC8qIFJUUDJiMTogaWYgZWl0aGVyIGlzIHN5bnRoZXNpc2VkLCBjb21wYXJlIGJ5IHRpbWVzdGFtcCAqL1xuXHRcdGlmKGl0ZW0uaXNTeW50aGVzaXplZCgpIHx8IGV4aXN0aW5nLmlzU3ludGhlc2l6ZWQoKSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udGltZXN0YW1wID4gZXhpc3RpbmcudGltZXN0YW1wO1xuXHRcdH1cblxuXHRcdC8qIFJUUDJiMiAqL1xuXHRcdHZhciBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksXG5cdFx0XHRleGlzdGluZ09yZGVyaW5ncyA9IGV4aXN0aW5nLnBhcnNlSWQoKTtcblx0XHRpZihpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA9PT0gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsKSB7XG5cdFx0XHRyZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPiBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWw7XG5cdFx0fVxuXHR9XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZihpdGVtLmFjdGlvbiA9PT0gJ2VudGVyJyB8fCBpdGVtLmFjdGlvbiA9PT0gJ3VwZGF0ZScpIHtcblx0XHRcdGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhpdGVtKTtcblx0XHRcdGl0ZW0uYWN0aW9uID0gJ3ByZXNlbnQnO1xuXHRcdH1cblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IG1lbWJlcktleShpdGVtKTtcblx0XHQvKiB3ZSd2ZSBzZWVuIHRoaXMgbWVtYmVyLCBzbyBkbyBub3QgcmVtb3ZlIGl0IGF0IHRoZSBlbmQgb2Ygc3luYyAqL1xuXHRcdGlmKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuXHRcdFx0ZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG5cblx0XHQvKiBjb21wYXJlIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG5ldyBpdGVtIHdpdGggYW55IGV4aXN0aW5nIG1lbWJlciAob3IgQUJTRU5UIHdpdG5lc3MpICovXG5cdFx0dmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuXHRcdGlmKGV4aXN0aW5nSXRlbSAmJiAhbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0bWFwW2tleV0gPSBpdGVtO1xuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBrZXkgaW4gbWFwKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1hcFtrZXldO1xuXHRcdFx0aWYoaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSBtZW1iZXJLZXkoaXRlbSk7XG5cdFx0dmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuXG5cdFx0aWYoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIFJUUDJmICovXG5cdFx0aWYodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuXHRcdFx0aXRlbSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGl0ZW0pO1xuXHRcdFx0aXRlbS5hY3Rpb24gPSAnYWJzZW50Jztcblx0XHRcdG1hcFtrZXldID0gaXRlbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIG1hcFtrZXldO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5zdGFydFN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC5zdGFydFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuXHRcdC8qIHdlIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aGlsZSBhIHN5bmMgaXMgaW4gcHJvZ3Jlc3MgKi9cblx0XHRpZighdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xuXHRcdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb3B5KG1hcCk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3ModHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5lbmRTeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAuZW5kU3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0aWYoc3luY0luUHJvZ3Jlc3MpIHtcblx0XHRcdC8qIHdlIGNhbiBub3cgc3RyaXAgb3V0IHRoZSBBQlNFTlQgbWVtYmVycywgYXMgd2UgaGF2ZVxuXHRcdFx0ICogcmVjZWl2ZWQgYWxsIG9mIHRoZSBvdXQtb2Ytb3JkZXIgc3luYyBtZXNzYWdlcyAqL1xuXHRcdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gbWFwKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuXHRcdFx0XHRpZihlbnRyeS5hY3Rpb24gPT09ICdhYnNlbnQnKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKiBhbnkgbWVtYmVycyB0aGF0IHdlcmUgcHJlc2VudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHN5bmMsXG5cdFx0XHQgKiBhbmQgaGF2ZSBub3QgYmVlbiBzZWVuIGluIHN5bmMsIGNhbiBiZSByZW1vdmVkLCBhbmQgbGVhdmUgZXZlbnRzIGVtaXR0ZWQgKi9cblx0XHRcdHRoaXMucHJlc2VuY2UuX3N5bnRoZXNpemVMZWF2ZXModXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udmFsdWVzQXJyYXkodGhpcy5yZXNpZHVhbE1lbWJlcnMpKTtcblx0XHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIHRoaXMucmVzaWR1YWxNZW1iZXJzKSB7XG5cdFx0XHRcdGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcblxuXHRcdFx0LyogZmluaXNoLCBub3RpZnlpbmcgYW55IHdhaXRlcnMgKi9cblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnc3luYycpO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS53YWl0U3luYyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC53YWl0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0aWYoIXN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9uY2UoJ3N5bmMnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR0aGlzLm1hcCA9IHt9O1xuXHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24oaW5Qcm9ncmVzcykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1ByZXNlbmNlTWFwLnNldEluUHJvZ3Jlc3MoKScsICdpblByb2dyZXNzID0gJyArIGluUHJvZ3Jlc3MpO1xuXHRcdHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBpblByb2dyZXNzO1xuXHRcdHRoaXMucHJlc2VuY2Uuc3luY0NvbXBsZXRlID0gIWluUHJvZ3Jlc3M7XG5cdH07XG5cblx0cmV0dXJuIFJlYWx0aW1lUHJlc2VuY2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZWFsdGltZXByZXNlbmNlID0gKHJlYWx0aW1lcHJlc2VuY2VfUmVhbHRpbWVQcmVzZW5jZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVjaGFubmVsLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcmVhbHRpbWVjaGFubmVsX1JlYWx0aW1lQ2hhbm5lbCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uQWN0aW9uO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciBzdGF0ZWNoYW5nZU9wID0gJ3N0YXRlY2hhbmdlJztcblx0dmFyIHN5bmNPcCA9ICdzeW5jJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gUmVhbHRpbWVDaGFubmVsKHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcblx0XHRjbGllbnRfY2hhbm5lbC5jYWxsKHRoaXMsIHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyByZWFsdGltZXByZXNlbmNlKHRoaXMsIHJlYWx0aW1lLm9wdGlvbnMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSByZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdHRoaXMuc3RhdGUgPSAnaW5pdGlhbGl6ZWQnO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblx0XHR0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucHJvcGVydGllcyA9IHtcblx0XHRcdGF0dGFjaFNlcmlhbDogdW5kZWZpbmVkXG5cdFx0fTtcblx0XHR0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0dGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG5cdFx0dGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBudWxsO1xuXHRcdHRoaXMuX21vZGUgPSBudWxsO1xuXHRcdC8qIFRlbXBvcmFyeTsgb25seSB1c2VkIGZvciB0aGUgY2hlY2tDaGFubmVsc09uUmVzdW1lIG9wdGlvbiAqL1xuXHRcdHRoaXMuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gZmFsc2U7XG5cdFx0dGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG5cdFx0dGhpcy5fZGVjb2RpbmdDb250ZXh0ID0ge1xuXHRcdFx0Y2hhbm5lbE9wdGlvbnM6IHRoaXMuY2hhbm5lbE9wdGlvbnMsXG5cdFx0XHRwbHVnaW5zOiByZWFsdGltZS5vcHRpb25zLnBsdWdpbnMgfHwgeyB9LFxuXHRcdFx0YmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZFxuXHRcdH07XG5cdFx0dGhpcy5fbGFzdFBheWxvYWQgPSB7XG5cdFx0XHRtZXNzYWdlSWQ6IG51bGwsXG5cdFx0XHRwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuXHRcdFx0ZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbFxuXHRcdH07XG5cdFx0LyogT25seSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBwdWJsaWMgZXZlbnQgZW1pdHRlciBpcyB0aGF0IHRoaXMgZW1pdHMgYW5cblx0XHQgKiB1cGRhdGUgZXZlbnQgZm9yIGFsbCBBVFRBQ0hFRHMsIHdoZXRoZXIgcmVzdW1lZCBvciBub3QgKi9cblx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhSZWFsdGltZUNoYW5uZWwsIGNsaWVudF9jaGFubmVsKTtcblxuXHRSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0XHRjb2RlOiA5MDAwMSxcblx0XHRcdG1lc3NhZ2U6ICdDaGFubmVsIG9wZXJhdGlvbiBmYWlsZWQgYXMgY2hhbm5lbCBzdGF0ZSBpcyAnICsgc3RhdGVcblx0XHR9O1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm9ncmVzc09wcyA9IHtcblx0XHRzdGF0ZWNoYW5nZTogc3RhdGVjaGFuZ2VPcCxcblx0XHRzeW5jOiBzeW5jT3Bcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHQvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblx0XHRpZih0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0YXJncy51bnNoaWZ0KG51bGwpO1xuXHRcdH1cblx0XHRpZihhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhcmdzLnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJncztcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3NldE9wdGlvbnMnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGVycil7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCknLCAnU2V0IG9wdGlvbnMgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHR2YXIgZXJyID0gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKTtcblx0XHRpZihlcnIpIHtcblx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNsaWVudF9jaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0aWYgKHRoaXMuX2RlY29kaW5nQ29udGV4dClcblx0XHRcdHRoaXMuX2RlY29kaW5nQ29udGV4dC5jaGFubmVsT3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0aWYodGhpcy5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucykpIHtcblx0XHRcdC8qIFRoaXMgZG9lcyBub3QganVzdCBkbyBfYXR0YWNoKHRydWUsIG51bGwsIGNhbGxiYWNrKSBiZWNhdXNlIHRoYXQgd291bGQgcHV0IHVzXG5cdFx0XHQgKiBpbnRvIHRoZSAnYXR0YWNoaW5nJyBzdGF0ZSB1bnRpbCB3ZSByZWNlaXZlIHRoZSBuZXcgYXR0YWNoZWQsIHdoaWNoIGlzXG5cdFx0XHQgKiBjb25jZXB0dWFsbHkgaW5jb3JyZWN0OiB3ZSBhcmUgc3RpbGwgYXR0YWNoZWQsIHdlIGp1c3QgaGF2ZSBhIHBlbmRpbmcgcmVxdWVzdCB0b1xuXHRcdFx0ICogY2hhbmdlIHNvbWUgY2hhbm5lbCBwYXJhbXMuIFBlciBSVEwxNyBnb2luZyBpbnRvIHRoZSBhdHRhY2hpbmcgc3RhdGUgd291bGQgbWVhblxuXHRcdFx0ICogcmVqZWN0aW5nIG1lc3NhZ2VzIHVudGlsIHdlIGhhdmUgY29uZmlybWF0aW9uIHRoYXQgdGhlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLFxuXHRcdFx0ICogd2hpY2ggd291bGQgdW5uZWNlc3NhcmlseSBsb3NlIG1lc3NhZ2UgY29udGludWl0eS4gKi9cblx0XHRcdHRoaXMuYXR0YWNoSW1wbCgpO1xuXHRcdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xuXHRcdFx0XHRcdGNhc2UgJ3VwZGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZihvcHRpb25zICYmICdwYXJhbXMnIGluIG9wdGlvbnMgJiYgIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KG9wdGlvbnMucGFyYW1zKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ29wdGlvbnMucGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0JywgNDAwMDAsIDQwMCk7XG5cdFx0fVxuXHRcdGlmKG9wdGlvbnMgJiYgJ21vZGVzJyBpbiBvcHRpb25zKXtcblx0XHRcdGlmKCF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KG9wdGlvbnMubW9kZXMpKXtcblx0XHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ29wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheScsIDQwMDAwLCA0MDApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubW9kZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHR2YXIgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xuXHRcdFx0XHRpZighY3VycmVudE1vZGUgfHwgdHlwZW9mIGN1cnJlbnRNb2RlICE9PSAnc3RyaW5nJyB8fCAhdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4ocHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNoYW5uZWxNb2RlcywgU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZS5jYWxsKGN1cnJlbnRNb2RlKSkpe1xuXHRcdFx0XHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdJbnZhbGlkIGNoYW5uZWwgbW9kZTogJyArIGN1cnJlbnRNb2RlLCA0MDAwMCwgNDAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyB8fCB0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykgJiYgKG9wdGlvbnMucGFyYW1zIHx8IG9wdGlvbnMubW9kZXMpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRtZXNzYWdlcyA9IGFyZ3VtZW50c1swXSxcblx0XHRcdGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV07XG5cblx0XHRpZih0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHQrK2FyZ0NvdW50O1xuXHRcdH1cblx0XHRpZighdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayh0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihhcmdDb3VudCA9PSAyKSB7XG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc09iamVjdChtZXNzYWdlcykpXG5cdFx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhtZXNzYWdlcyldO1xuXHRcdFx0ZWxzZSBpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KG1lc3NhZ2VzKSlcblx0XHRcdFx0bWVzc2FnZXMgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXNBcnJheShtZXNzYWdlcyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1RoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cycsIDQwMDEzLCA0MDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe25hbWU6IGFyZ3VtZW50c1swXSwgZGF0YTogYXJndW1lbnRzWzFdfSldO1xuXHRcdH1cblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRtYXhNZXNzYWdlU2l6ZSA9IHRoaXMucmVhbHRpbWUub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcblx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogUlNMMWkgKi9cblx0XHRcdHZhciBzaXplID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpO1xuXHRcdFx0aWYoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICsgc2l6ZSArICcgYnl0ZXM7IGxpbWl0IGlzICcgKyBtYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjayk7XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnbWVzc2FnZSBjb3VudCA9ICcgKyBtZXNzYWdlcy5sZW5ndGgpO1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cdFx0c3dpdGNoKHN0YXRlKSB7XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoUmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKHN0YXRlKSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnc2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZSk7XG5cdFx0XHRcdHZhciBtc2cgPSBuZXcgcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cdFx0XHRcdG1zZy5hY3Rpb24gPSBhY3Rpb25zLk1FU1NBR0U7XG5cdFx0XHRcdG1zZy5jaGFubmVsID0gdGhpcy5uYW1lO1xuXHRcdFx0XHRtc2cubWVzc2FnZXMgPSBtZXNzYWdlcztcblx0XHRcdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm9uRXZlbnQoKScsICdyZWNlaXZlZCBtZXNzYWdlJyk7XG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuXHRcdFx0c3Vic2NyaXB0aW9ucy5lbWl0KG1lc3NhZ2UubmFtZSwgbWVzc2FnZSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmxhZ3MsIGNhbGxiYWNrKSB7XG5cdFx0aWYodHlwZW9mKGZsYWdzKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sgPSBmbGFncztcblx0XHRcdGZsYWdzID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnYXR0YWNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYoZmxhZ3MpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdjaGFubmVsLmF0dGFjaCgpIHdpdGggZmxhZ3MnLCAnY2hhbm5lbC5zZXRPcHRpb25zKCkgd2l0aCBjaGFubmVsT3B0aW9ucy5wYXJhbXMnKTtcblx0XHRcdC8qIElmIGZsYWdzIHJlcXVlc3RlZCwgYWx3YXlzIGRvIGEgcmUtYXR0YWNoLiBUT0RPIG9ubHkgZG8gdGhpcyBpZlxuXHRcdFx0ICogY3VycmVudCBtb2RlIGRpZmZlcnMgZnJvbSByZXF1ZXN0ZWQgbW9kZSAqL1xuXHRcdFx0dGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBmbGFncztcblx0XHR9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fYXR0YWNoKGZhbHNlLCBudWxsLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fYXR0YWNoID0gZnVuY3Rpb24oZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKCknLCAnQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hpbmcnIHx8IGZvcmNlUmVhdHRhY2gpIHtcblx0XHRcdHRoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCBhdHRhY2hSZWFzb24pO1xuXHRcdH1cblxuXHRcdHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gYXR0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSAnICsgdGhpcy5ldmVudCwgOTAwMDAsIDUwMCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0F0dGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGRldGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoSW1wbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2hJbXBsKCknLCAnc2VuZGluZyBBVFRBQ0ggbWVzc2FnZScpO1xuXHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCB0cnVlKTtcblx0XHR2YXIgYXR0YWNoTXNnID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5BVFRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZSwgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtc30pO1xuXHRcdGlmKHRoaXMuX3JlcXVlc3RlZEZsYWdzKSB7XG5cdFx0XHRhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKHRoaXMuX3JlcXVlc3RlZEZsYWdzKTtcblx0XHR9IGVsc2UgaWYodGhpcy5jaGFubmVsT3B0aW9ucy5tb2Rlcykge1xuXHRcdFx0YXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hbGxUb1VwcGVyQ2FzZSh0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX2F0dGFjaFJlc3VtZSkge1xuXHRcdFx0YXR0YWNoTXNnLnNldEZsYWcoJ0FUVEFDSF9SRVNVTUUnKTtcblx0XHR9XG5cdFx0aWYodGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuXHRcdFx0YXR0YWNoTXNnLmNoYW5uZWxTZXJpYWwgPSB0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsO1xuXHRcdH1cblx0XHR0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZywgbm9vcCk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2RldGFjaCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXHRcdHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0aWYoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZCcsIDkwMDAxLCA0MDApKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnZGV0YWNoaW5nJyk7XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gZGV0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSAnICsgdGhpcy5ldmVudCwgOTAwMDAsIDUwMCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0RldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaEltcGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKScsICdzZW5kaW5nIERFVEFDSCBtZXNzYWdlJyk7XG5cdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIHRydWUpO1xuXHRcdHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkRFVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lfSk7XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIChjYWxsYmFjayB8fCBub29wKSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuXHRcdHZhciBhcmdzID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcblxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0aGlzLnN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoUmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0YWNoKGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBjaGVjayBwcmVjb25kaXRpb25zICovXG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNDAwMDApO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0dGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcblx0XHR9XG5cblx0XHQvKiBzZW5kIHN5bmMgcmVxdWVzdCAqL1xuXHRcdHZhciBzeW5jTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuU1lOQywgY2hhbm5lbDogdGhpcy5uYW1lfSk7XG5cdFx0aWYodGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCkge1xuXHRcdFx0c3luY01lc3NhZ2UuY2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWw7XG5cdFx0fVxuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoc3luY01lc3NhZ2UpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihtc2csIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5yZWFsdGltZS5vcHRpb25zLnF1ZXVlTWVzc2FnZXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNlbmRQcmVzZW5jZSA9IGZ1bmN0aW9uKHByZXNlbmNlLCBjYWxsYmFjaykge1xuXHRcdHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG5cdFx0XHRjaGFubmVsOiB0aGlzLm5hbWUsXG5cdFx0XHRwcmVzZW5jZTogKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkocHJlc2VuY2UpID9cblx0XHRcdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXNBcnJheShwcmVzZW5jZSkgOlxuXHRcdFx0XHRbcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocHJlc2VuY2UpXSlcblx0XHR9KTtcblx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG5cdFx0c3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XG5cdFx0Y2FzZSBhY3Rpb25zLkFUVEFDSEVEOlxuXHRcdFx0dGhpcy5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPSB0cnVlO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcblx0XHRcdHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcblx0XHRcdHRoaXMucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgfHwge307XG5cdFx0XHR2YXIgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG5cdFx0XHR0aGlzLm1vZGVzID0gKG1vZGVzRnJvbUZsYWdzICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbFRvTG93ZXJDYXNlKG1vZGVzRnJvbUZsYWdzKSkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0dmFyIHJlc3VtZWQgPSBtZXNzYWdlLmhhc0ZsYWcoJ1JFU1VNRUQnKTtcblx0XHRcdHZhciBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJyk7XG5cdFx0XHRpZih0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdC8qIGF0dGFjaGVkIG9wZXJhdGlvbnMgdG8gY2hhbmdlIG9wdGlvbnMgc2V0IHRoZSBpbnByb2dyZXNzIG11dGV4LCBidXQgbGVhdmVcblx0XHRcdFx0ICogY2hhbm5lbCBpbiB0aGUgYXR0YWNoZWQgc3RhdGUgKi9cblx0XHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHRcdFx0aWYoIXJlc3VtZWQpIHtcblx0XHRcdFx0XHQvKiBPbiBhIGxvc3Mgb2YgY29udGludWl0eSwgdGhlIHByZXNlbmNlIHNldCBuZWVkcyB0byBiZSByZS1zeW5jZWQgKi9cblx0XHRcdFx0XHR0aGlzLnByZXNlbmNlLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlKHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuXHRcdFx0XHRpZighcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZih0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuXHRcdFx0XHQvKiBSVEw1aTogcmUtc2VuZCBERVRBQ0ggYW5kIHJlbWFpbiBpbiB0aGUgJ2RldGFjaGluZycgc3RhdGUgKi9cblx0XHRcdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgYWN0aW9ucy5ERVRBQ0hFRDpcblx0XHRcdHZhciBlcnIgPSBtZXNzYWdlLmVycm9yID8gZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMobWVzc2FnZS5lcnJvcikgOiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGRldGFjaGVkJywgOTAwMDEsIDQwNCk7XG5cdFx0XHRpZih0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcsIGVycik7XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpIHtcblx0XHRcdFx0LyogT25seSByZXRyeSBpbW1lZGlhdGVseSBpZiB3ZSB3ZXJlIHByZXZpb3VzbHkgYXR0YWNoZWQuIElmIHdlIHdlcmVcblx0XHRcdFx0ICogYXR0YWNoaW5nLCBnbyBpbnRvIHN1c3BlbmRlZCwgZmFpbCBtZXNzYWdlcywgYW5kIHdhaXQgYSBmZXcgc2Vjb25kc1xuXHRcdFx0XHQgKiBiZWZvcmUgcmV0cnlpbmcgKi9cblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCBlcnIpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcblx0XHRcdC8qIHN5bmNzIGNhbiBoYXZlIGNoYW5uZWxTZXJpYWxzLCBidXQgbWlnaHQgbm90IGlmIHRoZSBzeW5jIGlzIG9uZSBwYWdlIGxvbmcgKi9cblx0XHRcdGlzU3luYyA9IHRydWU7XG5cdFx0XHRzeW5jQ2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG5cdFx0XHQvKiBzeW5jcyBjYW4gaGFwcGVuIG9uIGNoYW5uZWxzIHdpdGggbm8gcHJlc2VuY2UgZGF0YSBhcyBwYXJ0IG9mIGNvbm5lY3Rpb25cblx0XHRcdCAqIHJlc3VtaW5nLCBpbiB3aGljaCBjYXNlIHByb3RvY29sIG1lc3NhZ2UgaGFzIG5vIHByZXNlbmNlIHByb3BlcnR5ICovXG5cdFx0XHRpZighbWVzc2FnZS5wcmVzZW5jZSkgYnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLlBSRVNFTkNFOlxuXHRcdFx0dmFyIHByZXNlbmNlID0gbWVzc2FnZS5wcmVzZW5jZSxcblx0XHRcdFx0aWQgPSBtZXNzYWdlLmlkLFxuXHRcdFx0XHRjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0dGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBwcmVzZW5jZU1zZyA9IHByZXNlbmNlW2ldO1xuXHRcdFx0XHRcdHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGUocHJlc2VuY2VNc2csIG9wdGlvbnMpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkKSBwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy50aW1lc3RhbXApIHByZXNlbmNlTXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLmlkKSBwcmVzZW5jZU1zZy5pZCA9IGlkICsgJzonICsgaTtcblx0XHRcdH1cblx0XHRcdHRoaXMucHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2UsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuTUVTU0FHRTpcblxuXHRcdFx0Ly9SVEwxN1xuXHRcdFx0aWYodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnTWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIHNraXBwZWQgYXMgdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIiBzdGF0ZSBpcyBub3QgXCJhdHRhY2hlZFwiIChzdGF0ZSBpcyBcIicgKyB0aGlzLnN0YXRlICsgJ1wiKS4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLFxuXHRcdFx0XHRmaXJzdE1lc3NhZ2UgPSBtZXNzYWdlc1swXSxcblx0XHRcdFx0bGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXSxcblx0XHRcdFx0aWQgPSBtZXNzYWdlLmlkLFxuXHRcdFx0XHRjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCxcblx0XHRcdFx0dGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG5cblx0XHRcdGlmKGZpcnN0TWVzc2FnZS5leHRyYXMgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZyb20gIT09IHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBvbiB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiLic7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIG1zZyk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDAxOCwgNDAwKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIG1zZyA9IG1lc3NhZ2VzW2ldO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlKG1zZywgdGhpcy5fZGVjb2RpbmdDb250ZXh0KTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8qIGRlY3J5cHQgZmFpbGVkIC4uIHRoZSBtb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IHdlIGhhdmUgdGhlIHdyb25nIGtleSAqL1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0c3dpdGNoKGUuY29kZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSA0MDAxODpcblx0XHRcdFx0XHRcdFx0LyogZGVjb2RlIGZhaWx1cmUgKi9cblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdGNhc2UgNDAwMTk6XG5cdFx0XHRcdFx0XHRcdC8qIE5vIHZjZGlmZiBwbHVnaW4gcGFzc2VkIGluIC0gbm8gcG9pbnQgcmVjb3ZlcmluZywgZ2l2ZSB1cCAqL1xuXHRcdFx0XHRcdFx0Y2FzZSA0MDAyMTpcblx0XHRcdFx0XHRcdFx0LyogQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGRlbHRhcywgc2ltaWxhcmx5IG5vIHBvaW50IHJlY292ZXJpbmcgKi9cblx0XHRcdFx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIW1zZy5jb25uZWN0aW9uSWQpIG1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGlmKCFtc2cudGltZXN0YW1wKSBtc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuXHRcdFx0XHRpZighbXNnLmlkKSBtc2cuaWQgPSBpZCArICc6JyArIGk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQgPSBsYXN0TWVzc2FnZS5pZDtcblx0XHRcdHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG5cdFx0XHR0aGlzLm9uRXZlbnQobWVzc2FnZXMpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuRVJST1I6XG5cdFx0XHQvKiB0aGVyZSB3YXMgYSBjaGFubmVsLXNwZWNpZmljIGVycm9yICovXG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvcjtcblx0XHRcdGlmKGVyciAmJiBlcnIuY29kZSA9PSA4MDAxNikge1xuXHRcdFx0XHQvKiBhdHRhY2gvZGV0YWNoIG9wZXJhdGlvbiBhdHRlbXB0ZWQgb24gc3VwZXJzZWRlZCB0cmFuc3BvcnQgaGFuZGxlICovXG5cdFx0XHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGVycikpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ0ZhdGFsIHByb3RvY29sIGVycm9yOiB1bnJlY29nbmlzZWQgYWN0aW9uICgnICsgbWVzc2FnZS5hY3Rpb24gKyAnKScpO1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5hYm9ydChjb25uZWN0aW9uZXJyb3JbXCJhXCIgLyogZGVmYXVsdCAqL10udW5rbm93bkNoYW5uZWxFcnIpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZighdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ1N0YXJ0aW5nIGRlY29kZSBmYWlsdXJlIHJlY292ZXJ5IHByb2Nlc3MuJyk7XG5cdFx0XHR0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2F0dGFjaCh0cnVlLCByZWFzb24sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWQnLCAnYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gJyArIHRoaXMubmFtZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm5vdGlmeVN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgY3VycmVudCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlICsgJywgbm90aWZ5aW5nIHN0YXRlICcgKyBzdGF0ZSk7XG5cdFx0dGhpcy5jbGVhclN0YXRlVGltZXIoKTtcblxuXHRcdGlmKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucHJlc2VuY2UuYWN0T25DaGFubmVsU3RhdGUoc3RhdGUsIGhhc1ByZXNlbmNlLCByZWFzb24pO1xuXHRcdGlmKHN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdHRoaXMuc3RhcnRSZXRyeVRpbWVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuXHRcdH1cblx0XHRpZihyZWFzb24pIHtcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSByZWFzb247XG5cdFx0fVxuXHRcdHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlKHRoaXMuc3RhdGUsIHN0YXRlLCByZXN1bWVkLCByZWFzb24pO1xuXHRcdHZhciBsb2dMZXZlbCA9IHN0YXRlID09PSAnZmFpbGVkJyA/IGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IgOiBsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nTGV2ZWwsICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIicsIHN0YXRlICsgKHJlYXNvbiA/ICgnOyByZWFzb246ICcgKyByZWFzb24pIDogJycpKTtcblxuXHRcdC8qIE5vdGU6IHdlIGRvbid0IHNldCBpblByb2dyZXNzIGZvciBwZW5kaW5nIHN0YXRlcyB1bnRpbCB0aGUgcmVxdWVzdCBpcyBhY3R1YWxseSBpbiBwcm9ncmVzcyAqL1xuXHRcdGlmKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHR0aGlzLm9uQXR0YWNoZWQoKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzeW5jT3AsIGhhc1ByZXNlbmNlKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmKHN0YXRlID09PSAnZGV0YWNoZWQnIHx8IHN0YXRlID09PSAnZmFpbGVkJyB8fCBzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3luY09wLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0aWYoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdHRoaXMuX2F0dGFjaFJlc3VtZSA9IHRydWU7XG5cdFx0fSBlbHNlIGlmKHN0YXRlID09PSAnZGV0YWNoaW5nJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdHRoaXMuX2F0dGFjaFJlc3VtZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuXHRcdHRoaXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnJlcXVlc3RTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24pIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgc3RhdGUpO1xuXHRcdHRoaXMubm90aWZ5U3RhdGUoc3RhdGUsIHJlYXNvbik7XG5cdFx0Lyogc2VuZCB0aGUgZXZlbnQgYW5kIGF3YWl0IHJlc3BvbnNlICovXG5cdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2hlY2tQZW5kaW5nU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBpZiBjYW4ndCBzZW5kIGV2ZW50cywgZG8gbm90aGluZyAqL1xuXHRcdHZhciBjbVN0YXRlID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZTtcblx0XHQvKiBBbGxvdyBhdHRhY2ggbWVzc2FnZXMgdG8gcXVldWUgdXAgd2hlbiBzeW5jaHJvbml6aW5nLCBzaW5jZSB0aGlzIHdpbGwgYmVcblx0XHQgKiB0aGUgc3RhdGUgd2UnbGwgYmUgaW4gd2hlbiB1cGdyYWRlIHRyYW5zcG9ydC5hY3RpdmUgdHJpZ2dlcnMgYSBjaGVja3BlbmRpbmdzdGF0ZSAqL1xuXHRcdGlmKCEoY21TdGF0ZS5zZW5kRXZlbnRzIHx8IGNtU3RhdGUuZm9yY2VRdWV1ZUV2ZW50cykpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICdzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSk7XG5cdFx0LyogT25seSBzdGFydCB0aGUgc3RhdGUgdGltZXIgcnVubmluZyB3aGVuIGFjdHVhbGx5IHNlbmRpbmcgdGhlIGV2ZW50ICovXG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG5cdFx0XHRcdHRoaXMuYXR0YWNoSW1wbCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRcdHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG5cdFx0XHRcdHRoaXMuZGV0YWNoSW1wbCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0LyogcmVzdW1lIGFueSBzeW5jIG9wZXJhdGlvbiB0aGF0IHdhcyBpbiBwcm9ncmVzcyAqL1xuXHRcdFx0XHR0aGlzLnN5bmMoKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnRpbWVvdXRQZW5kaW5nU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0dmFyIGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NoYW5uZWwgYXR0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGRldGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKCF0aGlzLnN0YXRlVGltZXIpIHtcblx0XHRcdHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcnLCAndGltZXIgZXhwaXJlZCcpO1xuXHRcdFx0XHRzZWxmLnN0YXRlVGltZXIgPSBudWxsO1xuXHRcdFx0XHRzZWxmLnRpbWVvdXRQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0sIHRoaXMucmVhbHRpbWUub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jbGVhclN0YXRlVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcblx0XHRpZihzdGF0ZVRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoc3RhdGVUaW1lcik7XG5cdFx0XHR0aGlzLnN0YXRlVGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN0YXJ0UmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZih0aGlzLnJldHJ5VGltZXIpIHJldHVybjtcblxuXHRcdHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBJZiBjb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQsIGp1c3QgbGVhdmUgaW4gc3VzcGVuZGVkLCBhIHJlYXR0YWNoXG5cdFx0XHQgKiB3aWxsIGJlIHRyaWdnZXJlZCBvbmNlIGl0IGNvbm5lY3RzIGFnYWluICovXG5cdFx0XHRpZihzZWxmLnN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiBzZWxmLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdFx0c2VsZi5yZXRyeVRpbWVyID0gbnVsbDtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAnYXR0ZW1wdGluZyBhIG5ldyBhdHRhY2gnKTtcblx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMucmVhbHRpbWUub3B0aW9ucy50aW1lb3V0cy5jaGFubmVsUmV0cnlUaW1lb3V0KTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLnJldHJ5VGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuXHRcdFx0dGhpcy5zdXNwZW5kVGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbihvcGVyYXRpb24sIHZhbHVlKSB7XG5cdFx0dGhpcy5yZXN0LmNoYW5uZWxzLnNldEluUHJvZ3Jlc3ModGhpcywgb3BlcmF0aW9uLCB2YWx1ZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG5cdFx0XHRpZih0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWRcIiwgNDAwMDAsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCkge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwidW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZFwiLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG5cdFx0XHRwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuXHRcdH1cblxuXHRcdGNsaWVudF9jaGFubmVsLnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGxpc3RlbmVyKSB7XG5cdFx0cmV0dXJuIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwodGhpcywgc3RhdGUsIHRoaXMuc3RhdGUsIGxpc3RlbmVyKTtcblx0fVxuXG5cdC8qIEByZXR1cm5zIG51bGwgKGlmIGNhbiBzYWZlbHkgYmUgcmVsZWFzZWQpIHwgRXJyb3JJbmZvIChpZiBjYW5ub3QpICovXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZ2V0UmVsZWFzZUVyciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzID0gdGhpcy5zdGF0ZTtcblx0XHRpZihzID09PSAnaW5pdGlhbGl6ZWQnIHx8IHMgPT09ICdkZXRhY2hlZCcgfHwgcyA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2FuIG9ubHkgcmVsZWFzZSBhIGNoYW5uZWwgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBpcyBubyBwb3NzaWJpbGl0eSBvZiBmdXJ0aGVyIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyIGJlaW5nIHJlY2VpdmVkIChpbml0aWFsaXplZCwgZGV0YWNoZWQsIG9yIGZhaWxlZCk7IHdhcyAnICsgcywgOTAwMDEsIDQwMCk7XG5cdH1cblxuXHRyZXR1cm4gUmVhbHRpbWVDaGFubmVsO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcmVhbHRpbWVjaGFubmVsID0gKHJlYWx0aW1lY2hhbm5lbF9SZWFsdGltZUNoYW5uZWwpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2Vycm9ycmVwb3J0ZXIuanNcbnZhciBlcnJvcnJlcG9ydGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWUuanNcblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJlYWx0aW1lX1JlYWx0aW1lID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIFJlYWx0aW1lKG9wdGlvbnMpIHtcblx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBSZWFsdGltZSkpe1xuXHRcdFx0cmV0dXJuIG5ldyBSZWFsdGltZShvcHRpb25zKTtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZSgpJywgJycpO1xuXHRcdGNsaWVudF9yZXN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uID0gbmV3IGNvbm5lY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcblx0XHR0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMpO1xuXHRcdGlmKG9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUmVhbHRpbWUsIGNsaWVudF9yZXN0KTtcblxuXHRSZWFsdGltZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNvbm5lY3QoKScsICcnKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuXHR9O1xuXG5cdFJlYWx0aW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNsb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQ2hhbm5lbHMocmVhbHRpbWUpIHtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XG5cdFx0dGhpcy5hbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMuaW5Qcm9ncmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYub25UcmFuc3BvcnRBY3RpdmUoKTtcblx0XHR9KTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDaGFubmVscywgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuXHRcdGlmKGNoYW5uZWxOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSAnICsgbXNnLmFjdGlvbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgZm9yIG5vbi1leGlzdGVudCBjaGFubmVsOiAnICsgY2hhbm5lbE5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjaGFubmVsLm9uTWVzc2FnZShtc2cpO1xuXHR9O1xuXG5cdC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuXHQgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy5cblx0ICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgdXNlIGluUHJvZ3Jlc3MgYXMgaW5Qcm9ncmVzcyBpcyBvbmx5IGNoYW5uZWxzIHdoaWNoIGhhdmUgYWxyZWFkeSBtYWRlXG5cdCogYXQgbGVhc3Qgb25lIGF0dGVtcHQgdG8gYXR0YWNoL2RldGFjaCAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUub25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hpbmcnIHx8IGNoYW5uZWwuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG5cdFx0XHRcdGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSBpZihjaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0XHRjaGFubmVsLmF0dGFjaCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUucmVhdHRhY2ggPSBmdW5jdGlvbihyZWFzb24pIHtcblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0LyogTkIgdGhpcyBzaG91bGQgbm90IHRyaWdnZXIgZm9yIG1lcmVseSBhdHRhY2hpbmcgY2hhbm5lbHMsIGFzIHRoZXkgd2lsbFxuXHRcdFx0ICogYmUgcmVhdHRhY2hlZCBhbnl3YXkgdGhyb3VnaCB0aGUgb25UcmFuc3BvcnRBY3RpdmUgY2hlY2tQZW5kaW5nU3RhdGUgKi9cblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0Y2hhbm5lbC5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZXNldEF0dGFjaGVkTXNnSW5kaWNhdG9ycyA9IGZ1bmN0aW9uKCkge1xuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRjaGFubmVsLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUuY2hlY2tBdHRhY2hlZE1zZ0luZGljYXRvcnMgPSBmdW5jdGlvbihjb25uZWN0aW9uSWQpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyAmJiBjaGFubmVsLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICczMHMgYWZ0ZXIgYSByZXN1bWUsIGZvdW5kIGNoYW5uZWwgd2hpY2ggaGFzIG5vdCByZWNlaXZlZCBhbiBhdHRhY2hlZDsgY2hhbm5lbElkID0gJyArIGNoYW5uZWxJZCArICc7IGNvbm5lY3Rpb25JZCA9ICcgKyBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzKCknLCBtc2cpO1xuXHRcdFx0XHRlcnJvcnJlcG9ydGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlcG9ydCgnZXJyb3InLCBtc2csICdjaGFubmVsLW5vLWF0dGFjaGVkLWFmdGVyLXJlc3VtZScpO1xuXHRcdFx0XHRjaGFubmVsLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcblx0ICogZXZlbnRzKSBpbXBseSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXMgZm9yIGFueSBjaGFubmVsIHdoaWNoIGlzIGVpdGhlclxuXHQgKiBhdHRhY2hlZCwgcGVuZGluZywgb3Igd2lsbCBhdHRlbXB0IHRvIGJlY29tZSBhdHRhY2hlZCBpbiB0aGUgZnV0dXJlICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvblN0YXRlLCByZWFzb24pIHtcblx0XHR2YXIgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG5cdFx0XHQnY2xvc2luZycgIDogJ2RldGFjaGVkJyxcblx0XHRcdCdjbG9zZWQnICAgOiAnZGV0YWNoZWQnLFxuXHRcdFx0J2ZhaWxlZCcgICA6ICdmYWlsZWQnLFxuXHRcdFx0J3N1c3BlbmRlZCc6ICdzdXNwZW5kZWQnXG5cdFx0fTtcblx0XHR2YXIgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbJ2F0dGFjaGluZycsICdhdHRhY2hlZCcsICdkZXRhY2hpbmcnLCAnc3VzcGVuZGVkJ107XG5cdFx0dmFyIHRvQ2hhbm5lbFN0YXRlID0gY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGVbY29ubmVjdGlvblN0YXRlXTtcblxuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcblx0XHRcdFx0IGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0Y2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdID0gbmV3IHJlYWx0aW1lY2hhbm5lbCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHRpZiAoY2hhbm5lbC5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJDaGFubmVscy5nZXQoKSBjYW5ub3QgYmUgdXNlZCB0byBzZXQgY2hhbm5lbCBvcHRpb25zIHRoYXQgd291bGQgY2F1c2UgdGhlIGNoYW5uZWwgdG8gcmVhdHRhY2guIFBsZWFzZSwgdXNlIFJlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCkgaW5zdGVhZC5cIiwgNDAwMDAsIDQwMCk7XG5cdFx0XHR9XG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fTtcblxuXHQvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cblx0ICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG5cdFx0aWYocmVsZWFzZUVycikge1xuXHRcdFx0dGhyb3cgcmVsZWFzZUVycjtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuXHRcdGRlbGV0ZSB0aGlzLmluUHJvZ3Jlc3NbbmFtZV07XG5cdH07XG5cblx0LyogUmVjb3JkcyBvcGVyYXRpb25zIGN1cnJlbnRseSBwZW5kaW5nIG9uIGEgdHJhbnNwb3J0OyB1c2VkIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIHRvIGRlY2lkZSB3aGVuXG5cdCAqIGl0J3Mgc2FmZSB0byB1cGdyYWRlLiBOb3RlIHRoYXQgYSBjaGFubmVsIG1pZ2h0IGJlIGluIHRoZSBhdHRhY2hpbmcgc3RhdGUgd2l0aG91dCBhbnkgcGVuZGluZ1xuXHQgKiBvcGVyYXRpb25zIChlZyBpZiBhdHRhY2hlZCB3aGlsZSB0aGUgY29ubmVjdGlvbiBzdGF0ZSBpcyBjb25uZWN0aW5nKSAtIHN1Y2ggYSBjaGFubmVsIG11c3Qgbm90XG5cdCAqIGhvbGQgdXAgYW4gdXBncmFkZSwgc28gaXMgbm90IGNvbnNpZGVyZWQgaW5Qcm9ncmVzcy5cblx0ICogT3BlcmF0aW9uIGlzIGN1cnJlbnRseSBvbmUgb2YgZWl0aGVyICdzdGF0ZWNoYW5nZScgb3IgJ3N5bmMnICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24oY2hhbm5lbCwgb3BlcmF0aW9uLCBpblByb2dyZXNzKSB7XG5cdFx0dGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV0gPSB0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXSB8fCB7fTtcblx0XHR0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXVtvcGVyYXRpb25dID0gaW5Qcm9ncmVzcztcblx0XHRpZighaW5Qcm9ncmVzcyAmJiB0aGlzLmhhc05vcGVuZGluZygpKSB7XG5cdFx0XHR0aGlzLmVtaXQoJ25vcGVuZGluZycpO1xuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUub25jZU5vcGVuZGluZyA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0aWYodGhpcy5oYXNOb3BlbmRpbmcoKSkge1xuXHRcdFx0bGlzdGVuZXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vbmNlKCdub3BlbmRpbmcnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmhhc05vcGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJFdmVyeSh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS52YWx1ZXNBcnJheSh0aGlzLmluUHJvZ3Jlc3MsIHRydWUpLCBmdW5jdGlvbihvcGVyYXRpb25zKSB7XG5cdFx0XHRyZXR1cm4gIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvbnRhaW5zVmFsdWUob3BlcmF0aW9ucywgdHJ1ZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIFJlYWx0aW1lO1xufSkoKTtcblxucmVhbHRpbWVfUmVhbHRpbWUuUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG5cdG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuXHRyZXR1cm4gbmV3IHJlYWx0aW1lX1JlYWx0aW1lKG9wdGlvbnMpO1xufTtcblxucmVhbHRpbWVfUmVhbHRpbWUuQ2FsbGJhY2tzID0gcmVhbHRpbWVfUmVhbHRpbWU7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9yZWFsdGltZSA9IChyZWFsdGltZV9SZWFsdGltZSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL21zZ3BhY2suanNcbnZhciB1dGlsX21zZ3BhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2luZGV4LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xpZW50X3Jlc3QuVXRpbHMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0LkJ1ZmZlclV0aWxzID0gYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5DcnlwdG8gPSB1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0LkRlZmF1bHRzID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5IdHRwID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0LlJlc291cmNlID0gY2xpZW50X3Jlc291cmNlO1xuY2xpZW50X3Jlc3QuTWVzc2FnZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5QcmVzZW5jZU1lc3NhZ2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5cbmNsaWVudF9yZWFsdGltZS5VdGlscyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkJ1ZmZlclV0aWxzID0gYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuQ3J5cHRvID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuRGVmYXVsdHMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5IdHRwID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5NZXNzYWdlID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5QcmVzZW5jZU1lc3NhZ2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuUHJvdG9jb2xNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJbXCJhXCIgLyogZGVmYXVsdCAqL107XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpYiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgUmVzdDogY2xpZW50X3Jlc3QsXG4gIFJlYWx0aW1lOiBjbGllbnRfcmVhbHRpbWUsXG4gIG1zZ3BhY2s6IHV0aWxfbXNncGFja1tcImFcIiAvKiBkZWZhdWx0ICovXVxufSk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IChvcHRpb25zLmluZGV4T2YoJzonKSA9PSAtMSkgPyB7dG9rZW46IG9wdGlvbnN9IDoge2tleTogb3B0aW9uc307XG4gIH1cbiAgb3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBmaWxlIGltcG9ydGVkIGJlbG93IGlzIG9ubHkgZ2VuZXJhdGVkIGFmdGVyIHJ1bm5pbmcgXG4gKiB0aGUgYnVpbGQgdGFzay4gKi9cbnZhciBBYmx5ID0gcmVxdWlyZSgnLi9icm93c2VyL3N0YXRpYy9hYmx5LW5vZGUnKTtcblxudmFyIFJlc3RQcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFibHkuUmVzdChwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpKTtcbn1cbk9iamVjdC5hc3NpZ24oUmVzdFByb21pc2UsIEFibHkuUmVzdCk7XG5cbnZhciBSZWFsdGltZVByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQWJseS5SZWFsdGltZShwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpKTtcbn1cbk9iamVjdC5hc3NpZ24oUmVhbHRpbWVQcm9taXNlLCBBYmx5LlJlYWx0aW1lKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlc3Q6IFJlc3RQcm9taXNlLFxuICBSZWFsdGltZTogUmVhbHRpbWVQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKVxuICAgID8gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKVxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMl0hLi9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMl0hLi9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMl0hLi9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5jaGF0Q29tcG9uZW50c19jaGF0SG9sZGVyX18yRTFBWCB7XFxyXFxuICBkaXNwbGF5OiBncmlkO1xcclxcbiAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMTAwcHg7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19jaGF0VGV4dF9fM01SRXMge1xcclxcbiAgZGlzcGxheTogLW1vei1ib3g7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgLW1vei1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXHJcXG4gIC1tb3otYm94LWRpcmVjdGlvbjogbm9ybWFsO1xcclxcbiAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgLW1vei1ib3gtYWxpZ246IHN0YXJ0O1xcclxcbiAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG4gIGdyaWQtZ2FwOiAxZW07XFxyXFxuICBnYXA6IDFlbTtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGhlaWdodDogLXdlYmtpdC1jYWxjKDEwMHZoIC0gNDBweCAtIDEwMHB4IC0gMTAwcHggLSAxMDBweCk7XFxyXFxuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA0MHB4IC0gMTAwcHggLSAxMDBweCAtIDEwMHB4KTtcXHJcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19mb3JtX18zckZJSyB7XFxyXFxuICBkaXNwbGF5OiBncmlkO1xcclxcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMTAwcHg7XFxyXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VlZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX3RleHRhcmVhX18yVXVMeSB7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sXFxyXFxuICAgIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcclxcbiAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU0ge1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LXNpemU6IDEuNGVtO1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCByaWdodCB0b3AsIGZyb20oIzM2Mzc5NSksIHRvKCMwMDVjOTcpKTtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU06aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXHJcXG4gICAgbGluZWFyLFxcclxcbiAgICBsZWZ0IHRvcCwgcmlnaHQgdG9wLFxcclxcbiAgICBmcm9tKHJnYmEoNTQsIDU1LCAxNDksIDEpKSxcXHJcXG4gICAgY29sb3Itc3RvcCg2MiUsIHJnYmEoMCwgOTIsIDE1MSwgMSkpLFxcclxcbiAgICB0byhyZ2JhKDAsIDEyNSwgMjA1LCAxKSlcXHJcXG4gICk7XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgbGVmdCxcXHJcXG4gICAgcmdiYSg1NCwgNTUsIDE0OSwgMSkgMCUsXFxyXFxuICAgIHJnYmEoMCwgOTIsIDE1MSwgMSkgNjIlLFxcclxcbiAgICByZ2JhKDAsIDEyNSwgMjA1LCAxKSAxMDAlXFxyXFxuICApO1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcclxcbiAgICA5MGRlZyxcXHJcXG4gICAgcmdiYSg1NCwgNTUsIDE0OSwgMSkgMCUsXFxyXFxuICAgIHJnYmEoMCwgOTIsIDE1MSwgMSkgNjIlLFxcclxcbiAgICByZ2JhKDAsIDEyNSwgMjA1LCAxKSAxMDAlXFxyXFxuICApO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TTpkaXNhYmxlZCxcXHJcXG4uY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TTpob3ZlcjpkaXNhYmxlZCB7XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIHJpZ2h0IHRvcCwgZnJvbSgjMzYzNzk1KSwgdG8oIzAwNWM5NykpO1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbiAgb3BhY2l0eTogMC41O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfbWVzc2FnZV9fMWRub0Ige1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZjVmODtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAtbW96LWJveC1mbGV4OiAwO1xcclxcbiAgICAgICBmbGV4LWdyb3c6IDA7XFxyXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsYUFBYTtFQUNiLDZCQUE2QjtBQUMvQjs7QUFFQTtFQUNFLGlCQUFhO0VBQWIsYUFBYTtFQUNiLHlCQUFzQjtFQUF0QiwwQkFBc0I7T0FBdEIsc0JBQXNCO0VBQ3RCLHFCQUF1QjtPQUF2Qix1QkFBdUI7RUFDdkIsYUFBUTtFQUFSLFFBQVE7RUFDUixZQUFZO0VBQ1osMERBQWtEO0VBQWxELGtEQUFrRDtFQUNsRCxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsZ0NBQWdDO0VBQ2hDLDBCQUEwQjtBQUM1Qjs7QUFFQTtFQUNFLFlBQVk7RUFDWixTQUFTO0VBQ1Q7d0VBQ3NFO0VBQ3RFLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLFNBQVM7RUFDVCxZQUFZO0VBQ1osaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixxRkFBdUQ7RUFBdkQsMkRBQXVEO0VBQXZELHVEQUF1RDtBQUN6RDs7QUFFQTtFQUNFOzs7Ozs7R0FLQztFQUxEOzs7OztHQUtDO0VBTEQ7Ozs7O0dBS0M7QUFDSDs7QUFFQTs7RUFFRSxxRkFBdUQ7RUFBdkQsMkRBQXVEO0VBQXZELHVEQUF1RDtFQUN2RCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSx5QkFBeUI7RUFDekIsWUFBWTtFQUNaLG1CQUFtQjtFQUNuQixnQkFBWTtPQUFaLFlBQVk7RUFDWiw0QkFBNEI7QUFDOUJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmNoYXRIb2xkZXIge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdFRleHQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG4gIGdhcDogMWVtO1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNDBweCAtIDEwMHB4IC0gMTAwcHggLSAxMDBweCk7XFxyXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4uZm9ybSB7XFxyXFxuICBkaXNwbGF5OiBncmlkO1xcclxcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMTAwcHg7XFxyXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VlZTtcXHJcXG59XFxyXFxuXFxyXFxuLnRleHRhcmVhIHtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlcjogMDtcXHJcXG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbixcXHJcXG4gICAgVWJ1bnR1LCBDYW50YXJlbGwsIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsIHNhbnMtc2VyaWY7XFxyXFxuICBmb250LXNpemU6IDEuMmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uIHtcXHJcXG4gIGJvcmRlcjogMDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgZm9udC1zaXplOiAxLjRlbTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxufVxcclxcblxcclxcbi5idXR0b246aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcclxcbiAgICA5MGRlZyxcXHJcXG4gICAgcmdiYSg1NCwgNTUsIDE0OSwgMSkgMCUsXFxyXFxuICAgIHJnYmEoMCwgOTIsIDE1MSwgMSkgNjIlLFxcclxcbiAgICByZ2JhKDAsIDEyNSwgMjA1LCAxKSAxMDAlXFxyXFxuICApO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uOmRpc2FibGVkLFxcclxcbi5idXR0b246aG92ZXI6ZGlzYWJsZWQge1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG4gIG9wYWNpdHk6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLm1lc3NhZ2Uge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZjVmODtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICBmbGV4LWdyb3c6IDA7XFxyXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjaGF0SG9sZGVyXCI6IFwiY2hhdENvbXBvbmVudHNfY2hhdEhvbGRlcl9fMkUxQVhcIixcblx0XCJjaGF0VGV4dFwiOiBcImNoYXRDb21wb25lbnRzX2NoYXRUZXh0X18zTVJFc1wiLFxuXHRcImZvcm1cIjogXCJjaGF0Q29tcG9uZW50c19mb3JtX18zckZJS1wiLFxuXHRcInRleHRhcmVhXCI6IFwiY2hhdENvbXBvbmVudHNfdGV4dGFyZWFfXzJVdUx5XCIsXG5cdFwiYnV0dG9uXCI6IFwiY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TVwiLFxuXHRcIm1lc3NhZ2VcIjogXCJjaGF0Q29tcG9uZW50c19tZXNzYWdlX18xZG5vQlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBhcnJheVdpdGhIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCBub25JdGVyYWJsZVJlc3QgZnJvbSBcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufSJdLCJuYW1lcyI6WyJBYmx5IiwidXNlRWZmZWN0IiwiYWJseSIsIlJlYWx0aW1lIiwiUHJvbWlzZSIsImF1dGhVcmwiLCJ1c2VDaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJjYWxsYmFja09uTWVzc2FnZSIsImNoYW5uZWwiLCJjaGFubmVscyIsImdldCIsIm9uTW91bnQiLCJzdWJzY3JpYmUiLCJtc2ciLCJvblVuTW91bnQiLCJ1bnN1YnNjcmliZSIsInVzZUVmZmVjdEhvb2siLCJSZWFjdCIsInVzZVN0YXRlIiwic3R5bGVzIiwiQ2hhdENvbXBvbmVudCIsImlucHV0Qm94IiwibWVzc2FnZUVuZCIsIm1lc3NhZ2VUZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJyZWNlaXZlZE1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJtZXNzYWdlVGV4dElzRW1wdHkiLCJ0cmltIiwibGVuZ3RoIiwibWVzc2FnZSIsImhpc3RvcnkiLCJzbGljZSIsInNlbmRDaGF0TWVzc2FnZSIsInB1Ymxpc2giLCJuYW1lIiwiZGF0YSIsImZvY3VzIiwiaGFuZGxlRm9ybVN1Ym1pc3Npb24iLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlS2V5UHJlc3MiLCJjaGFyQ29kZSIsIm1lc3NhZ2VzIiwibWFwIiwiaW5kZXgiLCJhdXRob3IiLCJjb25uZWN0aW9uSWQiLCJjb25uZWN0aW9uIiwiaWQiLCJtaWxsaXNlY29uZHMiLCJEYXRlIiwidGltZVN0YW1wIiwidG9EYXRlU3RyaW5nIiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvdXIiLCJjaGF0SG9sZGVyIiwiY2hhdFRleHQiLCJlbGVtZW50IiwiZm9ybSIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsInRleHRhcmVhIiwiYnV0dG9uIl0sInNvdXJjZVJvb3QiOiIifQ==