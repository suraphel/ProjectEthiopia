(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_chatroom_chatComponents_js"],{

/***/ "./components/chatroom/AblyReactEffect.js":
/*!************************************************!*\
  !*** ./components/chatroom/AblyReactEffect.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useChannel": function() { return /* binding */ useChannel; }
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();

//offer company name and logo
// textarea for his offer
// hidden and appear
// states for rendering the page
//WebSocket connections
//Ably
//add and Id
//add message storage and retrival
//


var ably = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime.Promise)({
  authUrl: "/api/createTokenRequest"
}); // console.log(ably);

function useChannel(channelName, callbackOnMessage) {
  _s();

  var channel = ably.channels.get(channelName);

  var onMount = function onMount() {
    channel.subscribe(function (msg) {
      callbackOnMessage(msg);
    });
  };

  var onUnMount = function onUnMount() {
    channel.unsubscribe();
  };

  var useEffectHook = function useEffectHook() {
    onMount();
    return function () {
      onUnMount();
    };
  };

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(useEffectHook);
  return [channel, ably];
}

_s(useChannel, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/chatroom/chatComponents.js":
/*!***********************************************!*\
  !*** ./components/chatroom/chatComponents.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var A_Projects_NextJs_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var A_Projects_NextJs_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactEffect */ "./components/chatroom/AblyReactEffect.js");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chatroom/chatComponents.module.css */ "./components/chatroom/chatComponents.module.css");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "A:\\Projects\\NextJs\\Balemoja\\components\\chatroom\\chatComponents.js",
    _this = undefined,
    _s = $RefreshSig$();






var ChatComponent = function ChatComponent() {
  _s();

  var inputBox = null;
  var messageEnd = null;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(""),
      messageText = _useState[0],
      setMessageText = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      receivedMessages = _useState2[0],
      setMessages = _useState2[1];

  var messageTextIsEmpty = messageText.trim().length === 0;

  var _useChannel = (0,_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel)("chat-demo", function (message) {
    var history = receivedMessages.slice(-199);
    setMessages([].concat((0,A_Projects_NextJs_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(history), [message]));
  }),
      _useChannel2 = (0,A_Projects_NextJs_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_useChannel, 2),
      channel = _useChannel2[0],
      ably = _useChannel2[1];

  var sendChatMessage = function sendChatMessage(messageText) {
    channel.publish({
      name: "chat-message",
      data: messageText
    });
    setMessageText("");
    inputBox.focus();
  };

  var handleFormSubmission = function handleFormSubmission(event) {
    event.preventDefault();
    sendChatMessage(messageText);
  };

  var handleKeyPress = function handleKeyPress(event) {
    if (event.charCode !== 13 || messageTextIsEmpty) {
      return;
    }

    sendChatMessage(messageText);
    event.preventDefault();
  };

  var messages = receivedMessages.map(function (message, index) {
    var author = message.connectionId === ably.connection.id ? "me" : "other";
    var milliseconds = new Date();
    var timeStamp = milliseconds.toDateString(); // function parseMillisecondsIntoReadableTime(milliseconds) {
    //   //Get hours from milliseconds
    //   var hours = milliseconds / (1000 * 60 * 60);
    //   var absoluteHours = Math.floor(hours);
    //   var h = absoluteHours > 9 ? absoluteHours : "0" + absoluteHours;
    //   //Get remainder from hours and convert to minutes
    //   var minutes = (hours - absoluteHours) * 60;
    //   var absoluteMinutes = Math.floor(minutes);
    //   var m = absoluteMinutes > 9 ? absoluteMinutes : "0" + absoluteMinutes;
    //   //Get remainder from minutes and convert to seconds
    //   var seconds = (minutes - absoluteMinutes) * 60;
    //   var absoluteSeconds = Math.floor(seconds);
    //   var s = absoluteSeconds > 9 ? absoluteSeconds : "0" + absoluteSeconds;
    //   return h + ":" + m + ":" + s;
    // }
    // var time = parseMillisecondsIntoReadableTime(milliseconds);
    // alert(time);
    // console.log(time);

    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().message) // time={new Date().toString()}
      ,
      "data-author": author,
      children: message.data
    }, index, false, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, _this);
  });
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    messageEnd.scrollIntoView({
      behaviour: "smooth"
    });
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatHolder),
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatText),
      children: [messages, new Date().toDateString(), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        ref: function ref(element) {
          messageEnd = element;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 88,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("form", {
      onSubmit: handleFormSubmission,
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().form),
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("textarea", {
        ref: function ref(element) {
          inputBox = element;
        },
        value: messageText,
        placeholder: "Type a message..." // time={new Date().toString()}
        ,
        onChange: function onChange(e) {
          return setMessageText(e.target.value);
        },
        onKeyPress: handleKeyPress,
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().textarea)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        type: "submit",
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().button),
        disabled: messageTextIsEmpty,
        children: "Send"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 106,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 84,
    columnNumber: 5
  }, _this);
};

_s(ChatComponent, "UHCFF9ns1jrEPUyCddaISRIBzu0=", false, function () {
  return [_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel];
});

_c = ChatComponent;
/* harmony default export */ __webpack_exports__["default"] = (ChatComponent);

var _c;

$RefreshReg$(_c, "ChatComponent");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/ably/browser/static/ably-commonjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/browser/static/ably-commonjs.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*!
 * @license Copyright 2021, Ably
 * 
 * Ably JavaScript Library v1.2.13
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.com
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_749__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_749__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_749__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_749__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_749__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_749__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_749__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_749__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_749__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_749__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_749__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_749__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_749__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_749__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_749__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_749__(__nested_webpack_require_749__.s = 50);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4226__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4226__(3);


var Logger = (function() {
	var consoleLogger, errorLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
		 (global.console && global.console.log && (typeof global.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
		errorLogger = console.warn ? function() { console.warn.apply(console, arguments); } : consoleLogger;
	} else if(global.console && global.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = errorLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = errorLogger = function() {};
	}

	function pad(str, three) {
		return ('000' + str).slice(-2-(three || 0));
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;

	function getHandler(logger) {
		return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logTimestamps ?
			function(msg) {
				var time = new Date();
				logger(pad(time.getHours()) + ':' + pad(time.getMinutes()) + ':' + pad(time.getSeconds()) + '.' + pad(time.getMilliseconds(), true) + ' ' + msg);
			} : logger;
	}

	var logHandler = getHandler(consoleLogger),
		logErrorHandler = getHandler(errorLogger);

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			(level === LOG_ERROR ? logErrorHandler : logHandler)('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
	}

	Logger.deprecatedWithMsg = function(funcName, msg) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = logErrorHandler = handler;
	};

	return Logger;
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_4226__(17)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_7545__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7545__(3);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7545__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_7545__(5);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var Utils = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function Utils() {}

	function randomPosn(arrOrStr) {
		return Math.floor(Math.random() * arrOrStr.length);
	}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target) {
		for(var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			if(!source) { break; }
			for(var key in source) {
				if(hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.forInOwnNonNullProps = function(ob, fn) {
		for (var prop in ob) {
			if (hasOwnProperty.call(ob, prop) && ob[prop]) {
				fn(prop);
			}
		}
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.allSame = function(arr, prop) {
		if(arr.length === 0) {
			return true;
		}
		var first = arr[0][prop];
		return Utils.arrEvery(arr, function(item) {
			return item[prop] === first;
		});
	};

	Utils.nextTick = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		var accept = contentTypes[format || 'json'];
		return {
			accept: accept,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.defaultPostHeaders = function(format) {
		var accept, contentType;
		accept = contentType = contentTypes[format || 'json'];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(randomPosn(arr), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect;

	Utils.isErrorInfo = function(err) {
		return err.constructor.name == 'ErrorInfo'
	};

	Utils.inspectError = function(x) {
		/* redundant, but node vmcontext issue makes instanceof unreliable, and
		 * can't use just constructor test as could be a TypeError constructor etc. */
		return (x && (Utils.isErrorInfo(x) ||
			x.constructor.name == 'Error' ||
			x instanceof Error)) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.inspectBody = function(body) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(body)) {
			return body.toString();
		} else if(typeof body === 'string') {
			return body;
		} else {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(body);
		}
	};

	/* Data is assumed to be either a string or a buffer. */
	Utils.dataSizeBytes = function(data) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].byteLength(data);
		}
		if(typeof data === 'string') {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringByteSize(data);
		}
		throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + (typeof data));
	};

	Utils.cheapRandStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Takes param the minimum number of bytes of entropy the string must
	 * include, not the length of the string. String length produced is not
	 * guaranteed. */
	Utils.randomString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(uIntArr);
		} : function(numBytes) {
			/* Old browser; fall back to Math.random. Could just use a
			 * CryptoJS version of the above, but want this to still work in nocrypto
			 * versions of the library */
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64CharSet;
			/* base64 has 33% overhead; round length up */
			var length = Math.round(numBytes * 4/3);
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	Utils.randomHexString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexEncode(uIntArr);
		} : function(numBytes) {
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexCharSet;
			var length = numBytes * 2;
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	Utils.promisify = function(ob, fnName, args) {
		return new Promise(function(resolve, reject) {
			ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
				err ? reject(err) : resolve(res);
			}));
		});
	};

	Utils.decodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));
	};

	Utils.encodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.encode(body, true) : JSON.stringify(body);
	};

	Utils.allToLowerCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toLowerCase();
		});
	};

	Utils.allToUpperCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toUpperCase();
		});
	};

	return Utils;
})();

/* harmony default export */ __webpack_exports__["a"] = (Utils);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_21941__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_21941__(1);


var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode, cause) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
		this.cause = cause;
		this.href = undefined;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		if(this.cause) result += '; cause=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(this.cause);
		if(this.href && !(this.message && this.message.indexOf('help.ably.io') > -1)) result += '; see ' + this.href + ' ';
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		if(result.code && !result.href) {
			result.href = 'https://help.ably.io/error/' + result.code;
		}
		return result;
	};

	return ErrorInfo;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorInfo);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_23403__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony import */ var _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_23403__(24);


if(typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

function allowComet() {
	/* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
	 * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
	 * So if websockets are supported, then just forget about comet transports and use that */
	var loc = global.location;
	return (!global.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1);
}

var userAgent = global.navigator && global.navigator.userAgent.toString();
var currentUrl = global.location && global.location.href;

var Platform = {
        agent: 'browser',
	logTimestamps: true,
	userAgent: userAgent,
	currentUrl: currentUrl,
	noUpgrade: userAgent && userAgent.match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: global.WebSocket || global.MozWebSocket,
	xhrSupported: global.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
	jsonpSupported: typeof(document) !== 'undefined',
	allowComet: allowComet(),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
	supportsBinary: !!global.TextDecoder,
	preferBinary: false,
	ArrayBuffer: global.ArrayBuffer,
	atob: global.atob,
	nextTick: typeof setImmediate !== 'undefined' ? global.setImmediate.bind(global) : function(f) { setTimeout(f, 0); },
	addEventListener: global.addEventListener,
	inspect: JSON.stringify,
	stringByteSize: function(str) {
		/* str.length will be an underestimate for non-ascii strings. But if we're
		 * in a browser too old to support TextDecoder, not much we can do. Better
		 * to underestimate, so if we do go over-size, the server will reject the
		 * message */
		return global.TextDecoder &&
			(new global.TextEncoder().encode(str)).length ||
			str.length;
	},
	TextEncoder: global.TextEncoder,
	TextDecoder: global.TextDecoder,
	Promise: global.Promise,
	getRandomValues: (function(crypto) {
		if (crypto === undefined) {
			return undefined;
		}
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			if(callback) {
				callback(null);
			}
		};
	})(global.crypto || global.msCrypto) // mscrypto for IE11
};

/* harmony default export */ __webpack_exports__["a"] = (Platform);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_23403__(17), __nested_webpack_require_23403__(42).setImmediate))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_26250__) {

"use strict";

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_26250__(3);

// CONCATENATED MODULE: ./browser/lib/util/defaults.js


var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket']
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(platform_browser["a" /* default */].noUpgrade) {
	Defaults.upgradeTransports = [];
}

/* harmony default export */ var defaults = (Defaults);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_26250__(1);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_26250__(5);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_26250__(0);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_26250__(2);

// CONCATENATED MODULE: ./common/lib/util/defaults.js







defaults.ENVIRONMENT              = '';
defaults.REST_HOST                = 'rest.ably.io';
defaults.REALTIME_HOST            = 'realtime.ably.io';
defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
defaults.PORT                     = 80;
defaults.TLS_PORT                 = 443;
defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	/* Undocumented, but part of the api and can be used by customers: */
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	fallbackRetryTimeout       : 600000,
	/* For internal / test use only: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 6000
};
defaults.httpMaxRetryCount = 3;
defaults.maxMessageSize    = 65536;

defaults.errorReportingUrl = 'https://errors.ably.io/api/15/store/';
defaults.errorReportingHeaders = {
	"X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
	"Content-Type": "application/json"
};

defaults.version          = '1.2.13';
defaults.apiVersion       = '1.2';

var agent = 'ably-js/' + defaults.version;
if (platform_browser["a" /* default */].agent) {
	agent += ' ' + platform_browser["a" /* default */].agent;
} 
defaults.agent = agent;

defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

// construct environment fallback hosts as per RSC15i
defaults.environmentFallbackHosts = function(environment) {
	return [
		environment + '-a-fallback.ably-realtime.com',
		environment + '-b-fallback.ably-realtime.com',
		environment + '-c-fallback.ably-realtime.com',
		environment + '-d-fallback.ably-realtime.com',
		environment + '-e-fallback.ably-realtime.com'
	];
};

defaults.getFallbackHosts = function(options) {
	var fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : defaults.httpMaxRetryCount;

	return fallbackHosts ? utils["a" /* default */].arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
};

defaults.getHosts = function(options) {
	return [options.restHost].concat(defaults.getFallbackHosts(options));
};

function checkHost(host) {
	if(typeof host !== 'string') {
		throw new errorinfo["a" /* default */]('host must be a string; was a ' + typeof host, 40000, 400);
	};
	if(!host.length) {
		throw new errorinfo["a" /* default */]('host must not be zero-length', 40000, 400);
	};
}

defaults.objectifyOptions = function(options) {
	if(typeof options == 'string') {
		return (options.indexOf(':') == -1) ? {token: options} : {key: options};
	}
	return options;
};

defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		logger["a" /* default */].deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		logger["a" /* default */].deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		logger["a" /* default */].deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.fallbackHostsUseDefault) {
		/* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
		if(options.fallbackHosts) {
			var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* default fallbacks can't be used with custom ports */
		if(options.port || options.tlsPort) {
			var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* emit an appropriate deprecation warning */
		if(options.environment) {
			logger["a" /* default */].deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
		} else {
			logger["a" /* default */].deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
		}

		/* use the default fallback hosts as requested */
		options.fallbackHosts = defaults.FALLBACK_HOSTS;
	}

	if(options.recover === true) {
		logger["a" /* default */].deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(!('closeOnUnload' in options)) {
		/* Have closeOnUnload default to true unless we have any indication that
		 * the user may want to recover the connection */
		options.closeOnUnload = !options.recover;
	}

	if(options.transports && utils["a" /* default */].arrIn(options.transports, 'xhr')) {
		logger["a" /* default */].deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		utils["a" /* default */].arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	/* infer hosts and fallbacks based on the configured environment */
	var environment = (options.environment && String(options.environment).toLowerCase()) || defaults.ENVIRONMENT;
	var production = !environment || (environment === 'production');

	if(!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
		options.fallbackHosts = production ? defaults.FALLBACK_HOSTS : defaults.environmentFallbackHosts(environment);
	}

	if(!options.realtimeHost) {
		/* prefer setting realtimeHost to restHost as a custom restHost typically indicates
		 * a development environment is being used that can't be inferred by the library */
		if(options.restHost) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_WARN, 'Defaults.normaliseOptions', 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
			options.realtimeHost = options.restHost
		} else {
			options.realtimeHost = production ? defaults.REALTIME_HOST : environment + '-' + defaults.REALTIME_HOST;
		}
	}

	if(!options.restHost) {
		options.restHost = production ? defaults.REST_HOST : environment + '-' + defaults.REST_HOST;
	}

	utils["a" /* default */].arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);

	options.port = options.port || defaults.PORT;
	options.tlsPort = options.tlsPort || defaults.TLS_PORT;
	options.maxMessageSize = options.maxMessageSize || defaults.maxMessageSize;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = platform_browser["a" /* default */].supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = platform_browser["a" /* default */].preferBinary;
	}

	if(options.clientId) {
		var headers = options.headers = options.headers || {};
		headers['X-Ably-ClientId'] = bufferutils["a" /* default */].base64Encode(bufferutils["a" /* default */].utf8Encode(options.clientId));
	}

	if(!('idempotentRestPublishing' in options)) {
		options.idempotentRestPublishing = true;
	}

	if(options.promises && !platform_browser["a" /* default */].Promise) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
		options.promises = false;
	}

        if(options.agents) {
          for(var key in options.agents) {
            defaults.agent += ' ' + key + '/' + options.agents[key];
          }
        }

	return options;
};

/* harmony default export */ var util_defaults = __webpack_exports__["a"] = (defaults);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_37334__) {

"use strict";
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_37334__(32);
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_37334__(33);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_37334__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_37334__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_37334__(3);






var BufferUtils = (function() {
	var ArrayBuffer = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].ArrayBuffer;
	var atob = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].atob;
	var TextEncoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextEncoder;
	var TextDecoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextDecoder;
	var base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var hexCharSet = '0123456789abcdef';

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }
	function isTypedArray(ob) { return ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob); }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function uint8ViewToBase64(bytes) {
		var base64    = ''
		var encodings = base64CharSet;

		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	/* Most BufferUtils methods that return a binary object return an ArrayBuffer
	 * if supported, else a CryptoJS WordArray. The exception is toBuffer, which
	 * returns a Uint8Array (and won't work on browsers too old to support it) */
	function BufferUtils() {}

	BufferUtils.base64CharSet = base64CharSet;
	BufferUtils.hexCharSet = hexCharSet;

	var isBuffer = BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf) || isTypedArray(buf); };

	/* In browsers, returns a Uint8Array */
	var toBuffer = BufferUtils.toBuffer = function(buf) {
		if(!ArrayBuffer) {
			throw new Error("Can't convert to Buffer: browser does not support the necessary types");
		}

		if(isArrayBuffer(buf)) {
			return new Uint8Array(buf);
		}

		if(isTypedArray(buf)) {
			return new Uint8Array(buf.buffer);
		}

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return uint8View;
		};

		throw new Error("BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray");
	};

	BufferUtils.toArrayBuffer = function(buf) {
		if(isArrayBuffer(buf)) {
			return buf;
		}
		return toBuffer(buf).buffer;
	};

	BufferUtils.toWordArray = function(buf) {
		if(isTypedArray(buf)) {
			buf = buf.buffer;
		}
		return isWordArray(buf) ? buf : crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default.a.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isWordArray(buf)) {
			return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["stringify"])(buf);
		}
		return uint8ViewToBase64(toBuffer(buf));
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob) {
			return base64ToArrayBuffer(str);
		}
		return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["parse"])(str);
	};

	BufferUtils.hexEncode = function(buf) {
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["stringify"])(buf);
	};

	BufferUtils.hexDecode = function(string) {
		var wordArray = Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["parse"])(string);
		return ArrayBuffer ? BufferUtils.toArrayBuffer(wordArray) : wordArray;
	};

	BufferUtils.utf8Encode = function(string) {
		if(TextEncoder) {
			return (new TextEncoder()).encode(string).buffer;
		}
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["parse"])(string);
	};

	/* For utf8 decoding we apply slightly stricter input validation than to
	 * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
	 * can take (in particular allowing strings, which are just interpreted as
	 * binary); here we ensure that the input is actually a buffer since trying
	 * to utf8-decode a string to another string is almost certainly a mistake */
	BufferUtils.utf8Decode = function(buf) {
		if(!isBuffer(buf)) {
			throw new Error("Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray");
		}
		if(TextDecoder && !isWordArray(buf)) {
			return (new TextDecoder()).decode(buf);
		}
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["stringify"])(buf);
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	BufferUtils.byteLength = function(buf) {
		if(isArrayBuffer(buf) || isTypedArray(buf)) {
			return buf.byteLength
		} else if(isWordArray(buf)) {
			return buf.sigBytes;
		}
	};

	/* Returns ArrayBuffer on browser and Buffer on Node.js */
	BufferUtils.typedArrayToBuffer = function(typedArray) {
		return typedArray.buffer;
	};

	return BufferUtils;
})();

/* harmony default export */ __webpack_exports__["a"] = (BufferUtils);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_45867__) {

"use strict";
/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_45867__(1);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_45867__(4);



var Http = (function() {
	var noop = function() {};

	function Http() {}

	var now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	function getHosts(client) {
		/* If we're a connected realtime client, try the endpoint we're connected
		 * to first -- but still have fallbacks, being connected is not an absolute
		 * guarantee that a datacenter has free capacity to service REST requests. */
		var connection = client.connection,
			connectionHost = connection && connection.connectionManager.host;

		if(connectionHost) {
			return [connectionHost].concat(_common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getFallbackHosts(client.options));
		}

		return _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getHosts(client.options);
	}
	Http._getHosts = getHosts;

	Http.methods = ['get', 'delete', 'post', 'put', 'patch'];
	Http.methodsWithoutBody = ['get', 'delete'];
	Http.methodsWithBody = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrSubtract(Http.methods, Http.methodsWithoutBody);

	/* - Http.get, Http.post, Http.put, ...
	 * Perform an HTTP request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 *
	 * - Http.getUri, Http.postUri, Http.putUri, ...
	 * Perform an HTTP request for a given full URI
	 * @param rest
	 * @param uri the full URI
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithoutBody, function(method) {
		Http[method] = function(rest, path, headers, params, callback) {
			Http['do'](method, rest, path, headers, null, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, params, callback) {
			Http.doUri(method, rest, uri, headers, null, params, callback);
		};
	});

	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithBody, function(method) {
		Http[method] = function(rest, path, headers, body, params, callback) {
			Http['do'](method, rest, path, headers, body, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, body, params, callback) {
			Http.doUri(method, rest, uri, headers, body, params, callback);
		};
	});

	/* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
	Http['do'] = function(method, rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uriFromHost = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');
		var doArgs = arguments;

		var currentFallback = rest._currentFallback;
		if(currentFallback) {
			if(currentFallback.validUntil > now()) {
				/* Use stored fallback */
				Http.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function(err) {
					if(err && shouldFallback(err)) {
						/* unstore the fallback and start from the top with the default sequence */
						rest._currentFallback = null;
						Http['do'].apply(Http, doArgs);
						return;
					}
					callback.apply(null, arguments);
				});
				return;
			} else {
				/* Fallback expired; remove it and fallthrough to normal sequence */
				rest._currentFallback = null;
			}
		}

		var hosts = getHosts(rest);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts, persistOnSuccess) {
			var host = candidateHosts.shift();
			Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts, true);
					return;
				}
				if(persistOnSuccess) {
					/* RSC15f */
					rest._currentFallback = {
						host: host,
						validUntil: now() + rest.options.timeouts.fallbackRetryTimeout
					};
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	Http.doUri = function(method, rest, uri, headers, body, params, callback) {
		Http.Request(method, rest, uri, headers, params, body, callback);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/* harmony default export */ __webpack_exports__["a"] = (Http);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_51456__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_51456__(1);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_51456__(0);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_51456__(3);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = Object.create(null);
		this.anyOnce = [];
		this.eventsOnce = Object.create(null);
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners)) {
				while ((idx = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (hasOwnProperty.call(listeners, eventName) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.any.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(listener))) {
			this.any = [];
			this.events = Object.create(null);
			this.anyOnce = [];
			this.eventsOnce = Object.create(null);
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		var argCount = arguments.length, self = this;
		if((argCount === 0 || (argCount === 1 && typeof event !== 'function')) && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				self.once(event, resolve);
			});
		}
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)){
			var listenerWrapper = function() {
				var args = Array.prototype.slice.call(arguments);
				_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
					self.off(ev, listenerWrapper);
				});
				listener.apply(this, args);
			};
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listenerWrapper);
			});
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
			self = this,
			listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string')) {
			throw("whenState requires a valid event String argument");
		}
		if(typeof listener !== 'function' && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				EventEmitter.prototype.whenState.apply(self, [targetState, currentState, resolve].concat(listenerArgs));
			});
		}
		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_60569__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60569__(1);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60569__(2);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_60569__(9);
/* harmony import */ var _presencemessage__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_60569__(11);





var ProtocolMessage = (function() {

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
		this.params = undefined;
	}

	var actions = ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.channelModes = [ 'PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE' ];

	ProtocolMessage.ActionName = [];
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[actions[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'TRANSIENT':          1 << 4,
		'ATTACH_RESUME':      1 << 5,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(modes, function(mode) {
			self.setFlag(mode);
		});
	};

	ProtocolMessage.prototype.decodeModesFromFlags = function() {
		var modes = [],
			self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(ProtocolMessage.channelModes, function(mode) {
			if(self.hasFlag(mode)) {
				modes.push(mode);
			}
		});
		return modes.length > 0 ? modes : undefined;
	};

	ProtocolMessage.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].encodeBody;

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].decodeBody(serialized, format);
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = _message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = _presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(presence[i], true);
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(_message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(_presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');
		if(msg.params) {
			var stringifiedParams = '';
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].forInOwnNonNullProps(msg.params, function(prop) {
				if (stringifiedParams.length > 0) {
					stringifiedParams += '; ';
				}
				stringifiedParams += prop + '=' + msg.params[prop];
			});
			if (stringifiedParams.length > 0) {
				result += '; params=[' + stringifiedParams + ']';
			}
		}
		result += ']';
		return result;
	};

	/* Only valid for channel messages */
	ProtocolMessage.isDuplicate = function(a, b) {
		if (a && b) {
			if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) &&
				(a.action === b.action) &&
				(a.channel === b.channel) &&
				(a.id === b.id)) {
				if (a.action === actions.PRESENCE) {
					return true;
				} else if (a.messages.length === b.messages.length) {
					for (var i = 0; i < a.messages.length; i++) {
						var aMessage = a.messages[i];
						var bMessage = b.messages[i];
						if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !==
							(bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
							return false;
						}
					}

					return true;
				}
			}
		}

		return false;
	};

	return ProtocolMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (ProtocolMessage);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_67773__) {

"use strict";
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_67773__(5);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_67773__(1);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_67773__(0);
/* harmony import */ var platform_crypto__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_67773__(19);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_67773__(2);






var Message = (function() {

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
		this.size = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			id: this.id,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		if(this.extras)
			result += '; extras=' + JSON.stringify(this.extras);
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isObject(data) || _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].encodeBody;

	Message.decode = function(message, context) {
		/* The second argument could be either EncodingDecodingContext that contains ChannelOptions or ChannelOptions */
		if(!context || !context.channelOptions) {
			var channelOptions = context;
			context = {
				channelOptions: channelOptions,
				plugins: { },
				baseEncodedPreviousPayload: undefined
			};
		}

		var lastPayload = message.data;
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				lastProcessedEncodingIndex, encodingsToProcess = xforms.length,
				data = message.data;

			try {
				while((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
					var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Decode(String(data));
							if(lastProcessedEncodingIndex == xforms.length) {
								lastPayload = data;
							}
							continue;
						case 'utf-8':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(context.channelOptions != null && context.channelOptions.cipher) {
								var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						case 'vcdiff':
							if(!context.plugins || !context.plugins.vcdiff) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
							}
							if(typeof Uint8Array === 'undefined') {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
							}
							try {
								var deltaBase = context.baseEncodedPreviousPayload;
								if(typeof deltaBase === 'string') {
									deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(deltaBase);
								}

								/* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
								 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
								 * to process it into a buffer anyway) */
								deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(deltaBase);
								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);

								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
								lastPayload = data;
							} catch(e) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Vcdiff delta decode failed with ' + e, 40018, 400);
							}
							continue;
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Error processing the ' + xform + ' encoding, decoder returned ‘' + e.message + '’', e.code || 40013, 400);
			} finally {
				message.encoding = (lastProcessedEncodingIndex <= 0) ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
				message.data = data;
			}
		}
		context.baseEncodedPreviousPayload = lastPayload;
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	function normalizeCipherOptions(options) {
		if(options && options.cipher && !options.cipher.channelCipher) {
			if(!platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		}
	}

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		normalizeCipherOptions(options);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		normalizeCipherOptions(options);
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	function getMessageSize(msg) {
		var size = 0;
		if(msg.name) {
			size += msg.name.length;
		}
		if(msg.clientId) {
			size += msg.clientId.length;
		}
		if(msg.extras) {
			size += JSON.stringify(msg.extras).length;
		}
		if(msg.data) {
			size += _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].dataSizeBytes(msg.data);
		}
		return size;
	};

	/* This should be called on encode()d (and encrypt()d) Messages (as it
	 * assumes the data is a string or buffer) */
	Message.getMessagesSize = function(messages) {
		var msg, total = 0;
		for(var i=0; i<messages.length; i++) {
			msg = messages[i];
			total += (msg.size || (msg.size = getMessageSize(msg)))
		}
		return total;
	};

	return Message;
})();

/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_79596__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_79596__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_81748__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_81748__(3);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_81748__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_81748__(5);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_81748__(9);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_81748__(1);






var PresenceMessage = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function toActionValue(actionString) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.size = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].encode;
	PresenceMessage.decode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	PresenceMessage.getMessagesSize = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getMessagesSize;

	return PresenceMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (PresenceMessage);


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_87981__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87981__(45);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87981__(17)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_111360__) {

"use strict";
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_111360__(2);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_111360__(1);



var ConnectionError = {
	disconnected: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

ConnectionError.isRetriable = function(err) {
	if (!err.statusCode || !err.code || err.statusCode >= 500) {
		return true;
	}
	var retriable = false;
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].valuesArray(ConnectionError).forEach(function(connErr) {
		if (connErr.code && connErr.code == err.code) {
			retriable = true;
		}
	});
	return retriable;
};

/* harmony default export */ __webpack_exports__["a"] = (ConnectionError);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_113345__) {

"use strict";

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_113345__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_113345__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_113345__(1);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_113345__(6);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var multicaster = __nested_webpack_require_113345__(22);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_113345__(5);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_113345__(2);

// CONCATENATED MODULE: ./browser/lib/util/base64.js
/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

/* harmony default export */ var base64 = (Base64);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/hmac-sha256.js
var hmac_sha256 = __nested_webpack_require_113345__(38);
var hmac_sha256_default = /*#__PURE__*/__nested_webpack_require_113345__.n(hmac_sha256);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/enc-base64.js
var enc_base64 = __nested_webpack_require_113345__(18);

// CONCATENATED MODULE: ./common/lib/client/auth.js











var auth_Auth = (function() {
	var MAX_TOKEN_LENGTH = Math.pow(2, 17);
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }
	function normaliseAuthcallbackError(err) {
		/* A client auth callback may give errors in any number of formats; normalise to an errorinfo */
		if(!utils["a" /* default */].isErrorInfo(err)) {
			return new errorinfo["a" /* default */](utils["a" /* default */].inspectError(err), err.code || 40170, err.statusCode || 401);
		}
		/* network errors will not have an inherent error code */
		if(!err.code) {
			if(err.statusCode === 403) {
				err.code = 40300;
			} else {
				err.code = 40170;
				/* normalise statusCode to 401 per RSA4e */
				err.statusCode = 401;
			}
		}
		return err;
	}

	var hmac, toBase64;
	if(platform_browser["a" /* default */].createHmac) {
		toBase64 = function(str) { return (Buffer.from(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = platform_browser["a" /* default */].createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = base64.encode;
		hmac = function(text, key) {
			return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = Object.create(null);
		var keys = utils["a" /* default */].keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	/* RSA4a */
	function noWayToRenew(options) {
		return !options.key &&
			!options.authCallback &&
			!options.authUrl;
	}

	var trId = 0;
	function getTokenRequestId() {
		return trId++;
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};
		/* The id of the current token request if one is in progress, else null */
		this.currentTokenRequestId = null;
		this.waitingForTokenRequest = null;

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			if(noWayToRenew(options)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(!options.key) {
				var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new errorinfo["a" /* default */](msg, 40160, 401);
			}
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback) {
			if(this.client.options.promises) {
				return utils["a" /* default */].promisify(this, 'authorize', arguments);
			}
			callback = noop;
		}
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.authOptions.key !== authOptions.key)) {
			throw new errorinfo["a" /* default */]('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(utils["a" /* default */].isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				if(self.client.connection) {
					/* We interpret RSA4d as including requests made by a client lib to
					 * authenticate triggered by an explicit authorize() or an AUTH received from
					 * ably, not just connect-sequence-triggered token fetches */
					self.client.connection.connectionManager.actOnErrorFromAuthorize(err);
				}
				callback(err);
				return;
			}

			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		logger["a" /* default */].deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'requestToken', arguments);
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);
		callback = callback || noop;

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			tokenRequestCallback = function(params, cb) {
				var authHeaders = utils["a" /* default */].mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
					usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
				if(!usePost) {
					/* Combine authParams with any qs params given in the authUrl */
					var queryIdx = authOptions.authUrl.indexOf('?');
					if(queryIdx > -1) {
						var providedQsParams = utils["a" /* default */].parseQueryString(authOptions.authUrl.slice(queryIdx));
						authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
						/* In case of conflict, authParams take precedence over qs params in the authUrl */
						authOptions.authParams = utils["a" /* default */].mixin(providedQsParams, authOptions.authParams);
					}
				}
				/* RSA8c2 */
				var authParams = utils["a" /* default */].mixin({}, authOptions.authParams || {}, params);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					var contentType;
					if (err) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + utils["a" /* default */].inspectError(err));
					} else {
						contentType = headers['content-type'];
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + utils["a" /* default */].inspectBody(body));
					}
					if(err || unpacked) return cb(err, body);
					if(bufferutils["a" /* default */].isBuffer(body)) body = body.toString();
					if(!contentType) {
						cb(new errorinfo["a" /* default */]('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
					if(!json && !text) {
						cb(new errorinfo["a" /* default */]('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain, application/jwt or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKEN_LENGTH) {
							cb(new errorinfo["a" /* default */]('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new errorinfo["a" /* default */]('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body, contentType);
				};
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams) + '; method: ' + (usePost ? 'POST' : 'GET'));
				if(usePost) {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = utils["a" /* default */].toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					http["a" /* default */].postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					http["a" /* default */].getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			callback(new errorinfo["a" /* default */](msg, 40171, 403));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				path = '/keys/' + keyName + '/requestToken',
				tokenUri = function(host) { return client.baseUri(host) + path; };

			var requestHeaders = utils["a" /* default */].defaultPostHeaders();
			if(authOptions.requestHeaders) utils["a" /* default */].mixin(requestHeaders, authOptions.requestHeaders);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = JSON.stringify(signedTokenParams);
			http["a" /* default */].post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + utils["a" /* default */].inspectError(err));
				callback(normaliseAuthcallbackError(err));
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length === 0) {
					callback(new errorinfo["a" /* default */]('Token string is empty', 40170, 401));
				} else if(tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
					callback(new errorinfo["a" /* default */]('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else if(tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
					/* common failure mode with poorly-implemented authCallbacks */
					callback(new errorinfo["a" /* default */]('Token string was literal null/undefined', 40170, 401));
				} else if((tokenRequestOrDetails[0] === '{') && !(contentType && contentType.indexOf('application/jwt') > -1)) {
					callback(new errorinfo["a" /* default */]('Token was double-encoded; make sure you\'re not JSON-encoding an already encoded token request or details', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
				callback(new errorinfo["a" /* default */]('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + utils["a" /* default */].inspectError(err));
					callback(normaliseAuthcallbackError(err));
					return;
				}
				if(!unpacked) tokenResponse = JSON.parse(tokenResponse);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'createTokenRequest', arguments);
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new errorinfo["a" /* default */]('No key specified', 40101, 403));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new errorinfo["a" /* default */]('Invalid key specified', 40101, 403));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new errorinfo["a" /* default */]('clientId can’t be an empty string', 40012, 400));
			return;
		}

		if('capability' in tokenParams) {
			tokenParams.capability = c14n(tokenParams.capability);
		}

		var request = utils["a" /* default */].mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability || '',
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
			this.client.time(callback);
		} else {
			callback(null, this.getTimestampUsingOffset());
		}
	};

	Auth.prototype.getTimestampUsingOffset = function() {
		return utils["a" /* default */].now() + (this.client.serverTimeOffset || 0);
	};

	Auth.prototype.isTimeOffsetSet = function() {
		return this.client.serverTimeOffset !== null;
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	/* @param forceSupersede: force a new token request even if there's one in
	 * progress, making all pending callbacks wait for the new one */
	Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
		var self = this,
			token = this.tokenDetails;

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				/* 403 to trigger a permanently failed client - RSA15c */
				callback(new errorinfo["a" /* default */]('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
				return;
			}
			/* RSA4b1 -- if we have a server time offset set already, we can
			 * autoremove expired tokens. Else just use the cached token. If it is
			 * expired Ably will tell us and we'll discard it then. */
			if(!this.isTimeOffsetSet() || !token.expires || (token.expires >= this.getTimestampUsingOffset())) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
				callback(null, token);
				return;
			}
			/* expired, so remove and fallthrough to getting a new one */
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
			this.tokenDetails = null;
		}

		(this.waitingForTokenRequest || (this.waitingForTokenRequest = Object(multicaster["a" /* default */])())).push(callback);
		if(this.currentTokenRequestId !== null && !forceSupersede) {
			return;
		}

		/* Request a new token */
		var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
		this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
			if(self.currentTokenRequestId > tokenRequestId) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
				return;
			}
			self.currentTokenRequestId = null;
			var callbacks = self.waitingForTokenRequest || noop;
			self.waitingForTokenRequest = null;
			if(err) {
				callbacks(err);
				return;
			}
			callbacks(null, (self.tokenDetails = tokenResponse));
		});
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new errorinfo["a" /* default */]('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new errorinfo["a" /* default */](msg, 40102, 401);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			(this.clientId !== '*') &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

/* harmony default export */ var auth = __webpack_exports__["a"] = (auth_Auth);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_154733__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_154733__(1);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_154733__(8);
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_154733__(20);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_154733__(0);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_154733__(4);
/* harmony import */ var _connectionerror__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_154733__(13);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_154733__(14);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_154733__(2);









var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(_client_auth__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].isTokenErr(err)) return false;
			if(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.ERROR, error: err})];
		} else {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(CometTransport, _transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'starting');
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getHost(options, params.host);
		var port = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			if(self.isDisposed) {
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]('Request cancelled', 80003, 400);
				}
				self.recvRequest = null;
				/* Connect request may complete without a emitting 'data' event since that is not
				 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
				if(!preconnected && !err) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onActivity();
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.isDisposed) {
			this.isDisposed = true;
			if(this.recvRequest) {
				_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', _connectionerror__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].disconnected);
			var self = this;
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.isDisposed) {
			return;
		}

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) _util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
			self.sendRequest = null;

			/* the result of the request, even if a nack, is usually a protocol response
			 * contained in the data. An err is anomolous, and indicates some issue with the
			 * network,transport, or connection */
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}

			if(data) {
				self.onData(data);
			}

			if(self.pendingItems) {
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			/* A request completing must be considered activity, as realtime sends
			 * heartbeats every 15s since a request began, not every 15s absolutely */
			self.onActivity();
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromDeserialized(items[i]));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

/* harmony default export */ __webpack_exports__["a"] = (CometTransport);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_169550__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_169550__(1);


var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no global object,
	 * will throw on accessing a property of undefined) */
	try {
		global.sessionStorage.setItem(test, test);
		global.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		global.localStorage.setItem(test, test);
		global.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? global.sessionStorage : global.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

/* harmony default export */ __webpack_exports__["a"] = (WebStorage);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_169550__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_172673__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_172673__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_176709__) {

"use strict";
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_176709__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_176709__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_176709__(28);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_176709__(3);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_176709__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_176709__(5);







var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray) {
		generateRandom = platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray;
	} else if(typeof Uint32Array !== 'undefined' && platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues(nativeArray, function(err) {
				callback(err, platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505,0x05000000], 5),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606,0x06060000], 6),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707,0x07070700], 7),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808,0x08080808], 8),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909,0x09090909,0x09000000], 9),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
		} else {
			key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key);
		if(iv) {
			this.iv = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(plaintext);
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(ciphertext);
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

/* harmony default export */ __webpack_exports__["a"] = (Crypto);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_191402__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_191402__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_191402__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_191402__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_191402__(0);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_191402__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_191402__(2);







var Transport = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var closeMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.CLOSE});
	var disconnectMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionSerial, connectionId, connectionDetails
	 * sync             connectionSerial, connectionId
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.isDisposed = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Transport, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(message) + '; connectionId = ' + this.connectionManager.connectionId);
		}
		this.onActivity();

		switch(message.action) {
		case actions.HEARTBEAT:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionId, message);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' + this.connectionManager.connectionId + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.onActivity();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onFatalError()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onClose()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.dispose()', '');
		this.isDisposed = true;
		this.off();
	};

	Transport.prototype.onActivity = function() {
		if(!this.maxIdleInterval) { return; }
		this.lastActivity = this.connectionManager.lastActivity = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
		this.setIdleTimer(this.maxIdleInterval + 100);
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"](msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 100);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

/* harmony default export */ __webpack_exports__["a"] = (Transport);


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionStateChange);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_202483__) {

"use strict";
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_202483__(0);


var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

/* harmony default export */ __webpack_exports__["a"] = (Multicaster);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_203423__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_203423__(1);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_203423__(3);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_203423__(4);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_203423__(0);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_203423__(6);






var ErrorReporter = (function() {
	function ErrorReporter() {}

	var levels = ErrorReporter.levels = [
		'fatal',
		'error',
		'warning',
		'info',
		'debug'
	];

	/* (level: typeof ErrorReporter.levels[number], message: string, fingerprint?: string, tags?: {[key: string]: string}): void */
	ErrorReporter.report = function(level, message, fingerprint, tags) {
		var eventId = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].randomHexString(16);

		var event = {
			event_id: eventId,
			tags: _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin({
				ablyAgent: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].agent
			}, tags),
			platform: 'javascript',
			level: level,
			release: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].version,
			fingerprint: fingerprint && [ fingerprint ],
			message: message,
			request: {
				headers: {
					'User-Agent': platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].userAgent
				},
				url: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].currentUrl
			}
		};

		_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter: ' + message);
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].postUri(null, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingUrl, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
			_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter resulted in: ' +
				(err ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err) : _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectBody(res))
			);
		});
	};

	return ErrorReporter;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorReporter);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		var keys = []; // TODO: use Object.keys when we are able to transpile to ES3
		for (var key in value) {
			if (!value.hasOwnProperty(key)) continue;
			keys.push(key);
		}
		return keys.filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

/* harmony default export */ __webpack_exports__["a"] = (msgpack);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_225303__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_225303__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_225303__(1);
/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_225303__(34);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_225303__(4);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_225303__(3);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_225303__(7);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_225303__(26);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_225303__(0);
/* harmony import */ var _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_225303__(21);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_225303__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_225303__(2);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_225303__(14);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_225303__(6);
/* harmony import */ var _types_message__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_225303__(9);
/* harmony import */ var _util_multicaster__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_225303__(22);
/* harmony import */ var _util_errorreporter__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_225303__(23);
/* harmony import */ var platform_webstorage__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_225303__(16);
/* harmony import */ var platform_transports__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_225303__(41);
/* harmony import */ var _websockettransport__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_225303__(40);




















var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get);
	var haveSessionStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession);
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var PendingMessage = _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, a.shortName) >
		   _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';

		this.connectionSerial = undefined;
		this.timeSerial = undefined;
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.timeSerial !== undefined) {
					params.timeSerial = this.timeSerial;
				} else if(this.connectionSerial !== undefined) {
					params.connectionSerial = this.connectionSerial;
				}
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					var recoverSerial = match[1];
					if(isNaN(recoverSerial)) {
						params.timeSerial = recoverSerial;
					} else {
						params.connectionSerial = recoverSerial;
					}
				}
				break;
			default:
		}
		if(options.clientId !== undefined) {
			params.clientId = options.clientId;
		}
		if(options.echoMessages === false) {
			params.echo = 'false';
		}
		if(this.format !== undefined) {
			params.format = this.format;
		}
		if(this.stream !== undefined) {
			params.stream = this.stream;
		}
		if(this.heartbeats !== undefined) {
			params.heartbeats = this.heartbeats;
		}
		params.v = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].apiVersion;
		params.agent = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].agent;
		if(options.transportParams !== undefined) {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(params, options.transportParams);
		}
		return params;
	};

	TransportParams.prototype.toString = function() {
		var result = '[mode=' + this.mode;
		if(this.host) { result += (',host=' + this.host); }
		if(this.connectionKey) { result += (',connectionKey=' + this.connectionKey); }
		if(this.connectionSerial !== undefined) { result += (',connectionSerial=' + this.connectionSerial); }
		if(this.timeSerial) { result += (',timeSerial=' + this.timeSerial); }
		if(this.format) { result += (',format=' + this.format); }
		result += ']';

		return result;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new _messagequeue__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]();
		this.msgSerial = 0;
		this.connectionDetails = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.timeSerial = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect((options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseTransportOrder, this.transports)[0];
		this.upgradeTransports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(this.transports, _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports);
		this.transportPreference = null;

		this.httpHosts = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;
		this.mostRecentMsg = null;
		this.forceFallbackHost = false;
		this.connectCounter = 0;

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports) + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
					self.requestState({state: 'closing'});
				});
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser ‘online’ event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser ‘offline’ event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(ConnectionManager, _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	Object(_websockettransport__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(ConnectionManager);
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(platform_transports__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], function (initFn) {
		initFn(ConnectionManager);
	});

	ConnectionManager.prototype.createTransportParams = function(host, mode) {
		var params = new TransportParams(this.options, host, mode, this.connectionKey);
		if(this.timeSerial) {
			params.timeSerial = this.timeSerial;
		} else if(this.connectionSerial !== undefined) {
			params.connectionSerial = this.connectionSerial;
		}
		return params;
	};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			var transportParams = self.createTransportParams(null, mode);
			if(mode === 'recover') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + self.options.recover);
				var match = self.options.recover.split(':');
				if(match && match[2]) {
					self.msgSerial = match[2];
				}
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
			}
			callback(transportParams);
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(_client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(wrappedErr.error) && !(self.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(self.errorReason))) {
					self.errorReason = wrappedErr.error;
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					if(!_transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].isRetriable(wrappedErr.error)) {
						/* Error received from the server that does not call for trying a fallback host, eg a rate limit */
						self.notifyState({state: self.states.connecting.failState, error: wrappedErr.error});
						callback(true);
					} else {
						/* Error with that transport only; continue trying other fallback hosts */
						callback(false);
					}
				}
				return;
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionId, connectionDetails, connectionPosition) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
				}
			} else {
				self.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param error
	 * @param transport
	 * @param connectionId
	 * @param connectionDetails
	 * @param connectedMessage
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connection position. (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				syncPosition = connectionReset ? upgradeConnectionPosition : self;

			if(connectionReset) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connection position from ' + (self.timeSerial || self.connectionSerial) + ' to ' + (syncPosition.timeSerial || syncPosition.connectionSerial) + '; upgrade error was ' + error);
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, syncPosition, function(syncErr, connectionId, postSyncPosition) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionId, connectionDetails, postSyncPosition);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionId the id of the new active connection
	 * @param connectionDetails the details of the new active connection
	 * @param connectionPosition the position at the point activation; either {connectionSerial: <serial>} or {timeSerial: <serial>}
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionId) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		}
		if(connectionDetails) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
		}
		if(connectionPosition) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'serial =  ' + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
		}

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](transport);
		this.host = transport.params.host;

		var connectionKey = connectionDetails.connectionKey;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			if(existingActiveProtocol.transport === transport) {
				var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-previously-active');
			} else {
				existingActiveProtocol.finish();
			}
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(pendingTransport) {
			if(pendingTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-pending');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			} else {
				pendingTransport.disconnect();
			}
		});
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(proposedTransport) {
			if(proposedTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-proposed');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.proposedTransports, transport);
			} else {
				proposedTransport.dispose();
			}
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport),
			wasProposed = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
			clearTimeout(this.channelResumeCheckTimer);
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {

			/* If we're disconnected with a 5xx we need to try fallback hosts
			 * (RTN14d), but (a) due to how the upgrade sequence works, the
			 * host/transport selection sequence only cares about getting to
			 * `preconnect` (eg establishing a websocket) getting a `disconnected`
			 * protocol message afterwards is too late; and (b) host retry only
			 * applies to connectBase unless the stored preference transport doesn't
			 * work. We solve this by unpersisting the transport preference and
			 * setting an instance variable to force fallback hosts to be used (if
			 * any) here. Bit of a kludge, but no real better alternatives without
			 * rewriting the entire thing */
			if(state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
				this.unpersistTransportPreference();
				this.forceFallbackHost = true;
				/* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
				this.notifyState({state: state, error: error, retryImmediately: true});
				return;
			}

			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			var newConnectionState = (state === 'failed' && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(error)) ? 'disconnected' : state;
			this.notifyState({state: newConnectionState, error: error});
			return;
		}

		if(wasActive && (state === 'disconnected') && (this.state !== this.states.synchronizing)) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens). (If we were in the
			* synchronizing state, then that's fine, the old transport just got its
			* disconnected before the new one got the sync -- ignore it and keep
			* waiting for the sync. If it fails we have a separate sync timer that
			* will expire). */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey
		});

		if(requestedSyncPosition.timeSerial) {
			syncMessage.timeSerial = requestedSyncPosition.timeSerial;
		} else if(requestedSyncPosition.connectionSerial !== undefined) {
			syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
		}
		transport.send(syncMessage);

		transport.once('sync', function(connectionId, syncPosition) {
			clearTimeout(timeout);
			callback(null, connectionId, syncPosition);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state,
		 * and resetting the connectionSerial position */
		var self = this;
		/* If no previous connectionId, don't reset the msgSerial as it may have
		 * been set by recover data (unless the recover failed) */
		var prevConnId = this.connectionid,
			connIdChanged = prevConnId && (prevConnId !== connectionId),
			recoverFailure = !prevConnId && hasConnectionError;
		if(connIdChanged || recoverFailure)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
			this.msgSerial = 0;
		}
		/* but do need to reattach channels, for channels that were previously in
		 * the attached state even though the connection mode was 'clean' due to a
		 * freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else if(this.options.checkChannelsOnResume) {
			/* For attached channels, set the attached msg indicator variable to false,
			 * wait 30s, and check we got an attached for each one.
			 * 30s was chosen to be 5s longer than the transport idle timeout expire
			 * time, in an attempt to avoid false positives due to a transport
			 * silently failing immediately after a resume */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Same connectionId; checkChannelsOnResume is enabled');
			clearTimeout(this.channelResumeCheckTimer);
			this.realtime.channels.resetAttachedMsgIndicators();
			this.channelResumeCheckTimer = setTimeout(function() {
				self.realtime.channels.checkAttachedMsgIndicators(connectionId);
			}, 30000);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
		var forceResetMessageSerial = connIdChanged || !prevConnId;
		this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.clearConnectionSerial();
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	/* force: set the connectionSerial even if it's less than the current
	 * connectionSerial. Used for new connections.
	 * Returns true iff the message was rejected as a duplicate. */
	ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
		var timeSerial = connectionPosition.timeSerial,
			connectionSerial = connectionPosition.connectionSerial;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.setConnectionSerial()', 'Updating connection serial; serial = ' + connectionSerial + '; timeSerial = ' + timeSerial + '; force = ' + force + '; previous = ' + this.connectionSerial);
		if(timeSerial !== undefined) {
			if(timeSerial <= this.timeSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with timeSerial ' + timeSerial + ', but current timeSerial is ' + this.timeSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
			this.setRecoveryKey();
			return;
		}
		if(connectionSerial !== undefined) {
			if(connectionSerial <= this.connectionSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.serial = this.connectionSerial = connectionSerial;
			this.setRecoveryKey();
		}
	};

	ConnectionManager.prototype.clearConnectionSerial = function() {
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.timeSerial = this.timeSerial = undefined;
		this.clearRecoveryKey();
	};

	ConnectionManager.prototype.setRecoveryKey = function() {
		this.realtime.connection.recoveryKey = this.connectionKey + ':' + (this.timeSerial || this.connectionSerial) + ':' + this.msgSerial;
	};

	ConnectionManager.prototype.clearRecoveryKey = function() {
		this.realtime.connection.recoveryKey = null;
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage) {
			var recoveryKey = this.realtime.connection.recoveryKey;
			if(recoveryKey) {
				setSessionRecoverData({
					recoveryKey: recoveryKey,
					disconnectedAt: _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
					location: global.location,
					clientId: this.realtime.auth.clientId
				}, this.connectionStateTtl);
			}
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getError = function() {
		return this.errorReason || this.getStateError();
	};

	ConnectionManager.prototype.getStateError = function() {
		return _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR : _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason) : ''));
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced
		 *   authorize). If this.errorReason is already set (to a token error),
		 *   then there has been at least one previous attempt to connect that also
		 *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
		 *   before trying again */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
			 indicated.retryImmediately               ||
				(this.state === this.states.connecting &&
					indicated.error && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(indicated.error) &&
					!(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)))));

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, newState.retryDelay, (indicated.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, null, (request.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		/* The point of the connectCounter mechanism is to ensure that the
		 * connection procedure can be cancelled. We want disconnectAllTransports
		 * to be able to stop any in-progress connection, even before it gets to
		 * the stage of having a pending (or even a proposed) transport that it can
		 * dispose() of. So we check that it's still current after any async stage,
		 * up until the stage that is synchronous with instantiating a transport */
		var connectCount = ++this.connectCounter;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				self.connectImpl(transportParams, connectCount);
			});
		};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(false, authCb);
			}
		}
	};

	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams, connectCount);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (no available host)', 80003, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (and no more fallback hosts to try)', 80003, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			platform_http__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].checkConnectivity(function(err, connectivity) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (network unreachable)', 80003, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		if(this.forceFallbackHost && candidateHosts.length) {
			this.forceFallbackHost = false;
			tryFallbackHosts();
			return;
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = self.createTransportParams(transportParams.host, 'upgrade');
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		/* This will prevent any connection procedure in an async part of one of its early stages from continuing */
		this.connectCounter++;

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](err, 90000, 400));
			return;
		}
		if(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
			this.setRecoveryKey();
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	function bundleWith(dest, src, maxSize) {
		var action;
		if(dest.channel !== src.channel) {
			/* RTL6d3 */
			return false;
		}
		if((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
			/* RTL6d - can only bundle messages or presence */
			return false;
		}
		if(action !== src.action) {
			/* RTL6d4 */
			return false;
		}
		var kind = (action === actions.PRESENCE) ? 'presence' : 'messages',
			proposed = dest[kind].concat(src[kind]),
			size = _types_message__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].getMessagesSize(proposed);
		if(size > maxSize) {
			/* RTL6d1 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].allSame(proposed, 'clientId')) {
			/* RTL6d2 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrEvery(proposed, function(msg) {
			return !msg.id;
		})) {
			/* RTL6d7 */
			return false;
		}
		/* we're good to go! */
		dest[kind] = proposed;
		return true;
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		var maxSize = this.options.maxMessageSize;
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Object(_util_multicaster__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		var numQueued = this.queuedMessages.count();
		if(numQueued > 0) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
			this.queuedMessages.completeAllMessages(err);
		}
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing,
			notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			if(notControlMsg) {
				var suppressed = this.setConnectionSerial(message);
				if(suppressed) {
					return;
				}
				if(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isDuplicate(message, this.mostRecentMsg)) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onChannelMessage()', 'received message with different connectionSerial, but same message id as a previous; discarding; id = ' + message.id);
					return;
				}
				this.mostRecentMsg = message;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
				id = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].cheapRandStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					transport.off('heartbeat', onHeartbeat);
					clearTimeout(timer);
					var responseTime = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.on('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].remove(transportPreferenceName);
		}
	};

	/* This method is only used during connection attempts, so implements RSA4c1,
	 * RSA4c2, and RSA4d. In particular it is not invoked for
	 * serverside-triggered reauths or manual reauths, so RSA4c3 does not apply */
	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40171) {
			/* No way to reauth */
			this.notifyState({state: 'failed', error: err});
		} else if(err.statusCode === 403) {
			var msg = 'Client configured authentication provider returned 403; failing the connection';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
			this.notifyState({state: 'failed', error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 403, err)});
		} else {
			var msg = 'Client configured authentication provider request failed';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
			this.notifyState({state: this.state.failState, error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 401, err)});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		this.connectionDetails = connectionDetails;
		if(connectionDetails.maxMessageSize) {
			this.options.maxMessageSize = connectionDetails.maxMessageSize;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionManager);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_225303__(17)))

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_321878__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_321878__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_321878__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_321878__(0);




var MessageQueue = (function() {
	function MessageQueue() {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		this.messages = [];
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(MessageQueue, _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

/* harmony default export */ __webpack_exports__["a"] = (MessageQueue);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_324635__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_324635__(1);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_324635__(7);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_324635__(3);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_324635__(2);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_324635__(6);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_324635__(0);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_324635__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_324635__(5);
/* harmony import */ var _util_domevent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_324635__(35);










var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof global !== 'undefined' && global.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
	 * it is 'chunked'. So instead, decide that it is chunked when
	 * transfer-encoding is present or content-length is absent.  ('or' because
	 * when using http2 streaming, there's no transfer-encoding header, but can
	 * still deduce streaming from lack of content-length) */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& (xhr.getResponseHeader('transfer-encoding')
			|| !xhr.getResponseHeader('content-length'));
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrMap(headerPairs[i].split(':'), _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		params = params || {};
		params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.method = method ? method.toUpperCase() : (_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(body) ? 'GET' : 'POST');
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(XHRRequest, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new XHRRequest(uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(!err && body) {
				this.emit('data', body);
			}
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = this.method,
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/x-msgpack') === 0) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}

		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = true;
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					responseBody,
					/* Be liberal in what we accept; buggy auth servers may respond
					 * without the correct contenttype, but assume they're still
					 * responding with json */
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				if(json) {
					/* If we requested msgpack but server responded with json, then since
					 * we set the responseType expecting msgpack, the response will be
					 * an ArrayBuffer containing json */
					responseBody = (xhr.responseType === 'arraybuffer') ? platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].utf8Decode(xhr.response) : String(xhr.responseText);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				} else {
					responseBody = xhr.response;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error && _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(responseBody.error);
			if(!err) {
				err = new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Error response received from server: ' + statusCode + ' body was: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(responseBody), null, statusCode);
			}
			self.complete(err, responseBody, headers, unpacked, statusCode);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].xhrSupported) {
		if(typeof _util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"] === 'object') {
			_util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].addUnloadListener(clearPendingRequests);
		}
		if(typeof(platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]) !== 'undefined') {
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].supportsAuthHeaders = true;
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts, method);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
				var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].internetUpUrl;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getUri(null, upUrl, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

/* harmony default export */ __webpack_exports__["a"] = (XHRRequest);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_324635__(17)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_338023__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338023__(12), __nested_webpack_require_338023__(10), __nested_webpack_require_338023__(46), __nested_webpack_require_338023__(18), __nested_webpack_require_338023__(37), __nested_webpack_require_338023__(36), __nested_webpack_require_338023__(29), __nested_webpack_require_338023__(30), __nested_webpack_require_338023__(31), __nested_webpack_require_338023__(47), __nested_webpack_require_338023__(48));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_338536__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338536__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_342432__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_342432__(12), __nested_webpack_require_342432__(37), __nested_webpack_require_342432__(29));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_346322__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_346322__(12), __nested_webpack_require_346322__(30));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_375869__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_375869__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_376140__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_376140__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_376424__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_376424__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_376424__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_376424__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_376424__(0);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_376424__(26);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_376424__(2);







var Protocol = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;

	function Protocol(transport) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.transport = transport;
		this.messageQueue = new _messagequeue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Protocol, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Protocol.prototype.onAck = function(serial, count) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		if(!err) {
			err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.send()', 'sending msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

/* harmony default export */ __webpack_exports__["a"] = (Protocol);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_380416__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(global, 'unload', listener);
	};

	return DomEvent;
})();

/* harmony default export */ __webpack_exports__["a"] = (DomEvent);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_380416__(17)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_381626__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_381626__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_387076__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_387076__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_391051__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_391051__(12), __nested_webpack_require_391051__(36), __nested_webpack_require_391051__(29));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_391387__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_391387__(1);
/* harmony import */ var _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_391387__(15);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_391387__(3);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_391387__(7);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_391387__(6);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_391387__(2);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_391387__(4);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_391387__(0);









var JSONPTransport = function(connectionManager) {
	var noop = function() {};
	/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
	var _ = global._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var head = null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		_common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(JSONPTransport, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	JSONPTransport.isAvailable = function() {
		return platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].allowComet;
	};
	if(JSONPTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = JSONPTransport;
	}
	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported) {
		head = document.getElementsByTagName('head')[0];
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	global.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new Request(undefined, uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['Ably-Agent']) this.params.agent = headers['Ably-Agent'];
		}
		this.body = body;
		this.method = method;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(Request, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			method = this.method,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body) {
			params.body = body;
		}
		if(method && method !== 'get') {
			params.method = method;
		}

		var script = this.script = document.createElement('script');
		var src = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('JSONP script error (event: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && !platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request) {
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, rest && rest.options.timeouts, method);
			req.once('complete', callback);
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
			return req;
		};

		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
			var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (JSONPTransport);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_391387__(17)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_402742__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_402742__(3);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_402742__(1);
/* harmony import */ var _transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_402742__(20);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_402742__(4);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_402742__(0);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_402742__(8);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_402742__(2);








var WebSocketTransport = function(connectionManager) {
	var WebSocket = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].useProtocolHeartbeats;
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.wsHost = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHost(params.options, params.host, true);
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(WebSocketTransport, _transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		connectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		this.uri = uri + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].toQueryString(connectParams)
		return new WebSocket(this.uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getPort(options) + '/';
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(self.isDisposed) {
				return;
			}
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.onActivity(); });
				}
			} catch(e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		try {
			wsConnection.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].serialize(message, this.params.format));
		} catch (e) {
			var msg = 'Exception from ws connection when trying to send: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(e);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', msg);
			/* Don't try to request a disconnect, that'll just involve sending data
			 * down the websocket again. Just finish the transport. */
			this.finish('disconnected', new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 50000, 500));
		}
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].deserialize(data, this.format));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 80003, 400);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.dispose()', '');
		this.isDisposed = true;
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (WebSocketTransport);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_413003__) {

"use strict";

// EXTERNAL MODULE: ./browser/lib/transport/jsonptransport.js
var jsonptransport = __nested_webpack_require_413003__(39);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_413003__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_413003__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_413003__(3);

// EXTERNAL MODULE: ./common/lib/transport/comettransport.js
var comettransport = __nested_webpack_require_413003__(15);

// EXTERNAL MODULE: ./browser/lib/transport/xhrrequest.js
var xhrrequest = __nested_webpack_require_413003__(27);

// CONCATENATED MODULE: ./browser/lib/transport/xhrpollingtransport.js






var xhrpollingtransport_XHRPollingTransport = function(connectionManager) {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRPollingTransport, comettransport["a" /* default */]);

	XHRPollingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/xhrstreamingtransport.js






var xhrstreamingtransport_XHRStreamingTransport = function(connectionManager) {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRStreamingTransport, comettransport["a" /* default */]);

	XHRStreamingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].streamingSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/index.js




/* harmony default export */ var lib_transport = __webpack_exports__["a"] = ([
  jsonptransport["a" /* default */],
  xhrpollingtransport,
  xhrstreamingtransport
]);


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_417833__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__nested_webpack_require_417833__(43);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_417833__(17)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_420045__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_420045__(17), __nested_webpack_require_420045__(44)))

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 45 */
/***/ (function(module, exports) {



/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_432274__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_432274__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_436272__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_436272__(12), __nested_webpack_require_436272__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_437981__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437981__(12), __nested_webpack_require_437981__(18), __nested_webpack_require_437981__(49), __nested_webpack_require_437981__(30), __nested_webpack_require_437981__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_446491__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_446491__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_455833__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_455833__.r(__webpack_exports__);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_455833__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_455833__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_455833__(0);

// EXTERNAL MODULE: ./common/lib/util/defaults.js + 1 modules
var defaults = __nested_webpack_require_455833__(4);

// EXTERNAL MODULE: ./common/lib/client/auth.js + 1 modules
var auth = __nested_webpack_require_455833__(14);

// CONCATENATED MODULE: ./common/lib/types/devicedetails.js


var devicedetails_DeviceDetails = (function() {

	function DeviceDetails() {
		this.id = undefined;
		this.deviceSecret = undefined;
		this.platform = undefined;
		this.formFactor = undefined;
		this.clientId = undefined;
		this.metadata = undefined;
		this.deviceIdentityToken = undefined;
		this.push = {
			recipient: undefined,
			state: undefined,
			error: undefined
		};
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	DeviceDetails.prototype.toJSON = function() {
		return {
			id: this.id,
			deviceSecret: this.deviceSecret,
			platform: this.platform,
			formFactor: this.formFactor,
			clientId: this.clientId,
			metadata: this.metadata,
			deviceIdentityToken: this.deviceIdentityToken,
			push: {
				recipient: this.push.recipient,
				state: this.push.state,
				error: this.push.error
			}
		};
	};

	DeviceDetails.prototype.toString = function() {
		var result = '[DeviceDetails';
		if(this.id)
			result += '; id=' + this.id;
		if(this.platform)
			result += '; platform=' + this.platform;
		if(this.formFactor)
			result += '; formFactor=' + this.formFactor;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.metadata)
			result += '; metadata=' + this.metadata;
		if(this.deviceIdentityToken)
			result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
		if(this.push.recipient)
			result += '; push.recipient=' + JSON.stringify(this.push.recipient);
		if(this.push.state)
			result += '; push.state=' + this.push.state;
		if(this.push.error)
			result += '; push.error=' + JSON.stringify(this.push.error);
		if(this.push.metadata)
			result += '; push.metadata=' + this.push.metadata;
		result += ']';
		return result;
	};

	DeviceDetails.toRequestBody = utils["a" /* default */].encodeBody;

	DeviceDetails.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return DeviceDetails.fromValuesArray(body);
		} else {
			return DeviceDetails.fromValues(body);
		}
	};

	DeviceDetails.fromValues = function(values) {
		values.error = values.error && ErrorInfo.fromValues(values.error); 
		return utils["a" /* default */].mixin(new DeviceDetails(), values);
	};

	DeviceDetails.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);
		return result;
	};

	return DeviceDetails;
})();

/* harmony default export */ var devicedetails = (devicedetails_DeviceDetails);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_455833__(6);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_455833__(5);

// CONCATENATED MODULE: ./common/lib/client/resource.js







var resource_Resource = (function() {
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (http["a" /* default */].supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(utils["a" /* default */].mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, utils["a" /* default */].mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, outerHeaders, unpacked, outerStatusCode) {
			if(err && !body) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = utils["a" /* default */].decodeBody(body, format);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, outerHeaders, true, outerStatusCode);
				return;
			}

			var wrappedStatusCode = body.statusCode,
				response = body.response,
				wrappedHeaders = body.headers;

			if(wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
				/* handle wrapped errors */
				var wrappedErr = (response && response.error) || err;
				if(!wrappedErr) {
					wrappedErr = new Error("Error in unenveloping " + body);
					wrappedErr.statusCode = wrappedStatusCode;
				}
				callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
				return;
			}

			callback(err, response, wrappedHeaders, true, wrappedStatusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, method, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + utils["a" /* default */].inspectError(err));
			} else {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (bufferutils["a" /* default */].isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, null, origheaders, origparams, envelope, callback);
		};
	});

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, body, origheaders, origparams, envelope, callback);
		};
	});

	Resource['do'] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
		if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
			callback = logResponseHandler(callback, method, path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doRequest(headers, params) {
			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			var args = [rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && auth["a" /* default */].isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doRequest);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			}];
			if (!body) {
				args.splice(3, 1);
			}

			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						decodedBody = msgpack.decode(body);
					} catch (decodeErr) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + utils["a" /* default */].inspectError(decodeErr));
					}
				}
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}
			http["a" /* default */][method].apply(this, args);
		}

		withAuthDetails(rest, origheaders, origparams, callback, doRequest);
	};

	return Resource;
})();

/* harmony default export */ var client_resource = (resource_Resource);

// CONCATENATED MODULE: ./common/lib/client/paginatedresource.js





var paginatedresource_PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && utils["a" /* default */].parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		PaginatedResource.prototype[method] = function(params, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
				self.handlePage(err, body, headers, unpacked, statusCode, callback);
			});
		};
	})

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		PaginatedResource.prototype[method] = function(params, body, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
				if(callback) {
					self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
				}
			});
		};
	});

	function returnErrOnly(err, body, useHPR) {
		/* If using httpPaginatedResponse, errors from Ably are returned as part of
		 * the HPR, only do callback(err) for network errors etc. which don't
		 * return a body and/or have no ably-originated error code (non-numeric
		 * error codes originate from node) */
		return !(useHPR && (body || typeof err.code === 'number'));
	}

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + utils["a" /* default */].inspectError(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			/* If we got an error, the failure to parse the body is almost certainly
			 * due to that, so cb with that in preference to the parse error */
			callback(err || e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams) {
				this.first = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'first', []);
					}
					self.get(relParams.first, cb);
				};
			}
			if('current' in relParams) {
				this.current = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'current', []);
					}
					self.get(relParams.current, cb);
				};
			}
			this.next = function(cb) {
				if(!cb && self.resource.rest.options.promises) {
					return utils["a" /* default */].promisify(self, 'next', []);
				}
				if('next' in relParams) {
					self.get(relParams.next, cb);
				} else {
					cb(null, null);
				}
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		this.errorCode = err && err.code;
		this.errorMessage = err && err.message;
	}
	utils["a" /* default */].inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

/* harmony default export */ var paginatedresource = (paginatedresource_PaginatedResource);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_455833__(2);

// CONCATENATED MODULE: ./common/lib/types/pushchannelsubscription.js


var pushchannelsubscription_PushChannelSubscription = (function() {

	function PushChannelSubscription() {
		this.channel = undefined;
		this.deviceId = undefined;
		this.clientId = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PushChannelSubscription.prototype.toJSON = function() {
		return {
			channel: this.channel,
			deviceId: this.deviceId,
			clientId: this.clientId
		};
	};

	PushChannelSubscription.prototype.toString = function() {
		var result = '[PushChannelSubscription';
		if(this.channel)
			result += '; channel=' + this.channel;
		if(this.deviceId)
			result += '; deviceId=' + this.deviceId;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		result += ']';
		return result;
	};

	PushChannelSubscription.toRequestBody = utils["a" /* default */].encodeBody;

	PushChannelSubscription.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return PushChannelSubscription.fromValuesArray(body);
		} else {
			return PushChannelSubscription.fromValues(body);
		}
	};

	PushChannelSubscription.fromValues = function(values) {
		return utils["a" /* default */].mixin(new PushChannelSubscription(), values);
	};

	PushChannelSubscription.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);
		return result;
	};

	return PushChannelSubscription;
})();

/* harmony default export */ var pushchannelsubscription = (pushchannelsubscription_PushChannelSubscription);

// CONCATENATED MODULE: ./common/lib/client/push.js








var push_Push = (function() {
	var noop = function() {};

	function Push(rest) {
		this.rest = rest;
		this.admin = new Admin(rest);
	}

	function Admin(rest) {
		this.rest = rest;
		this.deviceRegistrations = new DeviceRegistrations(rest);
		this.channelSubscriptions = new ChannelSubscriptions(rest);
	}

	Admin.prototype.publish = function(recipient, payload, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = utils["a" /* default */].mixin({recipient: recipient}, payload),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/publish', requestBody, headers, params, false, function(err) { callback(err); });
	};

	function DeviceRegistrations(rest) {
		this.rest = rest;
	}

	DeviceRegistrations.prototype.save = function(device, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = devicedetails.fromValues(device),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		client_resource.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/deviceRegistrations', headers, envelope, function(body, headers, unpacked) {
			return devicedetails.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			params = {},
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'remove', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, false, function(err) { callback(err); });
	};

	DeviceRegistrations.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations', headers, params, false, function(err) { callback(err); });
	};

	function ChannelSubscriptions(rest) {
		this.rest = rest;
	}

	ChannelSubscriptions.prototype.save = function(subscription, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = pushchannelsubscription.fromValues(subscription),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/channelSubscriptions', requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
		});
	};

	ChannelSubscriptions.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/channelSubscriptions', headers, envelope, function(body, headers, unpacked) {
			return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/channelSubscriptions', headers, params, false, function(err) { callback(err); });
	};

	/* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
	ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;

	ChannelSubscriptions.prototype.listChannels = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'listChannels', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		(new paginatedresource(rest, '/push/channels', headers, envelope, function(body, headers, unpacked) {
			var f = !unpacked && format;

			if(f) {
				body = utils["a" /* default */].decodeBody(body, format);
			}

			for(var i = 0; i < body.length; i++) {
				body[i] = String(body[i]);
			}
			return body;
		})).get(params, callback);
	};

	return Push;
})();

/* harmony default export */ var push = (push_Push);

// EXTERNAL MODULE: ./common/lib/util/eventemitter.js
var eventemitter = __nested_webpack_require_455833__(7);

// EXTERNAL MODULE: ./common/lib/types/presencemessage.js
var presencemessage = __nested_webpack_require_455833__(11);

// CONCATENATED MODULE: ./common/lib/client/presence.js







var presence_Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	utils["a" /* default */].inherits(Presence, eventemitter["a" /* default */]);

	Presence.prototype.get = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'get', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, '_history', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this.channel;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

/* harmony default export */ var client_presence = (presence_Presence);

// EXTERNAL MODULE: ./browser/lib/util/crypto.js
var util_crypto = __nested_webpack_require_455833__(19);

// EXTERNAL MODULE: ./common/lib/types/message.js
var types_message = __nested_webpack_require_455833__(9);

// CONCATENATED MODULE: ./common/lib/client/channel.js











var channel_Channel = (function() {
	function noop() {}
	var MSG_ID_ENTROPY_BYTES = 9;

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Channel()', 'started; name = ' + name);
		eventemitter["a" /* default */].call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new client_presence(this);
		this.setOptions(channelOptions);
	}
	utils["a" /* default */].inherits(Channel, eventemitter["a" /* default */]);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!util_crypto["a" /* default */]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = util_crypto["a" /* default */].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new paginatedresource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return types_message["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	function allEmptyIds(messages) {
		return utils["a" /* default */].arrEvery(messages, function(message) {
			return !message.id;
		});
	}

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			first = arguments[0],
			second = arguments[1],
			callback = arguments[argCount - 1],
			messages,
			params,
			self = this;

		if(typeof(callback) !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(typeof first === 'string' || first === null) {
			/* (name, data, ...) */
			messages = [types_message["a" /* default */].fromValues({name: first, data: second})];
			params = arguments[2];
		} else if(utils["a" /* default */].isObject(first)) {
			messages = [types_message["a" /* default */].fromValues(first)];
			params = arguments[1];
		} else if(utils["a" /* default */].isArray(first)) {
			messages = types_message["a" /* default */].fromValuesArray(first);
			params = arguments[1];
		} else {
			throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		}

		if(typeof params !== 'object' || !params) {
			/* No params supplied (so after-message argument is just the callback or undefined) */
			params = {};
		}

		var rest = this.rest,
			options = rest.options,
			format = options.useBinaryProtocol ? 'msgpack' : 'json',
			idempotentRestPublishing = rest.options.idempotentRestPublishing,
			headers = utils["a" /* default */].defaultPostHeaders(format);

		if(options.headers)
			utils["a" /* default */].mixin(headers, options.headers);

		if(idempotentRestPublishing && allEmptyIds(messages)) {
			var msgIdBase = utils["a" /* default */].randomString(MSG_ID_ENTROPY_BYTES);
			utils["a" /* default */].arrForEach(messages, function(message, index) {
				message.id = msgIdBase + ':' + index.toString();
			});
		}

		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if(err) {
				callback(err);
				return;
			}

			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages),
				maxMessageSize = options.maxMessageSize;
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}

			self._publish(types_message["a" /* default */].serialize(messages, format), headers, params, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, params, callback) {
		client_resource.post(this.rest, this.basePath + '/messages', requestBody, headers, params, false, callback);
	};

	return Channel;
})();

/* harmony default export */ var client_channel = (channel_Channel);

// CONCATENATED MODULE: ./common/lib/types/stats.js


var stats_Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.uncompressedData = (values && values.uncompressedData) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function MessageCategory(values) {
		var self = this;
		MessageCount.call(this, values);
		this.category = undefined;
		if (values && values.category) {
			this.category = { };
			utils["a" /* default */].forInOwnNonNullProps(values.category, function(prop) {
				self.category[prop] = new MessageCount(values.category[prop]);
			});
		}
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCategory(values && values.messages);
		this.presence = new MessageCategory(values && values.presence);
		this.all = new MessageCategory(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.httpEvent = new MessageTypes(values && values.httpEvent);
		this.push = new MessageTypes(values && values.push);
		this.all = new MessageTypes(values && values.all);
	}

	function MessageDirections(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
	}

	function XchgMessages(values) {
		this.all           = new MessageTypes(values && values.all);
		this.producerPaid  = new MessageDirections(values && values.producerPaid);
		this.consumerPaid  = new MessageDirections(values && values.consumerPaid);
	}

	function PushStats(values) {
		this.messages = (values && values.messages) || 0;
		var notifications = values && values.notifications;
		this.notifications = {
			invalid: notifications && notifications.invalid || 0,
			attempted: notifications && notifications.attempted || 0,
			successful: notifications && notifications.successful || 0,
			failed: notifications && notifications.failed || 0
		};
		this.directPublishes = (values && values.directPublishes) || 0;
	}

	function ProcessedCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.skipped = (values && values.skipped) || 0;
		this.failed = (values && values.failed) || 0;
	}

	function ProcessedMessages(values) {
		var self = this;
		this.delta = undefined;
		if (values && values.delta) {
			this.delta = { };
			utils["a" /* default */].forInOwnNonNullProps(values.delta, function(prop) {
				self.delta[prop] = new ProcessedCount(values.delta[prop]);
			});
		}
	}

	function Stats(values) {
		MessageDirections.call(this, values);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.xchgProducer  = new XchgMessages(values && values.xchgProducer);
		this.xchgConsumer  = new XchgMessages(values && values.xchgConsumer);
		this.push          = new PushStats(values && values.pushStats);
		this.processed     = new ProcessedMessages(values && values.processed);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

/* harmony default export */ var stats = (stats_Stats);

// CONCATENATED MODULE: ./common/lib/client/rest.js












var rest_Rest = (function() {
	var noop = function() {};
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		options = defaults["a" /* default */].objectifyOptions(options);

		if(options.log) {
			logger["a" /* default */].setLog(options.log.level, options.log.handler);
		}
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + utils["a" /* default */].inspect(options));

		this.options = defaults["a" /* default */].normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new errorinfo["a" /* default */]('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Rest()', 'started; version = ' + defaults["a" /* default */].libstring);

		this.baseUri = this.authority = function(host) { return defaults["a" /* default */].getHttpScheme(options) + host + ':' + defaults["a" /* default */].getPort(options, false); };
		this._currentFallback = null;

		this.serverTimeOffset = null;
		this.auth = new auth["a" /* default */](this, options);
		this.channels = new Channels(this);
		this.push = new push(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'stats', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders(),
			format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;

		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);

		(new paginatedresource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'time', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders();
		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		http["a" /* default */].get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - utils["a" /* default */].now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var useBinary = this.options.useBinaryProtocol,
			encoder = useBinary ? msgpack.encode: JSON.stringify,
			decoder = useBinary ? msgpack.decode : JSON.parse,
			format = useBinary ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;
		params = params || {};
		method = method.toLowerCase();
		var headers = method == 'get' ? utils["a" /* default */].defaultGetHeaders(format) : utils["a" /* default */].defaultPostHeaders(format);

		if(callback === undefined) {
			if(this.options.promises) {
				return utils["a" /* default */].promisify(this, 'request', [method, path, params, body, customHeaders]);
			}
			callback = noop;
		}

		if(typeof body !== 'string') {
			body = encoder(body);
		}
		if(this.options.headers) {
			utils["a" /* default */].mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			utils["a" /* default */].mixin(headers, customHeaders);
		}
		var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return utils["a" /* default */].ensureArray(unpacked ? resbody : decoder(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		if(!utils["a" /* default */].arrIn(http["a" /* default */].methods, method)) {
			throw new errorinfo["a" /* default */]('Unsupported method ' + method, 40500, 405);
		}

		if(utils["a" /* default */].arrIn(http["a" /* default */].methodsWithBody, method)) {
			paginatedResource[method](params, body, callback);
		} else {
			paginatedResource[method](params, callback);
		}
	};

	Rest.prototype.setLog = function(logOptions) {
		logger["a" /* default */].setLog(logOptions.level, logOptions.handler);
	};

	function Channels(rest) {
		this.rest = rest;
		this.all = Object.create(null);
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		delete this.all[String(name)];
	};

	return Rest;
})();

rest_Rest.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new rest_Rest(options);
};

rest_Rest.Callbacks = rest_Rest;

/* harmony default export */ var client_rest = (rest_Rest);

// EXTERNAL MODULE: ./common/lib/transport/connectionmanager.js
var connectionmanager = __nested_webpack_require_455833__(25);

// EXTERNAL MODULE: ./common/lib/client/connectionstatechange.js
var connectionstatechange = __nested_webpack_require_455833__(21);

// CONCATENATED MODULE: ./common/lib/client/connection.js






var connection_Connection = (function() {
	function noop() {}

	/* public constructor */
	function Connection(ably, options) {
		eventemitter["a" /* default */].call(this);
		this.ably = ably;
		this.connectionManager = new connectionmanager["a" /* default */](ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.timeSerial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			utils["a" /* default */].nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			utils["a" /* default */].nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	utils["a" /* default */].inherits(Connection, eventemitter["a" /* default */]);

	Connection.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener, new connectionstatechange["a" /* default */](undefined, state));
	}

	Connection.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.ping()', '');
		if(!callback) {
			if(this.ably.options.promises) {
				return utils["a" /* default */].promisify(this, 'ping', arguments);
			}
			callback = noop;
		}
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

/* harmony default export */ var connection = (connection_Connection);

// EXTERNAL MODULE: ./common/lib/types/protocolmessage.js
var protocolmessage = __nested_webpack_require_455833__(8);

// EXTERNAL MODULE: ./common/lib/transport/connectionerror.js
var connectionerror = __nested_webpack_require_455833__(13);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var util_multicaster = __nested_webpack_require_455833__(22);

// CONCATENATED MODULE: ./common/lib/client/channelstatechange.js
var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

/* harmony default export */ var channelstatechange = (ChannelStateChange);

// CONCATENATED MODULE: ./common/lib/client/realtimepresence.js











var realtimepresence_RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymousOrWildcard(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		var clientId = realtime.auth.clientId;
		return (!clientId || (clientId === '*')) && realtime.connection.state === 'connected';
	}

	/* Callback is called only in the event of an error */
	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		client_presence.call(this, channel);
		this.syncComplete = false;
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new eventemitter["a" /* default */]();
		this.pendingPresence = [];
	}
	utils["a" /* default */].inherits(RealtimePresence, client_presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to enter a presence channel', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'enter', callback);
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to update presence data', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'update', callback);
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'enter', callback);
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'update', callback);
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, '_enterOrUpdateClient', [clientId, data, action]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  'channel = ' + channel.name + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));

		var presence = presencemessage["a" /* default */].fromValues({
			action : action,
			data   : data
		});
		if (clientId) {
			presence.clientId = clientId;
		}

		var self = this;
		presencemessage["a" /* default */].encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.attach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					err = new errorinfo["a" /* default */]('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		}
		return this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'leaveClient', [clientId, data]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = presencemessage["a" /* default */].fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new errorinfo["a" /* default */]('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(connectionerror["a" /* default */].failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1],
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', args);
			}
			callback = noop;
		}

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(errorinfo["a" /* default */].fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.properties.attachSerial;
			} else {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		client_presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = presencemessage["a" /* default */].fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized()) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(realtimechannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Object(util_multicaster["a" /* default */])();
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + utils["a" /* default */].inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new errorinfo["a" /* default */](msg, 91004, 400);
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new channelstatechange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, 'enter', reenterCb);
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		utils["a" /* default */].arrForEach(items, function(item) {
			var presence = presencemessage["a" /* default */].fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: utils["a" /* default */].now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		logger["a" /* default */].deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		logger["a" /* default */].deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var channel = this.channel;
		var self = this;

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(channel.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);
		channel.attach(callback);
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	function PresenceMap(presence) {
		eventemitter["a" /* default */].call(this);
		this.presence = presence;
		this.map = Object.create(null);
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	utils["a" /* default */].inherits(PresenceMap, eventemitter["a" /* default */]);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = utils["a" /* default */].copy(map);
			this.setInProgress(true);
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(utils["a" /* default */].valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.setInProgress(false);
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.setInProgress(false);
		this.residualMembers = null;
	};

	PresenceMap.prototype.setInProgress = function(inProgress) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
		this.syncInProgress = inProgress;
		this.presence.syncComplete = !inProgress;
	};

	return RealtimePresence;
})();

/* harmony default export */ var realtimepresence = (realtimepresence_RealtimePresence);

// CONCATENATED MODULE: ./common/lib/client/realtimechannel.js












var realtimechannel_RealtimeChannel = (function() {
	var actions = protocolmessage["a" /* default */].Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		client_channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new realtimepresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new eventemitter["a" /* default */]();
		this.syncChannelSerial = undefined;
		this.properties = {
			attachSerial: undefined
		};
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
		/* Temporary; only used for the checkChannelsOnResume option */
		this._attachedMsgIndicator = false;
		this._attachResume = false;
		this._decodingContext = {
			channelOptions: this.channelOptions,
			plugins: realtime.options.plugins || { },
			baseEncodedPreviousPayload: undefined
		};
		this._lastPayload = {
			messageId: null,
			protocolMessageChannelSerial: null,
			decodeFailureRecoveryInProgress: null
		};
		/* Only differences between this and the public event emitter is that this emits an
		 * update event for all ATTACHEDs, whether resumed or not */
		this._allChannelChanges = new eventemitter["a" /* default */]();
	}
	utils["a" /* default */].inherits(RealtimeChannel, client_channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		args = Array.prototype.slice.call(args);
		if(typeof args[0] === 'function') {
			args.unshift(null);
		}
		if(args[args.length - 1] == undefined) {
			args.pop();
		}
		return args;
	};

	RealtimeChannel.prototype.setOptions = function(options, callback) {
		if(!callback) {
			if (this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'setOptions', arguments);
			}

			callback = function(err){
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
				}
			};
		}
		var err = validateChannelOptions(options);
		if(err) {
			callback(err);
			return;
		}
		client_channel.prototype.setOptions.call(this, options);
		if (this._decodingContext)
			this._decodingContext.channelOptions = this.channelOptions;
		if(this._shouldReattachToSetOptions(options)) {
			/* This does not just do _attach(true, null, callback) because that would put us
			 * into the 'attaching' state until we receive the new attached, which is
			 * conceptually incorrect: we are still attached, we just have a pending request to
			 * change some channel params. Per RTL17 going into the attaching state would mean
			 * rejecting messages until we have confirmation that the options have changed,
			 * which would unnecessarily lose message continuity. */
			this.attachImpl();
			this._allChannelChanges.once(function(stateChange) {
				switch(this.event) {
					case 'update':
					case 'attached':
						callback(null);
						return;
					default:
						callback(stateChange.reason);
						return;
				}
			});
		} else {
			callback();
		}
	};

	function validateChannelOptions(options) {
		if(options && 'params' in options && !utils["a" /* default */].isObject(options.params)) {
			return new errorinfo["a" /* default */]('options.params must be an object', 40000, 400);
		}
		if(options && 'modes' in options){
			if(!utils["a" /* default */].isArray(options.modes)){
				return new errorinfo["a" /* default */]('options.modes must be an array', 40000, 400);
			}
			for(var i = 0; i < options.modes.length; i++){
				var currentMode = options.modes[i];
				if(!currentMode || typeof currentMode !== 'string' || !utils["a" /* default */].arrIn(protocolmessage["a" /* default */].channelModes, String.prototype.toUpperCase.call(currentMode))){
					return new errorinfo["a" /* default */]('Invalid channel mode: ' + currentMode, 40000, 400);
				}
			}
		}
	}

	RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
		return (this.state === 'attached' || this.state === 'attaching') && (options.params || options.modes);
	};

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getError());
			return;
		}
		if(argCount == 2) {
			if(utils["a" /* default */].isObject(messages))
				messages = [types_message["a" /* default */].fromValues(messages)];
			else if(utils["a" /* default */].isArray(messages))
				messages = types_message["a" /* default */].fromValuesArray(messages);
			else
				throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [types_message["a" /* default */].fromValues({name: arguments[0], data: arguments[1]})];
		}
		var self = this,
			maxMessageSize = this.realtime.options.maxMessageSize;
		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages);
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		var state = this.state;
		switch(state) {
			case 'failed':
			case 'suspended':
				callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError(state)));
				break;
			default:
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
				var msg = new protocolmessage["a" /* default */]();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'attach', arguments);
			}
			callback = function(err) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}
		if(flags) {
			logger["a" /* default */].deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
			/* If flags requested, always do a re-attach. TODO only do this if
			 * current mode differs from requested mode */
			this._requestedFlags = flags;
		} else if (this.state === 'attached') {
			callback();
			return;
		}

		this._attach(false, null, callback);
	};

	RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
		if(!callback) {
			callback = function(err) {
				if (err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}

		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}

		if (this.state !== 'attaching' || forceReattach) {
			this.requestState('attaching', attachReason);
		}

		this.once(function(stateChange) {
			switch(this.event) {
				case 'attached':
					callback();
					break;
				case 'detached':
				case 'suspended':
				case 'failed':
					callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
					break;
				case 'detaching':
					callback(new errorinfo["a" /* default */]('Attach request superseded by a subsequent detach request', 90000, 409));
					break;
			}
		});
	};

	RealtimeChannel.prototype.attachImpl = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = protocolmessage["a" /* default */].fromValues({action: actions.ATTACH, channel: this.name, params: this.channelOptions.params});
		if(this._requestedFlags) {
			attachMsg.encodeModesToFlags(this._requestedFlags);
		} else if(this.channelOptions.modes) {
			attachMsg.encodeModesToFlags(utils["a" /* default */].allToUpperCase(this.channelOptions.modes));
		}
		if(this._attachResume) {
			attachMsg.setFlag('ATTACH_RESUME');
		}
		if(this._lastPayload.decodeFailureRecoveryInProgress) {
			attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'detach', arguments);
			}
			callback = noop;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}
		switch(this.state) {
                        case 'suspended':
                                this.notifyState('detached');
                                callback();
                                break;
			case 'detached':
				callback();
				break;
			case 'failed':
				callback(new errorinfo["a" /* default */]('Unable to detach; channel state = failed', 90001, 400));
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'attached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
							break;
						case 'attaching':
							callback(new errorinfo["a" /* default */]('Detach request superseded by a subsequent attach request', 90000, 409));
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = protocolmessage["a" /* default */].fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(this.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);

		return this.attach(callback);
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new errorinfo["a" /* default */]("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getError();
		}

		/* send sync request */
		var syncMessage = protocolmessage["a" /* default */].fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = protocolmessage["a" /* default */].fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (utils["a" /* default */].isArray(presence) ?
				presencemessage["a" /* default */].fromValuesArray(presence) :
				[presencemessage["a" /* default */].fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this._attachedMsgIndicator = true;
			this.properties.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			this.params = message.params || {};
			var modesFromFlags = message.decodeModesFromFlags();
			this.modes = (modesFromFlags && utils["a" /* default */].allToLowerCase(modesFromFlags)) || undefined;
			var resumed = message.hasFlag('RESUMED');
			var hasPresence = message.hasFlag('HAS_PRESENCE');
			if(this.state === 'attached') {
				/* attached operations to change options set the inprogress mutex, but leave
				 * channel in the attached state */
				this.setInProgress(statechangeOp, false);
				if(!resumed) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(hasPresence);
				}
				var change = new channelstatechange(this.state, this.state, resumed, message.error);
				this._allChannelChanges.emit('update', change);
				if(!resumed || this.channelOptions.updateOnAttached) {
					this.emit('update', change);
				}
			} else if(this.state === 'detaching') {
				/* RTL5i: re-send DETACH and remain in the 'detaching' state */
				this.checkPendingState();
			} else {
				this.notifyState('attached', message.error, resumed, hasPresence);
			}
			break;

		case actions.DETACHED:
			var err = message.error ? errorinfo["a" /* default */].fromValues(message.error) : new errorinfo["a" /* default */]('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					presencemessage["a" /* default */].decode(presenceMsg, options);
				} catch (e) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:

			//RTL17
			if(this.state !== 'attached') {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
				return;
			}

			var messages = message.messages,
				firstMessage = messages[0],
				lastMessage = messages[messages.length - 1],
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			if(firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
				var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
				this._startDecodeFailureRecovery(new errorinfo["a" /* default */](msg, 40018, 400));
				break;
			}

			for(var i = 0; i < messages.length; i++) {
				var msg = messages[i];
				try {
					types_message["a" /* default */].decode(msg, this._decodingContext);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
					switch(e.code) {
						case 40018:
							/* decode failure */
							this._startDecodeFailureRecovery(e);
							return;
						case 40019:
							/* No vcdiff plugin passed in - no point recovering, give up */
						case 40021:
							/* Browser does not support deltas, similarly no point recovering */
							this.notifyState('failed', e);
							return;
					}
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this._lastPayload.messageId = lastMessage.id;
			this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', errorinfo["a" /* default */].fromValues(err));
			}
			break;

		default:
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(connectionerror["a" /* default */].unknownChannelErr);
		}
	};

	RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
		var self = this;
		if(!this._lastPayload.decodeFailureRecoveryInProgress) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
			this._lastPayload.decodeFailureRecoveryInProgress = true;
			this._attach(true, reason, function() {
				self._lastPayload.decodeFailureRecoveryInProgress = false;
			});
		}
	};

	RealtimeChannel.prototype.onAttached = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new channelstatechange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? logger["a" /* default */].LOG_ERROR : logger["a" /* default */].LOG_MAJOR;
		logger["a" /* default */].logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		if(state === 'attached') {
			this._attachResume = true;
		} else if(state === 'detaching' || state === 'failed') {
			this._attachResume = false;
		}

		this.state = state;
		this._allChannelChanges.emit(state, change);
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new errorinfo["a" /* default */]('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new errorinfo["a" /* default */]('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.properties.attachSerial) {
				callback(new errorinfo["a" /* default */]("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.properties.attachSerial;
		}

		client_channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener);
	}

	/* @returns null (if can safely be released) | ErrorInfo (if cannot) */
	RealtimeChannel.prototype.getReleaseErr = function() {
		var s = this.state;
		if(s === 'initialized' || s === 'detached' || s === 'failed') {
			return null;
		}
		return new errorinfo["a" /* default */]('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' + s, 90001, 400);
	}

	return RealtimeChannel;
})();

/* harmony default export */ var realtimechannel = (realtimechannel_RealtimeChannel);

// EXTERNAL MODULE: ./common/lib/util/errorreporter.js
var errorreporter = __nested_webpack_require_455833__(23);

// CONCATENATED MODULE: ./common/lib/client/realtime.js










var realtime_Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime()', '');
		client_rest.call(this, options);
		this.connection = new connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	utils["a" /* default */].inherits(Realtime, client_rest);

	Realtime.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		eventemitter["a" /* default */].call(this);
		this.realtime = realtime;
		this.all = Object.create(null);
		this.inProgress = Object.create(null);
		var self = this;
		realtime.connection.connectionManager.on('transport.active', function() {
			self.onTransportActive();
		});
	}
	utils["a" /* default */].inherits(Channels, eventemitter["a" /* default */]);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.attach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	Channels.prototype.resetAttachedMsgIndicators = function() {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached') {
			channel._attachedMsgIndicator = false;
			}
		}
	};

	Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached' && channel._attachedMsgIndicator === false) {
				var msg = '30s after a resume, found channel which has not received an attached; channelId = ' + channelId + '; connectionId = ' + connectionId;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.checkAttachedMsgIndicators()', msg);
				errorreporter["a" /* default */].report('error', msg, 'channel-no-attached-after-resume');
				channel.requestState('attaching');
			};
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(utils["a" /* default */].arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			if (channel._shouldReattachToSetOptions(channelOptions)) {
				throw new errorinfo["a" /* default */]("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 40000, 400);
			}
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			return;
		}
		var releaseErr = channel.getReleaseErr();
		if(releaseErr) {
			throw releaseErr;
		}
		delete this.all[name];
		delete this.inProgress[name];
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return utils["a" /* default */].arrEvery(utils["a" /* default */].valuesArray(this.inProgress, true), function(operations) {
			return !utils["a" /* default */].containsValue(operations, true);
		});
	};

	return Realtime;
})();

realtime_Realtime.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new realtime_Realtime(options);
};

realtime_Realtime.Callbacks = realtime_Realtime;

/* harmony default export */ var client_realtime = (realtime_Realtime);

// EXTERNAL MODULE: ./browser/lib/util/msgpack.js
var util_msgpack = __nested_webpack_require_455833__(24);

// CONCATENATED MODULE: ./common/lib/index.js














client_rest.Utils = utils["a" /* default */];
client_rest.BufferUtils = bufferutils["a" /* default */];
client_rest.Crypto = util_crypto["a" /* default */];
client_rest.Defaults = defaults["a" /* default */];
client_rest.Http = http["a" /* default */];
client_rest.Resource = client_resource;
client_rest.Message = types_message["a" /* default */];
client_rest.PresenceMessage = presencemessage["a" /* default */];

client_realtime.Utils = utils["a" /* default */];
client_realtime.BufferUtils = bufferutils["a" /* default */];
client_realtime.Crypto = util_crypto["a" /* default */];
client_realtime.Defaults = defaults["a" /* default */];
client_realtime.Http = http["a" /* default */];
client_realtime.Message = types_message["a" /* default */];
client_realtime.PresenceMessage = presencemessage["a" /* default */];
client_realtime.ProtocolMessage = protocolmessage["a" /* default */];
client_realtime.ConnectionManager = connectionmanager["a" /* default */];

/* harmony default export */ var lib = __webpack_exports__["default"] = ({
  Rest: client_rest,
  Realtime: client_realtime,
  msgpack: util_msgpack["a" /* default */]
});


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

function promisifyOptions(options) {
  if(typeof options == 'string') {
    options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running 
 * the build task. */
var Ably = __webpack_require__(/*! ./browser/static/ably-node */ "./node_modules/ably/browser/static/ably-commonjs.js");

var RestPromise = function(options) {
  return new Ably.Rest(promisifyOptions(options));
}
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function(options) {
  return new Ably.Realtime(promisifyOptions(options));
}
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./components/chatroom/chatComponents.module.css":
/*!*******************************************************!*\
  !*** ./components/chatroom/chatComponents.module.css ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element) {
                // These elements should always exist. If they do not,
                // this code should fail.
                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                var parentNode = anchorElement.parentNode// Normally <head>
                ;
                // Each style tag should be placed right before our
                // anchor. By inserting before and not after, we do not
                // need to track the last inserted element.
                parentNode.insertBefore(element, anchorElement);
            };
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    let p;
    for(p in a){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css",
      function () {
        content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".chatComponents_chatHolder__2E1AX {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatComponents_chatText__3MREs {\r\n  display: -webkit-flex;\r\n  display: flex;\r\n  -webkit-flex-direction: column;\r\n          flex-direction: column;\r\n  -webkit-align-items: flex-start;\r\n          align-items: flex-start;\r\n  grid-gap: 1em;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.chatComponents_form__3rFIK {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.chatComponents_textarea__2UuLy {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.chatComponents_button__3eZyM {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.chatComponents_button__3eZyM:hover {\r\n  background: -webkit-gradient(\r\n    linear,\r\n    left top, right top,\r\n    from(rgba(54, 55, 149, 1)),\r\n    color-stop(62%, rgba(0, 92, 151, 1)),\r\n    to(rgba(0, 125, 205, 1))\r\n  );\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.chatComponents_button__3eZyM:disabled,\r\n.chatComponents_button__3eZyM:hover:disabled {\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.chatComponents_message__1dnoB {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  -webkit-flex-grow: 0;\r\n          flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n", "",{"version":3,"sources":["webpack://components/chatroom/chatComponents.module.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,6BAA6B;AAC/B;;AAEA;EACE,qBAAa;EAAb,aAAa;EACb,8BAAsB;UAAtB,sBAAsB;EACtB,+BAAuB;UAAvB,uBAAuB;EACvB,aAAQ;EAAR,QAAQ;EACR,YAAY;EACZ,kDAAkD;EAClD,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,gCAAgC;EAChC,0BAA0B;AAC5B;;AAEA;EACE,YAAY;EACZ,SAAS;EACT;wEACsE;EACtE,gBAAgB;AAClB;;AAEA;EACE,SAAS;EACT,YAAY;EACZ,iBAAiB;EACjB,gBAAgB;EAChB,qFAAuD;EAAvD,uDAAuD;AACzD;;AAEA;EACE;;;;;;GAKC;EALD;;;;;GAKC;AACH;;AAEA;;EAEE,qFAAuD;EAAvD,uDAAuD;EACvD,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,YAAY;EACZ,mBAAmB;EACnB,oBAAY;UAAZ,YAAY;EACZ,4BAA4B;AAC9B","sourcesContent":[".chatHolder {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatText {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.form {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.textarea {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.button {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.button:hover {\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.button:disabled,\r\n.button:hover:disabled {\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.message {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"chatHolder": "chatComponents_chatHolder__2E1AX",
	"chatText": "chatComponents_chatText__3MREs",
	"form": "chatComponents_form__3rFIK",
	"textarea": "chatComponents_textarea__2UuLy",
	"button": "chatComponents_button__3eZyM",
	"message": "chatComponents_message__1dnoB"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9jb21wb25lbnRzX2NoYXRyb29tX2NoYXRDb21wb25lbnRzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBLElBQU1FLElBQUksR0FBRyxJQUFJRix1RUFBSixDQUEwQjtBQUFFSyxFQUFBQSxPQUFPLEVBQUU7QUFBWCxDQUExQixDQUFiLEVBRUE7O0FBRU8sU0FBU0MsVUFBVCxDQUFvQkMsV0FBcEIsRUFBaUNDLGlCQUFqQyxFQUFvRDtBQUFBOztBQUN6RCxNQUFNQyxPQUFPLEdBQUdQLElBQUksQ0FBQ1EsUUFBTCxDQUFjQyxHQUFkLENBQWtCSixXQUFsQixDQUFoQjs7QUFFQSxNQUFNSyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCSCxJQUFBQSxPQUFPLENBQUNJLFNBQVIsQ0FBa0IsVUFBQ0MsR0FBRCxFQUFTO0FBQ3pCTixNQUFBQSxpQkFBaUIsQ0FBQ00sR0FBRCxDQUFqQjtBQUNELEtBRkQ7QUFHRCxHQUpEOztBQUtBLE1BQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDdEJOLElBQUFBLE9BQU8sQ0FBQ08sV0FBUjtBQUNELEdBRkQ7O0FBSUEsTUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFNO0FBQzFCTCxJQUFBQSxPQUFPO0FBQ1AsV0FBTyxZQUFNO0FBQ1hHLE1BQUFBLFNBQVM7QUFDVixLQUZEO0FBR0QsR0FMRDs7QUFPQWQsRUFBQUEsZ0RBQVMsQ0FBQ2dCLGFBQUQsQ0FBVDtBQUVBLFNBQU8sQ0FBQ1IsT0FBRCxFQUFVUCxJQUFWLENBQVA7QUFDRDs7R0F0QmVJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJoQjtBQUNBO0FBQ0E7OztBQUVBLElB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnSUFBZ0ksYUFBYTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxTkFBcU47QUFDck47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2TEFBNkw7QUFDN0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrUkFBa1IsWUFBWTtBQUM5UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa1FBQWtRO0FBQ2xRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEIsWUFBWSxpQ0FBbUIsTUFBTSxpQ0FBbUI7O0FBRXBGLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQjtBQUN4RDtBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNktBQTZLO0FBQzdLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdILGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsOEhBQThIO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTTtBQUNyTTs7QUFFQTtBQUNBLENBQUM7O0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LHFEQUFxRCw4REFBOEQsbUJBQW1CLEtBQUssa0JBQWtCLGdDQUFnQyxtQkFBbUIsMEJBQTBCLG1CQUFtQixtQ0FBbUMsS0FBSyx1QkFBdUI7QUFDOThIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDZGU7QUFDZjs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1JlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZxRDtBQUN0QztBQUNmLGlDQUFpQyw2REFBZ0I7QUFDakQ7Ozs7Ozs7Ozs7Ozs7OztBQ0hlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDRmU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVCZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZpRDtBQUNZO0FBQ1k7QUFDdEI7QUFDcEM7QUFDZixTQUFTLDJEQUFjLFNBQVMsaUVBQW9CLFlBQVksdUVBQTBCLFlBQVksNERBQWU7QUFDckg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOdUQ7QUFDSjtBQUNzQjtBQUNsQjtBQUN4QztBQUNmLFNBQVMsOERBQWlCLFNBQVMsNERBQWUsU0FBUyx1RUFBMEIsU0FBUyw4REFBaUI7QUFDL0c7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOcUQ7QUFDdEM7QUFDZjtBQUNBLG9DQUFvQyw2REFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDZEQUFnQjtBQUN0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL0FibHlSZWFjdEVmZmVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvYnJvd3Nlci9zdGF0aWMvYWJseS1jb21tb25qcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3M/YWMyOCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9vZmZlciBjb21wYW55IG5hbWUgYW5kIGxvZ29cclxuLy8gdGV4dGFyZWEgZm9yIGhpcyBvZmZlclxyXG4vLyBoaWRkZW4gYW5kIGFwcGVhclxyXG4vLyBzdGF0ZXMgZm9yIHJlbmRlcmluZyB0aGUgcGFnZVxyXG4vL1dlYlNvY2tldCBjb25uZWN0aW9uc1xyXG4vL0FibHlcclxuLy9hZGQgYW5kIElkXHJcbi8vYWRkIG1lc3NhZ2Ugc3RvcmFnZSBhbmQgcmV0cml2YWxcclxuLy9cclxuXHJcbmltcG9ydCBBYmx5IGZyb20gXCJhYmx5L3Byb21pc2VzXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuY29uc3QgYWJseSA9IG5ldyBBYmx5LlJlYWx0aW1lLlByb21pc2UoeyBhdXRoVXJsOiBcIi9hcGkvY3JlYXRlVG9rZW5SZXF1ZXN0XCIgfSk7XHJcblxyXG4vLyBjb25zb2xlLmxvZyhhYmx5KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGFubmVsKGNoYW5uZWxOYW1lLCBjYWxsYmFja09uTWVzc2FnZSkge1xyXG4gIGNvbnN0IGNoYW5uZWwgPSBhYmx5LmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSk7XHJcblxyXG4gIGNvbnN0IG9uTW91bnQgPSAoKSA9PiB7XHJcbiAgICBjaGFubmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XHJcbiAgICAgIGNhbGxiYWNrT25NZXNzYWdlKG1zZyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIGNvbnN0IG9uVW5Nb3VudCA9ICgpID0+IHtcclxuICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCB1c2VFZmZlY3RIb29rID0gKCkgPT4ge1xyXG4gICAgb25Nb3VudCgpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgb25Vbk1vdW50KCk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCh1c2VFZmZlY3RIb29rKTtcclxuXHJcbiAgcmV0dXJuIFtjaGFubmVsLCBhYmx5XTtcclxufVxyXG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDaGFubmVsIH0gZnJvbSBcIi4vQWJseVJlYWN0RWZmZWN0XCI7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4uL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3NcIjtcclxuXHJcbmNvbnN0IENoYXRDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgbGV0IGlucHV0Qm94ID0gbnVsbDtcclxuICBsZXQgbWVzc2FnZUVuZCA9IG51bGw7XHJcblxyXG4gIGNvbnN0IFttZXNzYWdlVGV4dCwgc2V0TWVzc2FnZVRleHRdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgW3JlY2VpdmVkTWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlKFtdKTtcclxuICBjb25zdCBtZXNzYWdlVGV4dElzRW1wdHkgPSBtZXNzYWdlVGV4dC50cmltKCkubGVuZ3RoID09PSAwO1xyXG5cclxuICBjb25zdCBbY2hhbm5lbCwgYWJseV0gPSB1c2VDaGFubmVsKFwiY2hhdC1kZW1vXCIsIChtZXNzYWdlKSA9PiB7XHJcbiAgICBjb25zdCBoaXN0b3J5ID0gcmVjZWl2ZWRNZXNzYWdlcy5zbGljZSgtMTk5KTtcclxuICAgIHNldE1lc3NhZ2VzKFsuLi5oaXN0b3J5LCBtZXNzYWdlXSk7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHNlbmRDaGF0TWVzc2FnZSA9IChtZXNzYWdlVGV4dCkgPT4ge1xyXG4gICAgY2hhbm5lbC5wdWJsaXNoKHsgbmFtZTogXCJjaGF0LW1lc3NhZ2VcIiwgZGF0YTogbWVzc2FnZVRleHQgfSk7XHJcbiAgICBzZXRNZXNzYWdlVGV4dChcIlwiKTtcclxuICAgIGlucHV0Qm94LmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlRm9ybVN1Ym1pc3Npb24gPSAoZXZlbnQpID0+IHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBzZW5kQ2hhdE1lc3NhZ2UobWVzc2FnZVRleHQpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUtleVByZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICBpZiAoZXZlbnQuY2hhckNvZGUgIT09IDEzIHx8IG1lc3NhZ2VUZXh0SXNFbXB0eSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzZW5kQ2hhdE1lc3NhZ2UobWVzc2FnZVRleHQpO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBtZXNzYWdlcyA9IHJlY2VpdmVkTWVzc2FnZXMubWFwKChtZXNzYWdlLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgYXV0aG9yID0gbWVzc2FnZS5jb25uZWN0aW9uSWQgPT09IGFibHkuY29ubmVjdGlvbi5pZCA/IFwibWVcIiA6IFwib3RoZXJcIjtcclxuXHJcbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY29uc3QgdGltZVN0YW1wID0gbWlsbGlzZWNvbmRzLnRvRGF0ZVN0cmluZygpO1xyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzSW50b1JlYWRhYmxlVGltZShtaWxsaXNlY29uZHMpIHtcclxuICAgIC8vICAgLy9HZXQgaG91cnMgZnJvbSBtaWxsaXNlY29uZHNcclxuICAgIC8vICAgdmFyIGhvdXJzID0gbWlsbGlzZWNvbmRzIC8gKDEwMDAgKiA2MCAqIDYwKTtcclxuICAgIC8vICAgdmFyIGFic29sdXRlSG91cnMgPSBNYXRoLmZsb29yKGhvdXJzKTtcclxuICAgIC8vICAgdmFyIGggPSBhYnNvbHV0ZUhvdXJzID4gOSA/IGFic29sdXRlSG91cnMgOiBcIjBcIiArIGFic29sdXRlSG91cnM7XHJcblxyXG4gICAgLy8gICAvL0dldCByZW1haW5kZXIgZnJvbSBob3VycyBhbmQgY29udmVydCB0byBtaW51dGVzXHJcbiAgICAvLyAgIHZhciBtaW51dGVzID0gKGhvdXJzIC0gYWJzb2x1dGVIb3VycykgKiA2MDtcclxuICAgIC8vICAgdmFyIGFic29sdXRlTWludXRlcyA9IE1hdGguZmxvb3IobWludXRlcyk7XHJcbiAgICAvLyAgIHZhciBtID0gYWJzb2x1dGVNaW51dGVzID4gOSA/IGFic29sdXRlTWludXRlcyA6IFwiMFwiICsgYWJzb2x1dGVNaW51dGVzO1xyXG5cclxuICAgIC8vICAgLy9HZXQgcmVtYWluZGVyIGZyb20gbWludXRlcyBhbmQgY29udmVydCB0byBzZWNvbmRzXHJcbiAgICAvLyAgIHZhciBzZWNvbmRzID0gKG1pbnV0ZXMgLSBhYnNvbHV0ZU1pbnV0ZXMpICogNjA7XHJcbiAgICAvLyAgIHZhciBhYnNvbHV0ZVNlY29uZHMgPSBNYXRoLmZsb29yKHNlY29uZHMpO1xyXG4gICAgLy8gICB2YXIgcyA9IGFic29sdXRlU2Vjb25kcyA+IDkgPyBhYnNvbHV0ZVNlY29uZHMgOiBcIjBcIiArIGFic29sdXRlU2Vjb25kcztcclxuXHJcbiAgICAvLyAgIHJldHVybiBoICsgXCI6XCIgKyBtICsgXCI6XCIgKyBzO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHZhciB0aW1lID0gcGFyc2VNaWxsaXNlY29uZHNJbnRvUmVhZGFibGVUaW1lKG1pbGxpc2Vjb25kcyk7XHJcblxyXG4gICAgLy8gYWxlcnQodGltZSk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyh0aW1lKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8c3BhblxyXG4gICAgICAgIGtleT17aW5kZXh9XHJcbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubWVzc2FnZX1cclxuICAgICAgICAvLyB0aW1lPXtuZXcgRGF0ZSgpLnRvU3RyaW5nKCl9XHJcbiAgICAgICAgZGF0YS1hdXRob3I9e2F1dGhvcn1cclxuICAgICAgPlxyXG4gICAgICAgIHttZXNzYWdlLmRhdGF9XHJcbiAgICAgIDwvc3Bhbj5cclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBtZXNzYWdlRW5kLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3VyOiBcInNtb290aFwiIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jaGF0SG9sZGVyfT5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jaGF0VGV4dH0+XHJcbiAgICAgICAge21lc3NhZ2VzfVxyXG4gICAgICAgIHtuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpfVxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIHJlZj17KGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgbWVzc2FnZUVuZCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICB9fVxyXG4gICAgICAgID48L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVGb3JtU3VibWlzc2lvbn0gY2xhc3NOYW1lPXtzdHlsZXMuZm9ybX0+XHJcbiAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICByZWY9eyhlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlucHV0Qm94ID0gZWxlbWVudDtcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgICB2YWx1ZT17bWVzc2FnZVRleHR9XHJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgYSBtZXNzYWdlLi4uXCJcclxuICAgICAgICAgIC8vIHRpbWU9e25ldyBEYXRlKCkudG9TdHJpbmcoKX1cclxuICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0TWVzc2FnZVRleHQoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgb25LZXlQcmVzcz17aGFuZGxlS2V5UHJlc3N9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy50ZXh0YXJlYX1cclxuICAgICAgICA+PC90ZXh0YXJlYT5cclxuICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICB0eXBlPVwic3VibWl0XCJcclxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbn1cclxuICAgICAgICAgIGRpc2FibGVkPXttZXNzYWdlVGV4dElzRW1wdHl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgU2VuZFxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICA8L2Zvcm0+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hhdENvbXBvbmVudDtcclxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAyMSwgQWJseVxuICogXG4gKiBBYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4yLjEzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG4gKiBcbiAqIEFibHkgUmVhbHRpbWUgTWVzc2FnaW5nXG4gKiBodHRwczovL3d3dy5hYmx5LmNvbVxuICogXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2VuY2UgdjIuMFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJBYmx5XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkFibHlcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxudmFyIExvZ2dlciA9IChmdW5jdGlvbigpIHtcblx0dmFyIGNvbnNvbGVMb2dnZXIsIGVycm9yTG9nZ2VyO1xuXG5cdC8qIENhbid0IGp1c3QgY2hlY2sgZm9yIGNvbnNvbGUgJiYgY29uc29sZS5sb2c7IGZhaWxzIGluIElFIDw9OSAqL1xuXHRpZigodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykgLyogbm9kZSAqLyB8fFxuXHRcdCAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUubG9nICYmICh0eXBlb2YgZ2xvYmFsLmNvbnNvbGUubG9nLmFwcGx5ID09PSAnZnVuY3Rpb24nKSkgLyogc2Vuc2libGUgYnJvd3NlcnMgKi8pIHtcblx0XHRjb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7IH07XG5cdFx0ZXJyb3JMb2dnZXIgPSBjb25zb2xlLndhcm4gPyBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7IH0gOiBjb25zb2xlTG9nZ2VyO1xuXHR9IGVsc2UgaWYoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUubG9nKSB7XG5cdFx0LyogSUUgPD0gOSB3aXRoIHRoZSBjb25zb2xlIG9wZW4gLS0gY29uc29sZS5sb2cgZG9lcyBub3Rcblx0XHQgKiBpbmhlcml0IGZyb20gRnVuY3Rpb24sIHNvIGhhcyBubyBhcHBseSBtZXRob2QgKi9cblx0XHRjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbigpIHsgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7IH07XG5cdH0gZWxzZSB7XG5cdFx0LyogSUUgPD0gOSB3aGVuIGRldiB0b29scyBhcmUgY2xvc2VkIC0gd2luZG93LmNvbnNvbGUgbm90IGV2ZW4gZGVmaW5lZCAqL1xuXHRcdGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uKCkge307XG5cdH1cblxuXHRmdW5jdGlvbiBwYWQoc3RyLCB0aHJlZSkge1xuXHRcdHJldHVybiAoJzAwMCcgKyBzdHIpLnNsaWNlKC0yLSh0aHJlZSB8fCAwKSk7XG5cdH1cblxuXHR2YXIgTE9HX05PTkUgID0gMCxcblx0TE9HX0VSUk9SID0gMSxcblx0TE9HX01BSk9SID0gMixcblx0TE9HX01JTk9SID0gMyxcblx0TE9HX01JQ1JPID0gNDtcblxuXHR2YXIgTE9HX0RFRkFVTFQgPSBMT0dfRVJST1IsXG5cdExPR19ERUJVRyAgID0gTE9HX01JQ1JPO1xuXG5cdHZhciBsb2dMZXZlbCA9IExPR19ERUZBVUxUO1xuXG5cdGZ1bmN0aW9uIGdldEhhbmRsZXIobG9nZ2VyKSB7XG5cdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nVGltZXN0YW1wcyA/XG5cdFx0XHRmdW5jdGlvbihtc2cpIHtcblx0XHRcdFx0dmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRsb2dnZXIocGFkKHRpbWUuZ2V0SG91cnMoKSkgKyAnOicgKyBwYWQodGltZS5nZXRNaW51dGVzKCkpICsgJzonICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArICcuJyArIHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCB0cnVlKSArICcgJyArIG1zZyk7XG5cdFx0XHR9IDogbG9nZ2VyO1xuXHR9XG5cblx0dmFyIGxvZ0hhbmRsZXIgPSBnZXRIYW5kbGVyKGNvbnNvbGVMb2dnZXIpLFxuXHRcdGxvZ0Vycm9ySGFuZGxlciA9IGdldEhhbmRsZXIoZXJyb3JMb2dnZXIpO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBMb2dnZXIoYXJncykge31cblxuXHQvKiBwdWJsaWMgY29uc3RhbnRzICovXG5cdExvZ2dlci5MT0dfTk9ORSAgICA9IExPR19OT05FLFxuXHRMb2dnZXIuTE9HX0VSUk9SICAgPSBMT0dfRVJST1IsXG5cdExvZ2dlci5MT0dfTUFKT1IgICA9IExPR19NQUpPUixcblx0TG9nZ2VyLkxPR19NSU5PUiAgID0gTE9HX01JTk9SLFxuXHRMb2dnZXIuTE9HX01JQ1JPICAgPSBMT0dfTUlDUk87XG5cblx0TG9nZ2VyLkxPR19ERUZBVUxUID0gTE9HX0RFRkFVTFQsXG5cdExvZ2dlci5MT0dfREVCVUcgICA9IExPR19ERUJVRztcblxuXHQvKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuXHRMb2dnZXIubG9nQWN0aW9uID0gZnVuY3Rpb24obGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuXHRcdGlmIChMb2dnZXIuc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0KGxldmVsID09PSBMT0dfRVJST1IgPyBsb2dFcnJvckhhbmRsZXIgOiBsb2dIYW5kbGVyKSgnQWJseTogJyArIGFjdGlvbiArICc6ICcgKyBtZXNzYWdlKTtcblx0XHR9XG5cdH07XG5cblx0TG9nZ2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihvcmlnaW5hbCwgcmVwbGFjZW1lbnQpIHtcblx0XHRMb2dnZXIuZGVwcmVjYXRlZFdpdGhNc2cob3JpZ2luYWwsIFwiUGxlYXNlIHVzZSAnXCIgKyByZXBsYWNlbWVudCArIFwiJyBpbnN0ZWFkLlwiKTtcblx0fVxuXG5cdExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyA9IGZ1bmN0aW9uKGZ1bmNOYW1lLCBtc2cpIHtcblx0XHRpZiAoTG9nZ2VyLnNob3VsZExvZyhMT0dfRVJST1IpKSB7XG5cdFx0XHRsb2dFcnJvckhhbmRsZXIoXCJBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJ1wiICsgZnVuY05hbWUgKyBcIicgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGZyb20gYSBmdXR1cmUgdmVyc2lvbi4gXCIgKyBtc2cpO1xuXHRcdH1cblx0fVxuXG5cdC8qIFdoZXJlIGEgbG9nZ2luZyBvcGVyYXRpb24gaXMgZXhwZW5zaXZlLCBzdWNoIGFzIHNlcmlhbGlzYXRpb24gb2YgZGF0YSwgdXNlIHNob3VsZExvZyB3aWxsIHByZXZlbnRcblx0ICAgdGhlIG9iamVjdCBiZWluZyBzZXJpYWxpc2VkIGlmIHRoZSBsb2cgbGV2ZWwgd2lsbCBub3Qgb3V0cHV0IHRoZSBtZXNzYWdlICovXG5cdExvZ2dlci5zaG91bGRMb2cgPSBmdW5jdGlvbihsZXZlbCkge1xuXHRcdHJldHVybiBsZXZlbCA8PSBsb2dMZXZlbDtcblx0fTtcblxuXHRMb2dnZXIuc2V0TG9nID0gZnVuY3Rpb24obGV2ZWwsIGhhbmRsZXIpIHtcblx0XHRpZihsZXZlbCAhPT0gdW5kZWZpbmVkKSBsb2dMZXZlbCA9IGxldmVsO1xuXHRcdGlmKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkgbG9nSGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG5cdH07XG5cblx0cmV0dXJuIExvZ2dlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTG9nZ2VyKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXG5cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFV0aWxzID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbXNncGFjayA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubXNncGFjaztcblxuXHRmdW5jdGlvbiBVdGlscygpIHt9XG5cblx0ZnVuY3Rpb24gcmFuZG9tUG9zbihhcnJPclN0cikge1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xuXHR9XG5cblx0Lypcblx0ICogQWRkIGEgc2V0IG9mIHByb3BlcnRpZXMgdG8gYSB0YXJnZXQgb2JqZWN0XG5cdCAqIHRhcmdldDogdGhlIHRhcmdldCBvYmplY3Rcblx0ICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuXHQgKiAgICAgICAgIGFkZGVkLCBieSByZWZlcmVuY2Ugb25seVxuXHQgKi9cblx0VXRpbHMubWl4aW4gPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYoIXNvdXJjZSkgeyBicmVhazsgfVxuXHRcdFx0Zm9yKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdGlmKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG5cdCAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcblx0ICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcblx0ICovXG5cdFV0aWxzLmNvcHkgPSBmdW5jdGlvbihzcmMpIHtcblx0XHRyZXR1cm4gVXRpbHMubWl4aW4oe30sIHNyYyk7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gb2JqZWN0IGlzXG5cdCAqIGFuIGFycmF5LlxuXHQgKi9cblx0VXRpbHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2IpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cdC8qXG5cdCAqIEVuc3VyZXMgdGhhdCBhbiBBcnJheSBvYmplY3QgaXMgYWx3YXlzIHJldHVybmVkXG5cdCAqIHJldHVybmluZyB0aGUgb3JpZ2luYWwgQXJyYXkgb2Ygb2JqIGlzIGFuIEFycmF5XG5cdCAqIGVsc2Ugd3JhcHBpbmcgdGhlIG9iaiBpbiBhIHNpbmdsZSBlbGVtZW50IEFycmF5XG5cdCAqL1xuXHRVdGlscy5lbnN1cmVBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmKFV0aWxzLmlzRW1wdHlBcmcob2JqKSkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRpZihVdGlscy5pc0FycmF5KG9iaikpIHtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXHRcdHJldHVybiBbb2JqXTtcblx0fVxuXG5cdC8qIC4uLk9yIGFuIE9iamVjdCAoaW4gdGhlIG5hcnJvdyBzZW5zZSkgKi9cblx0VXRpbHMuaXNPYmplY3QgPSBmdW5jdGlvbihvYikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgY29udGFpbnNcblx0ICogYW55IGVudW1lcmFibGUgcHJvcGVydGllcy5cblx0ICogb2I6IHRoZSBvYmplY3Rcblx0ICovXG5cdFV0aWxzLmlzRW1wdHkgPSBmdW5jdGlvbihvYikge1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRVdGlscy5pc09ubHlQcm9wSW4gPSBmdW5jdGlvbihvYiwgcHJvcGVydHkpIHtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKHByb3AgIT09IHByb3BlcnR5KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIGFyZ3VtZW50IHRvIGFuIG92ZXJsb2FkZWQgZnVuY3Rpb24gaXNcblx0ICogdW5kZWZpbmVkIChtaXNzaW5nKSBvciBudWxsLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiBjb25zdHJ1Y3RpbmcgZnVuY3Rpb25zIHN1Y2ggYXMgKFdlYklETCB0ZXJtaW5vbG9neSk6XG5cdCAqICAgb2ZmKFtUcmVhdFVuZGVmaW5lZEFzPU51bGxdIERPTVN0cmluZz8gZXZlbnQpXG5cdCAqIGFzIHlvdSBjYW4gdGhlbiBjb25maXJtIHRoZSBhcmd1bWVudCB1c2luZzpcblx0ICogICBVdGlscy5pc0VtcHR5QXJnKGV2ZW50KVxuXHQgKi9cblxuXHRVdGlscy5pc0VtcHR5QXJnID0gZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qXG5cdCAqIFBlcmZvcm0gYSBzaW1wbGUgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QuXG5cdCAqIFJlc3VsdCBpcyBhbiBvYmplY3QgaXJyZXNwZWN0aXZlIG9mIHdoZXRoZXJcblx0ICogdGhlIGlucHV0IGlzIGFuIG9iamVjdCBvciBhcnJheS4gQWxsXG5cdCAqIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29waWVkLlxuXHQgKiBvYjogdGhlIG9iamVjdFxuXHQgKi9cblx0VXRpbHMuc2hhbGxvd0Nsb25lID0gZnVuY3Rpb24ob2IpIHtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IE9iamVjdCgpO1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcblx0XHRcdHJlc3VsdFtwcm9wXSA9IG9iW3Byb3BdO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Lypcblx0ICogQ2xvbmUgYW4gb2JqZWN0IGJ5IGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoZVxuXHQgKiBnaXZlbiBvYmplY3QgYXMgaXRzIHByb3RvdHlwZS4gT3B0aW9uYWxseVxuXHQgKiBhIHNldCBvZiBhZGRpdGlvbmFsIG93biBwcm9wZXJ0aWVzIGNhbiBiZVxuXHQgKiBzdXBwbGllZCB0byBiZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjbG9uZS5cblx0ICogb2I6ICAgICAgICAgICAgdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcblx0ICogb3duUHJvcGVydGllczogb3B0aW9uYWwgb2JqZWN0IHdpdGggYWRkaXRpb25hbFxuXHQgKiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIHRvIGFkZFxuXHQgKi9cblx0VXRpbHMucHJvdG90eXBpY2FsQ2xvbmUgPSBmdW5jdGlvbihvYiwgb3duUHJvcGVydGllcykge1xuXHRcdGZ1bmN0aW9uIEYoKSB7fVxuXHRcdEYucHJvdG90eXBlID0gb2I7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBGKCk7XG5cdFx0aWYob3duUHJvcGVydGllcylcblx0XHRcdFV0aWxzLm1peGluKHJlc3VsdCwgb3duUHJvcGVydGllcyk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBEZWNsYXJlIGEgY29uc3RydWN0b3IgdG8gcmVwcmVzZW50IGEgc3ViY2xhc3Ncblx0ICogb2YgYW5vdGhlciBjb25zdHJ1Y3RvclxuXHQgKiBJZiBwbGF0Zm9ybSBoYXMgYSBidWlsdC1pbiB2ZXJzaW9uIHdlIHVzZSB0aGF0IGZyb20gUGxhdGZvcm0sIGVsc2Ugd2Vcblx0ICogZGVmaW5lIGhlcmUgKHNvIGNhbiBtYWtlIHVzZSBvZiBvdGhlciBVdGlscyBmbnMpXG5cdCAqIFNlZSBub2RlLmpzIHV0aWwuaW5oZXJpdHNcblx0ICovXG5cdFV0aWxzLmluaGVyaXRzID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyB8fCBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcblx0XHRjdG9yLnN1cGVyXyA9IHN1cGVyQ3Rvcjtcblx0XHRjdG9yLnByb3RvdHlwZSA9IFV0aWxzLnByb3RvdHlwaWNhbENsb25lKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IGN0b3IgfSk7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgYW4gZW51bWVyYWJsZVxuXHQgKiBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBlcXVhbHMgYSBnaXZlbiB2YWx1ZS5cblx0ICogb2I6ICB0aGUgb2JqZWN0XG5cdCAqIHZhbDogdGhlIHZhbHVlIHRvIGZpbmRcblx0ICovXG5cdFV0aWxzLmNvbnRhaW5zVmFsdWUgPSBmdW5jdGlvbihvYiwgdmFsKSB7XG5cdFx0Zm9yKHZhciBpIGluIG9iKSB7XG5cdFx0XHRpZihvYltpXSA9PSB2YWwpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0VXRpbHMuaW50ZXJzZWN0ID0gZnVuY3Rpb24oYXJyLCBvYikgeyByZXR1cm4gVXRpbHMuaXNBcnJheShvYikgPyBVdGlscy5hcnJJbnRlcnNlY3QoYXJyLCBvYikgOiBVdGlscy5hcnJJbnRlcnNlY3RPYihhcnIsIG9iKTsgfTtcblxuXHRVdGlscy5hcnJJbnRlcnNlY3QgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gYXJyMVtpXTtcblx0XHRcdGlmKFV0aWxzLmFyckluZGV4T2YoYXJyMiwgbWVtYmVyKSAhPSAtMSlcblx0XHRcdFx0cmVzdWx0LnB1c2gobWVtYmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5hcnJJbnRlcnNlY3RPYiA9IGZ1bmN0aW9uKGFyciwgb2IpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1lbWJlciA9IGFycltpXTtcblx0XHRcdGlmKG1lbWJlciBpbiBvYilcblx0XHRcdFx0cmVzdWx0LnB1c2gobWVtYmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5hcnJTdWJ0cmFjdCA9IGZ1bmN0aW9uKGFycjEsIGFycjIpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlbGVtZW50ID0gYXJyMVtpXTtcblx0XHRcdGlmKFV0aWxzLmFyckluZGV4T2YoYXJyMiwgZWxlbWVudCkgPT0gLTEpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmFyckluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuXHRcdD8gZnVuY3Rpb24oYXJyLCBlbGVtLCBmcm9tSW5kZXgpIHtcblx0XHRcdHJldHVybiBhcnIuaW5kZXhPZihlbGVtLCAgZnJvbUluZGV4KTtcblx0XHR9XG5cdFx0OiBmdW5jdGlvbihhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuXHRcdFx0ZnJvbUluZGV4ID0gZnJvbUluZGV4IHx8IDA7XG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcig7ZnJvbUluZGV4IDwgbGVuOyBmcm9tSW5kZXgrKykge1xuXHRcdFx0XHRpZihhcnJbZnJvbUluZGV4XSA9PT0gZWxlbSkge1xuXHRcdFx0XHRcdHJldHVybiBmcm9tSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXG5cdFV0aWxzLmFyckluID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJySW5kZXhPZihhcnIsIHZhbCkgIT09IC0xO1xuXHR9O1xuXG5cdFV0aWxzLmFyckRlbGV0ZVZhbHVlID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHR2YXIgaWR4ID0gVXRpbHMuYXJySW5kZXhPZihhcnIsIHZhbCk7XG5cdFx0dmFyIHJlcyA9IChpZHggIT0gLTEpO1xuXHRcdGlmKHJlcylcblx0XHRcdGFyci5zcGxpY2UoaWR4LCAxKTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xuXG5cdFV0aWxzLmFycldpdGhvdXRWYWx1ZSA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0dmFyIG5ld0FyciA9IGFyci5zbGljZSgpO1xuXHRcdFV0aWxzLmFyckRlbGV0ZVZhbHVlKG5ld0FyciwgdmFsKTtcblx0XHRyZXR1cm4gbmV3QXJyO1xuXHR9O1xuXG5cdC8qXG5cdCAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUga2V5cyBvZiB0aGUgZW51bWVyYWJsZVxuXHQgKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcblx0ICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXG5cdCAqIG9iOiAgICAgIHRoZSBvYmplY3Rcblx0ICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcblx0ICovXG5cdFV0aWxzLmtleXNBcnJheSA9IGZ1bmN0aW9uKG9iLCBvd25Pbmx5KSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYikge1xuXHRcdFx0aWYob3duT25seSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpIGNvbnRpbnVlO1xuXHRcdFx0cmVzdWx0LnB1c2gocHJvcCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Lypcblx0ICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIGVudW1lcmFibGVcblx0ICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG5cdCAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuXHQgKiBvYjogICAgICB0aGUgb2JqZWN0XG5cdCAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG5cdCAqL1xuXHRVdGlscy52YWx1ZXNBcnJheSA9IGZ1bmN0aW9uKG9iLCBvd25Pbmx5KSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYikge1xuXHRcdFx0aWYob3duT25seSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpIGNvbnRpbnVlO1xuXHRcdFx0cmVzdWx0LnB1c2gob2JbcHJvcF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BzID0gZnVuY3Rpb24ob2IsIGZuKSB7XG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBvYikge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApICYmIG9iW3Byb3BdKSB7XG5cdFx0XHRcdGZuKHByb3ApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRVdGlscy5hcnJGb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2ggP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdGFyci5mb3JFYWNoKGZuKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRmbihhcnJbaV0sIGksIGFycik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHQvKiBVc2VmdWwgd2hlbiB0aGUgZnVuY3Rpb24gbWF5IG11dGF0ZSB0aGUgYXJyYXkgKi9cblx0VXRpbHMuc2FmZUFyckZvckVhY2ggPSBmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyckZvckVhY2goYXJyLnNsaWNlKCksIGZuKTtcblx0fTtcblxuXHRVdGlscy5hcnJNYXAgPSBBcnJheS5wcm90b3R5cGUubWFwID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLm1hcChmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbilcdHtcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHQucHVzaChmbihhcnJbaV0sIGksIGFycikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFV0aWxzLmFyckZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHJldHVybiBhcnIuZmlsdGVyKGZuKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnIsIGZuKVx0e1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmKGZuKGFycltpXSkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0VXRpbHMuYXJyRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnkgP1xuXHRcdGZ1bmN0aW9uKGFyciwgZm4pIHtcblx0XHRcdHJldHVybiBhcnIuZXZlcnkoZm4pO1xuXHRcdH0gOiBmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZighZm4oYXJyW2ldLCBpLCBhcnIpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRVdGlscy5hbGxTYW1lID0gZnVuY3Rpb24oYXJyLCBwcm9wKSB7XG5cdFx0aWYoYXJyLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciBmaXJzdCA9IGFyclswXVtwcm9wXTtcblx0XHRyZXR1cm4gVXRpbHMuYXJyRXZlcnkoYXJyLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbVtwcm9wXSA9PT0gZmlyc3Q7XG5cdFx0fSk7XG5cdH07XG5cblx0VXRpbHMubmV4dFRpY2sgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrO1xuXG5cdHZhciBjb250ZW50VHlwZXMgPSB7XG5cdFx0anNvbjogICAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0anNvbnA6ICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG5cdFx0eG1sOiAgICAnYXBwbGljYXRpb24veG1sJyxcblx0XHRodG1sOiAgICd0ZXh0L2h0bWwnLFxuXHRcdG1zZ3BhY2s6ICdhcHBsaWNhdGlvbi94LW1zZ3BhY2snXG5cdH07XG5cblx0VXRpbHMuZGVmYXVsdEdldEhlYWRlcnMgPSBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHR2YXIgYWNjZXB0ID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCAnanNvbiddO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhY2NlcHQ6IGFjY2VwdCxcblx0XHRcdCdYLUFibHktVmVyc2lvbic6IF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFwaVZlcnNpb24sXG5cdFx0XHQnQWJseS1BZ2VudCc6IF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50XG5cdFx0fTtcblx0fTtcblxuXHRVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMgPSBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHR2YXIgYWNjZXB0LCBjb250ZW50VHlwZTtcblx0XHRhY2NlcHQgPSBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlc1tmb3JtYXQgfHwgJ2pzb24nXTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRhY2NlcHQ6IGFjY2VwdCxcblx0XHRcdCdjb250ZW50LXR5cGUnOiBjb250ZW50VHlwZSxcblx0XHRcdCdYLUFibHktVmVyc2lvbic6IF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFwaVZlcnNpb24sXG5cdFx0XHQnQWJseS1BZ2VudCc6IF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50XG5cdFx0fTtcblx0fTtcblxuXHRVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIGFyci5zcGxpY2UocmFuZG9tUG9zbihhcnIpLCAxKVswXTtcblx0fTtcblxuXHRVdGlscy50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIHBhcnRzID0gW107XG5cdFx0aWYocGFyYW1zKSB7XG5cdFx0XHRmb3IodmFyIGtleSBpbiBwYXJhbXMpXG5cdFx0XHRcdHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmxlbmd0aCA/ICc/JyArIHBhcnRzLmpvaW4oJyYnKSA6ICcnO1xuXHR9O1xuXG5cdFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihxdWVyeSkge1xuXHRcdHZhciBtYXRjaCxcblx0XHRcdHNlYXJjaCA9IC8oW14/Jj1dKyk9PyhbXiZdKikvZyxcblx0XHRcdHJlc3VsdCA9IHt9O1xuXG5cdFx0d2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuXHRcdFx0cmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcblxuIFx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHRcdC8qIElFIDggKi9cblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH07XG5cblx0VXRpbHMuaW5zcGVjdCA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdDtcblxuXHRVdGlscy5pc0Vycm9ySW5mbyA9IGZ1bmN0aW9uKGVycikge1xuXHRcdHJldHVybiBlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3JJbmZvJ1xuXHR9O1xuXG5cdFV0aWxzLmluc3BlY3RFcnJvciA9IGZ1bmN0aW9uKHgpIHtcblx0XHQvKiByZWR1bmRhbnQsIGJ1dCBub2RlIHZtY29udGV4dCBpc3N1ZSBtYWtlcyBpbnN0YW5jZW9mIHVucmVsaWFibGUsIGFuZFxuXHRcdCAqIGNhbid0IHVzZSBqdXN0IGNvbnN0cnVjdG9yIHRlc3QgYXMgY291bGQgYmUgYSBUeXBlRXJyb3IgY29uc3RydWN0b3IgZXRjLiAqL1xuXHRcdHJldHVybiAoeCAmJiAoVXRpbHMuaXNFcnJvckluZm8oeCkgfHxcblx0XHRcdHguY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3InIHx8XG5cdFx0XHR4IGluc3RhbmNlb2YgRXJyb3IpKSA/XG5cdFx0XHR4LnRvU3RyaW5nKCkgOlxuXHRcdFx0VXRpbHMuaW5zcGVjdCh4KTtcblx0fTtcblxuXHRVdGlscy5pbnNwZWN0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcblx0XHRpZihwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0XHRyZXR1cm4gYm9keS50b1N0cmluZygpO1xuXHRcdH0gZWxzZSBpZih0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBib2R5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KGJvZHkpO1xuXHRcdH1cblx0fTtcblxuXHQvKiBEYXRhIGlzIGFzc3VtZWQgdG8gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgYnVmZmVyLiAqL1xuXHRVdGlscy5kYXRhU2l6ZUJ5dGVzID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJ5dGVMZW5ndGgoZGF0YSk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5nQnl0ZVNpemUoZGF0YSk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiBcIiArICh0eXBlb2YgZGF0YSkpO1xuXHR9O1xuXG5cdFV0aWxzLmNoZWFwUmFuZFN0ciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO1xuXHR9O1xuXG5cdC8qIFRha2VzIHBhcmFtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBvZiBlbnRyb3B5IHRoZSBzdHJpbmcgbXVzdFxuXHQgKiBpbmNsdWRlLCBub3QgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLiBTdHJpbmcgbGVuZ3RoIHByb2R1Y2VkIGlzIG5vdFxuXHQgKiBndWFyYW50ZWVkLiAqL1xuXHRVdGlscy5yYW5kb21TdHJpbmcgPSAocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSA/XG5cdFx0ZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuXHRcdFx0cGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUodUludEFycik7XG5cdFx0fSA6IGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHQvKiBPbGQgYnJvd3NlcjsgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tLiBDb3VsZCBqdXN0IHVzZSBhXG5cdFx0XHQgKiBDcnlwdG9KUyB2ZXJzaW9uIG9mIHRoZSBhYm92ZSwgYnV0IHdhbnQgdGhpcyB0byBzdGlsbCB3b3JrIGluIG5vY3J5cHRvXG5cdFx0XHQgKiB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeSAqL1xuXHRcdFx0dmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NENoYXJTZXQ7XG5cdFx0XHQvKiBiYXNlNjQgaGFzIDMzJSBvdmVyaGVhZDsgcm91bmQgbGVuZ3RoIHVwICovXG5cdFx0XHR2YXIgbGVuZ3RoID0gTWF0aC5yb3VuZChudW1CeXRlcyAqIDQvMyk7XG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRVdGlscy5yYW5kb21IZXhTdHJpbmcgPSAocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSA/XG5cdFx0ZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuXHRcdFx0cGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5oZXhFbmNvZGUodUludEFycik7XG5cdFx0fSA6IGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHR2YXIgY2hhcnNldCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaGV4Q2hhclNldDtcblx0XHRcdHZhciBsZW5ndGggPSBudW1CeXRlcyAqIDI7XG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHQvKiBQaWNrIG4gZWxlbWVudHMgYXQgcmFuZG9tIHdpdGhvdXQgcmVwbGFjZW1lbnQgZnJvbSBhbiBhcnJheSAqL1xuXHRVdGlscy5hcnJDaG9vc2VOID0gZnVuY3Rpb24oYXJyLCBuKSB7XG5cdFx0dmFyIG51bUl0ZW1zID0gTWF0aC5taW4obiwgYXJyLmxlbmd0aCksXG5cdFx0XHRtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksXG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2goVXRpbHMuYXJyUG9wUmFuZG9tRWxlbWVudChtdXRhYmxlQXJyKSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMudHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9IDogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXHR9O1xuXG5cdFV0aWxzLnByb21pc2lmeSA9IGZ1bmN0aW9uKG9iLCBmbk5hbWUsIGFyZ3MpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRvYltmbk5hbWVdLmFwcGx5KG9iLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5jb25jYXQoZnVuY3Rpb24oZXJyLCByZXMpIHtcblx0XHRcdFx0ZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG5cdFx0XHR9KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0VXRpbHMuZGVjb2RlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xuXHRcdHJldHVybiAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcblx0fTtcblxuXHRVdGlscy5lbmNvZGVCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIChmb3JtYXQgPT0gJ21zZ3BhY2snKSA/IG1zZ3BhY2suZW5jb2RlKGJvZHksIHRydWUpIDogSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH07XG5cblx0VXRpbHMuYWxsVG9Mb3dlckNhc2UgPSBmdW5jdGlvbihhcnIpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJyTWFwKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFV0aWxzLmFsbFRvVXBwZXJDYXNlID0gZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyck1hcChhcnIsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gVXRpbHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFV0aWxzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxudmFyIEVycm9ySW5mbyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0XHR0aGlzLmNhdXNlID0gY2F1c2U7XG5cdFx0dGhpcy5ocmVmID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0RXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdFx0aWYodGhpcy5tZXNzYWdlKSByZXN1bHQgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0XHRpZih0aGlzLnN0YXR1c0NvZGUpIHJlc3VsdCArPSAnOyBzdGF0dXNDb2RlPScgKyB0aGlzLnN0YXR1c0NvZGU7XG5cdFx0aWYodGhpcy5jb2RlKSByZXN1bHQgKz0gJzsgY29kZT0nICsgdGhpcy5jb2RlO1xuXHRcdGlmKHRoaXMuY2F1c2UpIHJlc3VsdCArPSAnOyBjYXVzZT0nICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IodGhpcy5jYXVzZSk7XG5cdFx0aWYodGhpcy5ocmVmICYmICEodGhpcy5tZXNzYWdlICYmIHRoaXMubWVzc2FnZS5pbmRleE9mKCdoZWxwLmFibHkuaW8nKSA+IC0xKSkgcmVzdWx0ICs9ICc7IHNlZSAnICsgdGhpcy5ocmVmICsgJyAnO1xuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRFcnJvckluZm8uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciByZXN1bHQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBFcnJvckluZm8oKSwgdmFsdWVzKTtcblx0XHRpZiAodmFsdWVzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdC8qIEVycm9yLm1lc3NhZ2UgaXMgbm90IGVudW1lcmFibGUsIHNvIG1peGluIGxvc2VzIHRoZSBtZXNzYWdlICovXG5cdFx0XHRyZXN1bHQubWVzc2FnZSA9IHZhbHVlcy5tZXNzYWdlO1xuXHRcdH1cblx0XHRpZihyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcblx0XHRcdHJlc3VsdC5ocmVmID0gJ2h0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLycgKyByZXN1bHQuY29kZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyZXR1cm4gRXJyb3JJbmZvO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFcnJvckluZm8pO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIHNldEltbWVkaWF0ZSkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGliX3V0aWxfbXNncGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblxuaWYodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykge1xuXHRjb25zb2xlLmxvZyhcIldhcm5pbmc6IHRoaXMgZGlzdHJpYnV0aW9uIG9mIEFibHkgaXMgaW50ZW5kZWQgZm9yIGJyb3dzZXJzLiBPbiBub2RlanMsIHBsZWFzZSB1c2UgdGhlICdhYmx5JyBwYWNrYWdlIG9uIG5wbVwiKTtcbn1cblxuZnVuY3Rpb24gYWxsb3dDb21ldCgpIHtcblx0LyogeGhyIHJlcXVlc3RzIGZyb20gbG9jYWwgZmlsZXMgYXJlIHVucmVsaWFibGUgaW4gc29tZSBicm93c2Vycywgc3VjaCBhcyBDaHJvbWUgNjUgYW5kIGhpZ2hlciAtLSBzZWUgZWdcblx0ICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDkyNTY0MjkvY2hyb21lLTY1LXVuYWJsZS10by1tYWtlLXBvc3QtcmVxdWVzdHMtZnJvbS1sb2NhbC1maWxlcy10by1mbGFza1xuXHQgKiBTbyBpZiB3ZWJzb2NrZXRzIGFyZSBzdXBwb3J0ZWQsIHRoZW4ganVzdCBmb3JnZXQgYWJvdXQgY29tZXQgdHJhbnNwb3J0cyBhbmQgdXNlIHRoYXQgKi9cblx0dmFyIGxvYyA9IGdsb2JhbC5sb2NhdGlvbjtcblx0cmV0dXJuICghZ2xvYmFsLldlYlNvY2tldCB8fCAhbG9jIHx8ICFsb2Mub3JpZ2luIHx8IGxvYy5vcmlnaW4uaW5kZXhPZihcImh0dHBcIikgPiAtMSk7XG59XG5cbnZhciB1c2VyQWdlbnQgPSBnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCk7XG52YXIgY3VycmVudFVybCA9IGdsb2JhbC5sb2NhdGlvbiAmJiBnbG9iYWwubG9jYXRpb24uaHJlZjtcblxudmFyIFBsYXRmb3JtID0ge1xuICAgICAgICBhZ2VudDogJ2Jyb3dzZXInLFxuXHRsb2dUaW1lc3RhbXBzOiB0cnVlLFxuXHR1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcblx0Y3VycmVudFVybDogY3VycmVudFVybCxcblx0bm9VcGdyYWRlOiB1c2VyQWdlbnQgJiYgdXNlckFnZW50Lm1hdGNoKC9NU0lFXFxzOFxcLjAvKSxcblx0YmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcblx0V2ViU29ja2V0OiBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQsXG5cdHhoclN1cHBvcnRlZDogZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuXHRqc29ucFN1cHBvcnRlZDogdHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcsXG5cdGFsbG93Q29tZXQ6IGFsbG93Q29tZXQoKSxcblx0c3RyZWFtaW5nU3VwcG9ydGVkOiB0cnVlLFxuXHR1c2VQcm90b2NvbEhlYXJ0YmVhdHM6IHRydWUsXG5cdGNyZWF0ZUhtYWM6IG51bGwsXG5cdG1zZ3BhY2s6IF9saWJfdXRpbF9tc2dwYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0sXG5cdHN1cHBvcnRzQmluYXJ5OiAhIWdsb2JhbC5UZXh0RGVjb2Rlcixcblx0cHJlZmVyQmluYXJ5OiBmYWxzZSxcblx0QXJyYXlCdWZmZXI6IGdsb2JhbC5BcnJheUJ1ZmZlcixcblx0YXRvYjogZ2xvYmFsLmF0b2IsXG5cdG5leHRUaWNrOiB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWwpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDApOyB9LFxuXHRhZGRFdmVudExpc3RlbmVyOiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcixcblx0aW5zcGVjdDogSlNPTi5zdHJpbmdpZnksXG5cdHN0cmluZ0J5dGVTaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHQvKiBzdHIubGVuZ3RoIHdpbGwgYmUgYW4gdW5kZXJlc3RpbWF0ZSBmb3Igbm9uLWFzY2lpIHN0cmluZ3MuIEJ1dCBpZiB3ZSdyZVxuXHRcdCAqIGluIGEgYnJvd3NlciB0b28gb2xkIHRvIHN1cHBvcnQgVGV4dERlY29kZXIsIG5vdCBtdWNoIHdlIGNhbiBkby4gQmV0dGVyXG5cdFx0ICogdG8gdW5kZXJlc3RpbWF0ZSwgc28gaWYgd2UgZG8gZ28gb3Zlci1zaXplLCB0aGUgc2VydmVyIHdpbGwgcmVqZWN0IHRoZVxuXHRcdCAqIG1lc3NhZ2UgKi9cblx0XHRyZXR1cm4gZ2xvYmFsLlRleHREZWNvZGVyICYmXG5cdFx0XHQobmV3IGdsb2JhbC5UZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKS5sZW5ndGggfHxcblx0XHRcdHN0ci5sZW5ndGg7XG5cdH0sXG5cdFRleHRFbmNvZGVyOiBnbG9iYWwuVGV4dEVuY29kZXIsXG5cdFRleHREZWNvZGVyOiBnbG9iYWwuVGV4dERlY29kZXIsXG5cdFByb21pc2U6IGdsb2JhbC5Qcm9taXNlLFxuXHRnZXRSYW5kb21WYWx1ZXM6IChmdW5jdGlvbihjcnlwdG8pIHtcblx0XHRpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrKSB7XG5cdFx0XHRjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG5cdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KShnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykgLy8gbXNjcnlwdG8gZm9yIElFMTFcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUGxhdGZvcm0pO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNyksIF9fd2VicGFja19yZXF1aXJlX18oNDIpLnNldEltbWVkaWF0ZSkpXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2RlZmF1bHRzLmpzXG5cblxudmFyIERlZmF1bHRzID0ge1xuXHRpbnRlcm5ldFVwVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAudHh0Jyxcblx0anNvbnBJbnRlcm5ldFVwVXJsOiAnaHR0cHM6Ly9pbnRlcm5ldC11cC5hYmx5LXJlYWx0aW1lLmNvbS9pcy10aGUtaW50ZXJuZXQtdXAtMC05LmpzJyxcblx0LyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcblx0ICogaW50ZXJzZWN0aW9uIG9mIGJhc2VUcmFuc3BvcnRPcmRlciBhbmQgdGhlIHRyYW5zcG9ydHMgY2xpZW50T3B0aW9uIHRoYXQnc1xuXHQgKiBzdXBwb3J0ZWQuICBUaGlzIGlzIG5vdCBxdWl0ZSB0aGUgc2FtZSBhcyB0aGUgcHJlZmVyZW5jZSBvcmRlciAtLSBlLmcuXG5cdCAqIHhocl9wb2xsaW5nIGlzIHByZWZlcnJlZCB0byBqc29ucCwgYnV0IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQgd2Ugd2FudFxuXHQgKiB0aGUgYmFzZSB0cmFuc3BvcnQgdG8gYmUgeGhyX3BvbGxpbmcsIG5vdCBqc29ucCAqL1xuXHRkZWZhdWx0VHJhbnNwb3J0czogWyd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ2pzb25wJywgJ3dlYl9zb2NrZXQnXSxcblx0YmFzZVRyYW5zcG9ydE9yZGVyOiBbJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnanNvbnAnLCAnd2ViX3NvY2tldCddLFxuXHR0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI6IFsnanNvbnAnLCAneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICd3ZWJfc29ja2V0J10sXG5cdHVwZ3JhZGVUcmFuc3BvcnRzOiBbJ3hocl9zdHJlYW1pbmcnLCAnd2ViX3NvY2tldCddXG59O1xuXG4vKiBJZiB1c2luZyBJRTgsIGRvbid0IGF0dGVtcHQgdG8gdXBncmFkZSBmcm9tIHhocl9wb2xsaW5nIHRvIHhocl9zdHJlYW1pbmcgLVxuKiB3aGlsZSBpdCBjYW4gZG8gc3RyZWFtaW5nLCB0aGUgbG93IG1heCBodHRwLWNvbm5lY3Rpb25zLXBlci1ob3N0IGxpbWl0IG1lYW5zXG4qIHRoYXQgdGhlIHBvbGxpbmcgdHJhbnNwb3J0IGlzIGNyaXBwbGVkIGR1cmluZyB0aGUgdXBncmFkZSBwcm9jZXNzLiBTbyBqdXN0XG4qIGxlYXZlIGl0IGF0IHRoZSBiYXNlIHRyYW5zcG9ydCAqL1xuaWYocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5ub1VwZ3JhZGUpIHtcblx0RGVmYXVsdHMudXBncmFkZVRyYW5zcG9ydHMgPSBbXTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHMgPSAoRGVmYXVsdHMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9idWZmZXJ1dGlscy5qc1xudmFyIGJ1ZmZlcnV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcbnZhciBlcnJvcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9kZWZhdWx0cy5qc1xuXG5cblxuXG5cblxuXG5kZWZhdWx0cy5FTlZJUk9OTUVOVCAgICAgICAgICAgICAgPSAnJztcbmRlZmF1bHRzLlJFU1RfSE9TVCAgICAgICAgICAgICAgICA9ICdyZXN0LmFibHkuaW8nO1xuZGVmYXVsdHMuUkVBTFRJTUVfSE9TVCAgICAgICAgICAgID0gJ3JlYWx0aW1lLmFibHkuaW8nO1xuZGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMgICAgICAgICAgID0gWydBLmFibHktcmVhbHRpbWUuY29tJywgJ0IuYWJseS1yZWFsdGltZS5jb20nLCAnQy5hYmx5LXJlYWx0aW1lLmNvbScsICdELmFibHktcmVhbHRpbWUuY29tJywgJ0UuYWJseS1yZWFsdGltZS5jb20nXTtcbmRlZmF1bHRzLlBPUlQgICAgICAgICAgICAgICAgICAgICA9IDgwO1xuZGVmYXVsdHMuVExTX1BPUlQgICAgICAgICAgICAgICAgID0gNDQzO1xuZGVmYXVsdHMuVElNRU9VVFMgPSB7XG5cdC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXG5cdGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAgIDogMTUwMDAsXG5cdHN1c3BlbmRlZFJldHJ5VGltZW91dCAgICAgIDogMzAwMDAsXG5cdC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xuXHRodHRwUmVxdWVzdFRpbWVvdXQgICAgICAgICA6IDE1MDAwLFxuXHRjaGFubmVsUmV0cnlUaW1lb3V0ICAgICAgICA6IDE1MDAwLFxuXHRmYWxsYmFja1JldHJ5VGltZW91dCAgICAgICA6IDYwMDAwMCxcblx0LyogRm9yIGludGVybmFsIC8gdGVzdCB1c2Ugb25seTogKi9cblx0Y29ubmVjdGlvblN0YXRlVHRsICAgICAgICAgOiAxMjAwMDAsXG5cdHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgICAgIDogMTAwMDAsXG5cdHJlY3ZUaW1lb3V0ICAgICAgICAgICAgICAgIDogOTAwMDAsXG5cdHByZWZlcmVuY2VDb25uZWN0VGltZW91dCAgIDogNjAwMCxcblx0cGFyYWxsZWxVcGdyYWRlRGVsYXkgICAgICAgOiA2MDAwXG59O1xuZGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQgPSAzO1xuZGVmYXVsdHMubWF4TWVzc2FnZVNpemUgICAgPSA2NTUzNjtcblxuZGVmYXVsdHMuZXJyb3JSZXBvcnRpbmdVcmwgPSAnaHR0cHM6Ly9lcnJvcnMuYWJseS5pby9hcGkvMTUvc3RvcmUvJztcbmRlZmF1bHRzLmVycm9yUmVwb3J0aW5nSGVhZGVycyA9IHtcblx0XCJYLVNlbnRyeS1BdXRoXCI6IFwiU2VudHJ5IHNlbnRyeV92ZXJzaW9uPTcsIHNlbnRyeV9rZXk9YTA0ZTMzYzg2NzRjNDUxZjhhMzEwZmJlYzAyOWFjZjUsIHNlbnRyeV9jbGllbnQ9YWJseS1qcy8wLjFcIixcblx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbn07XG5cbmRlZmF1bHRzLnZlcnNpb24gICAgICAgICAgPSAnMS4yLjEzJztcbmRlZmF1bHRzLmFwaVZlcnNpb24gICAgICAgPSAnMS4yJztcblxudmFyIGFnZW50ID0gJ2FibHktanMvJyArIGRlZmF1bHRzLnZlcnNpb247XG5pZiAocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5hZ2VudCkge1xuXHRhZ2VudCArPSAnICcgKyBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFnZW50O1xufSBcbmRlZmF1bHRzLmFnZW50ID0gYWdlbnQ7XG5cbmRlZmF1bHRzLmdldEhvc3QgPSBmdW5jdGlvbihvcHRpb25zLCBob3N0LCB3cykge1xuXHRpZih3cylcblx0XHRob3N0ID0gKChob3N0ID09IG9wdGlvbnMucmVzdEhvc3QpICYmIG9wdGlvbnMucmVhbHRpbWVIb3N0KSB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuXHRlbHNlXG5cdFx0aG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcblxuXHRyZXR1cm4gaG9zdDtcbn07XG5cbmRlZmF1bHRzLmdldFBvcnQgPSBmdW5jdGlvbihvcHRpb25zLCB0bHMpIHtcblx0cmV0dXJuICh0bHMgfHwgb3B0aW9ucy50bHMpID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xufTtcblxuZGVmYXVsdHMuZ2V0SHR0cFNjaGVtZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbn07XG5cbi8vIGNvbnN0cnVjdCBlbnZpcm9ubWVudCBmYWxsYmFjayBob3N0cyBhcyBwZXIgUlNDMTVpXG5kZWZhdWx0cy5lbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMgPSBmdW5jdGlvbihlbnZpcm9ubWVudCkge1xuXHRyZXR1cm4gW1xuXHRcdGVudmlyb25tZW50ICsgJy1hLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcblx0XHRlbnZpcm9ubWVudCArICctYi1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWMtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1kLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcblx0XHRlbnZpcm9ubWVudCArICctZS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbSdcblx0XTtcbn07XG5cbmRlZmF1bHRzLmdldEZhbGxiYWNrSG9zdHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBmYWxsYmFja0hvc3RzID0gb3B0aW9ucy5mYWxsYmFja0hvc3RzLFxuXHRcdGh0dHBNYXhSZXRyeUNvdW50ID0gdHlwZW9mKG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgOiBkZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudDtcblxuXHRyZXR1cm4gZmFsbGJhY2tIb3N0cyA/IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckNob29zZU4oZmFsbGJhY2tIb3N0cywgaHR0cE1heFJldHJ5Q291bnQpIDogW107XG59O1xuXG5kZWZhdWx0cy5nZXRIb3N0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0cmV0dXJuIFtvcHRpb25zLnJlc3RIb3N0XS5jb25jYXQoZGVmYXVsdHMuZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG59O1xuXG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuXHRpZih0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdob3N0IG11c3QgYmUgYSBzdHJpbmc7IHdhcyBhICcgKyB0eXBlb2YgaG9zdCwgNDAwMDAsIDQwMCk7XG5cdH07XG5cdGlmKCFob3N0Lmxlbmd0aCkge1xuXHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2hvc3QgbXVzdCBub3QgYmUgemVyby1sZW5ndGgnLCA0MDAwMCwgNDAwKTtcblx0fTtcbn1cblxuZGVmYXVsdHMub2JqZWN0aWZ5T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gKG9wdGlvbnMuaW5kZXhPZignOicpID09IC0xKSA/IHt0b2tlbjogb3B0aW9uc30gOiB7a2V5OiBvcHRpb25zfTtcblx0fVxuXHRyZXR1cm4gb3B0aW9ucztcbn07XG5cbmRlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8qIERlcHJlY2F0ZWQgb3B0aW9ucyAqL1xuXHRpZihvcHRpb25zLmhvc3QpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnaG9zdCcsICdyZXN0SG9zdCcpO1xuXHRcdG9wdGlvbnMucmVzdEhvc3QgPSBvcHRpb25zLmhvc3Q7XG5cdH1cblx0aWYob3B0aW9ucy53c0hvc3QpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnd3NIb3N0JywgJ3JlYWx0aW1lSG9zdCcpO1xuXHRcdG9wdGlvbnMucmVhbHRpbWVIb3N0ID0gb3B0aW9ucy53c0hvc3Q7XG5cdH1cblx0aWYob3B0aW9ucy5xdWV1ZUV2ZW50cykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdxdWV1ZUV2ZW50cycsICdxdWV1ZU1lc3NhZ2VzJyk7XG5cdFx0b3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gb3B0aW9ucy5xdWV1ZUV2ZW50cztcblx0fVxuXG5cdGlmKG9wdGlvbnMuZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQpIHtcblx0XHQvKiBmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBhbmQgZmFsbGJhY2tIb3N0cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIGFzIHBlciBUTzNrNyAqL1xuXHRcdGlmKG9wdGlvbnMuZmFsbGJhY2tIb3N0cykge1xuXHRcdFx0dmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzIGFuZCBmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYm90aCBiZSBzZXQnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAwMDAsIDQwMCk7XG5cdFx0fVxuXG5cdFx0LyogZGVmYXVsdCBmYWxsYmFja3MgY2FuJ3QgYmUgdXNlZCB3aXRoIGN1c3RvbSBwb3J0cyAqL1xuXHRcdGlmKG9wdGlvbnMucG9ydCB8fCBvcHRpb25zLnRsc1BvcnQpIHtcblx0XHRcdHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJlIHNldCB3aGVuIHBvcnQgb3IgdGxzUG9ydCBhcmUgc2V0Jztcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDAwLCA0MDApO1xuXHRcdH1cblxuXHRcdC8qIGVtaXQgYW4gYXBwcm9wcmlhdGUgZGVwcmVjYXRpb24gd2FybmluZyAqL1xuXHRcdGlmKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkV2l0aE1zZygnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnVGhlcmUgaXMgbm8gbG9uZ2VyIGEgbmVlZCB0byBzZXQgdGhpcyB3aGVuIHRoZSBlbnZpcm9ubWVudCBvcHRpb24gaXMgYWxzbyBzZXQgc2luY2UgdGhlIGxpYnJhcnkgd2lsbCBub3cgZ2VuZXJhdGUgdGhlIGNvcnJlY3QgZmFsbGJhY2sgaG9zdHMgdXNpbmcgdGhlIGVudmlyb25tZW50IG9wdGlvbi4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0JywgJ2ZhbGxiYWNrSG9zdHM6IEFibHkuRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMnKTtcblx0XHR9XG5cblx0XHQvKiB1c2UgdGhlIGRlZmF1bHQgZmFsbGJhY2sgaG9zdHMgYXMgcmVxdWVzdGVkICovXG5cdFx0b3B0aW9ucy5mYWxsYmFja0hvc3RzID0gZGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFM7XG5cdH1cblxuXHRpZihvcHRpb25zLnJlY292ZXIgPT09IHRydWUpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgne3JlY292ZXI6IHRydWV9JywgJ3tyZWNvdmVyOiBmdW5jdGlvbihsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7IGNiKHRydWUpOyB9fScpO1xuXHRcdG9wdGlvbnMucmVjb3ZlciA9IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH07XG5cdH1cblxuXHRpZih0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAnY2xvc2VPblVubG9hZCB3YXMgdHJ1ZSBhbmQgYSBzZXNzaW9uIHJlY292ZXJ5IGZ1bmN0aW9uIHdhcyBzZXQgLSB0aGVzZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBzbyB1bnNldHRpbmcgdGhlIGxhdHRlcicpO1xuXHRcdG9wdGlvbnMucmVjb3ZlciA9IG51bGw7XG5cdH1cblxuXHRpZighKCdjbG9zZU9uVW5sb2FkJyBpbiBvcHRpb25zKSkge1xuXHRcdC8qIEhhdmUgY2xvc2VPblVubG9hZCBkZWZhdWx0IHRvIHRydWUgdW5sZXNzIHdlIGhhdmUgYW55IGluZGljYXRpb24gdGhhdFxuXHRcdCAqIHRoZSB1c2VyIG1heSB3YW50IHRvIHJlY292ZXIgdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRvcHRpb25zLmNsb3NlT25VbmxvYWQgPSAhb3B0aW9ucy5yZWNvdmVyO1xuXHR9XG5cblx0aWYob3B0aW9ucy50cmFuc3BvcnRzICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3RyYW5zcG9ydHM6IFtcInhoclwiXScsICd0cmFuc3BvcnRzOiBbXCJ4aHJfc3RyZWFtaW5nXCJdJyk7XG5cdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRGVsZXRlVmFsdWUob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJyk7XG5cdFx0b3B0aW9ucy50cmFuc3BvcnRzLnB1c2goJ3hocl9zdHJlYW1pbmcnKTtcblx0fVxuXG5cdGlmKCEoJ3F1ZXVlTWVzc2FnZXMnIGluIG9wdGlvbnMpKVxuXHRcdG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IHRydWU7XG5cblx0LyogaW5mZXIgaG9zdHMgYW5kIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBlbnZpcm9ubWVudCAqL1xuXHR2YXIgZW52aXJvbm1lbnQgPSAob3B0aW9ucy5lbnZpcm9ubWVudCAmJiBTdHJpbmcob3B0aW9ucy5lbnZpcm9ubWVudCkudG9Mb3dlckNhc2UoKSkgfHwgZGVmYXVsdHMuRU5WSVJPTk1FTlQ7XG5cdHZhciBwcm9kdWN0aW9uID0gIWVudmlyb25tZW50IHx8IChlbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nKTtcblxuXHRpZighb3B0aW9ucy5mYWxsYmFja0hvc3RzICYmICFvcHRpb25zLnJlc3RIb3N0ICYmICFvcHRpb25zLnJlYWx0aW1lSG9zdCAmJiAhb3B0aW9ucy5wb3J0ICYmICFvcHRpb25zLnRsc1BvcnQpIHtcblx0XHRvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBwcm9kdWN0aW9uID8gZGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFMgOiBkZWZhdWx0cy5lbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMoZW52aXJvbm1lbnQpO1xuXHR9XG5cblx0aWYoIW9wdGlvbnMucmVhbHRpbWVIb3N0KSB7XG5cdFx0LyogcHJlZmVyIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIHJlc3RIb3N0IGFzIGEgY3VzdG9tIHJlc3RIb3N0IHR5cGljYWxseSBpbmRpY2F0ZXNcblx0XHQgKiBhIGRldmVsb3BtZW50IGVudmlyb25tZW50IGlzIGJlaW5nIHVzZWQgdGhhdCBjYW4ndCBiZSBpbmZlcnJlZCBieSB0aGUgbGlicmFyeSAqL1xuXHRcdGlmKG9wdGlvbnMucmVzdEhvc3QpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19XQVJOLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdyZXN0SG9zdCBpcyBzZXQgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiBidXQgcmVhbHRpbWVIb3N0IGlzIG5vdCBzZXQsIHNvIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIFwiJyArIG9wdGlvbnMucmVzdEhvc3QgKyAnXCIgdG9vLiBJZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCBwbGVhc2Ugc2V0IHJlYWx0aW1lSG9zdCBleHBsaWNpdGx5LicpO1xuXHRcdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBvcHRpb25zLnJlc3RIb3N0XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMucmVhbHRpbWVIb3N0ID0gcHJvZHVjdGlvbiA/IGRlZmF1bHRzLlJFQUxUSU1FX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIGRlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XG5cdFx0fVxuXHR9XG5cblx0aWYoIW9wdGlvbnMucmVzdEhvc3QpIHtcblx0XHRvcHRpb25zLnJlc3RIb3N0ID0gcHJvZHVjdGlvbiA/IGRlZmF1bHRzLlJFU1RfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgZGVmYXVsdHMuUkVTVF9IT1NUO1xuXHR9XG5cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaCgob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5yZXN0SG9zdCwgb3B0aW9ucy5yZWFsdGltZUhvc3QpLCBjaGVja0hvc3QpO1xuXG5cdG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCBkZWZhdWx0cy5QT1JUO1xuXHRvcHRpb25zLnRsc1BvcnQgPSBvcHRpb25zLnRsc1BvcnQgfHwgZGVmYXVsdHMuVExTX1BPUlQ7XG5cdG9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IGRlZmF1bHRzLm1heE1lc3NhZ2VTaXplO1xuXHRpZighKCd0bHMnIGluIG9wdGlvbnMpKSBvcHRpb25zLnRscyA9IHRydWU7XG5cblx0LyogQWxsb3cgdmFsdWVzIHBhc3NlZCBpbiBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dHMgKi9cblx0b3B0aW9ucy50aW1lb3V0cyA9IHt9O1xuXHRmb3IodmFyIHByb3AgaW4gZGVmYXVsdHMuVElNRU9VVFMpIHtcblx0XHRvcHRpb25zLnRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBkZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcblx0fTtcblxuXHRpZigndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByZWZlckJpbmFyeTtcblx0fVxuXG5cdGlmKG9wdGlvbnMuY2xpZW50SWQpIHtcblx0XHR2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcblx0XHRoZWFkZXJzWydYLUFibHktQ2xpZW50SWQnXSA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJhc2U2NEVuY29kZShidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS51dGY4RW5jb2RlKG9wdGlvbnMuY2xpZW50SWQpKTtcblx0fVxuXG5cdGlmKCEoJ2lkZW1wb3RlbnRSZXN0UHVibGlzaGluZycgaW4gb3B0aW9ucykpIHtcblx0XHRvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG5cdH1cblxuXHRpZihvcHRpb25zLnByb21pc2VzICYmICFwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlByb21pc2UpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3twcm9taXNlczogdHJ1ZX0gd2FzIHNwZWNpZmllZCwgYnV0IG5vIFByb21pc2UgY29uc3RydWN0b3IgZm91bmQ7IGRpc2FibGluZyBwcm9taXNlcycpO1xuXHRcdG9wdGlvbnMucHJvbWlzZXMgPSBmYWxzZTtcblx0fVxuXG4gICAgICAgIGlmKG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICAgICAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucy5hZ2VudHMpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzLmFnZW50ICs9ICcgJyArIGtleSArICcvJyArIG9wdGlvbnMuYWdlbnRzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblx0cmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsX2RlZmF1bHRzID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZGVmYXVsdHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG5cblxuXG5cbnZhciBCdWZmZXJVdGlscyA9IChmdW5jdGlvbigpIHtcblx0dmFyIEFycmF5QnVmZmVyID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BcnJheUJ1ZmZlcjtcblx0dmFyIGF0b2IgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmF0b2I7XG5cdHZhciBUZXh0RW5jb2RlciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVGV4dEVuY29kZXI7XG5cdHZhciBUZXh0RGVjb2RlciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVGV4dERlY29kZXI7XG5cdHZhciBiYXNlNjRDaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXHR2YXIgaGV4Q2hhclNldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuXHRmdW5jdGlvbiBpc1dvcmRBcnJheShvYikgeyByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5zaWdCeXRlcyAhPT0gdW5kZWZpbmVkOyB9XG5cdGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIob2IpIHsgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2IuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyOyB9XG5cdGZ1bmN0aW9uIGlzVHlwZWRBcnJheShvYikgeyByZXR1cm4gQXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYik7IH1cblxuXHQvLyBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvbmxlaWdodG9uLzk1ODg0MS9yYXcvZjIwMGUzMGRmZTk1MjEyYzAxNjVjY2YxYWUwMDBjYTUxZTlkZTgwMy9naXN0ZmlsZTEuanNcblx0ZnVuY3Rpb24gdWludDhWaWV3VG9CYXNlNjQoYnl0ZXMpIHtcblx0XHR2YXIgYmFzZTY0ICAgID0gJydcblx0XHR2YXIgZW5jb2RpbmdzID0gYmFzZTY0Q2hhclNldDtcblxuXHRcdHZhciBieXRlTGVuZ3RoICAgID0gYnl0ZXMuYnl0ZUxlbmd0aFxuXHRcdHZhciBieXRlUmVtYWluZGVyID0gYnl0ZUxlbmd0aCAlIDNcblx0XHR2YXIgbWFpbkxlbmd0aCAgICA9IGJ5dGVMZW5ndGggLSBieXRlUmVtYWluZGVyXG5cblx0XHR2YXIgYSwgYiwgYywgZFxuXHRcdHZhciBjaHVua1xuXG5cdFx0Ly8gTWFpbiBsb29wIGRlYWxzIHdpdGggYnl0ZXMgaW4gY2h1bmtzIG9mIDNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1haW5MZW5ndGg7IGkgPSBpICsgMykge1xuXHRcdFx0Ly8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXG5cdFx0XHRjaHVuayA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdXG5cblx0XHRcdC8vIFVzZSBiaXRtYXNrcyB0byBleHRyYWN0IDYtYml0IHNlZ21lbnRzIGZyb20gdGhlIHRyaXBsZXRcblx0XHRcdGEgPSAoY2h1bmsgJiAxNjUxNTA3MikgPj4gMTggLy8gMTY1MTUwNzIgPSAoMl42IC0gMSkgPDwgMThcblx0XHRcdGIgPSAoY2h1bmsgJiAyNTgwNDgpICAgPj4gMTIgLy8gMjU4MDQ4ICAgPSAoMl42IC0gMSkgPDwgMTJcblx0XHRcdGMgPSAoY2h1bmsgJiA0MDMyKSAgICAgPj4gIDYgLy8gNDAzMiAgICAgPSAoMl42IC0gMSkgPDwgNlxuXHRcdFx0ZCA9IGNodW5rICYgNjMgICAgICAgICAgICAgICAvLyA2MyAgICAgICA9IDJeNiAtIDFcblxuXHRcdFx0Ly8gQ29udmVydCB0aGUgcmF3IGJpbmFyeSBzZWdtZW50cyB0byB0aGUgYXBwcm9wcmlhdGUgQVNDSUkgZW5jb2Rpbmdcblx0XHRcdGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBlbmNvZGluZ3NbZF1cblx0XHR9XG5cblx0XHQvLyBEZWFsIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcyBhbmQgcGFkZGluZ1xuXHRcdGlmIChieXRlUmVtYWluZGVyID09IDEpIHtcblx0XHRcdGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF1cblxuXHRcdFx0YSA9IChjaHVuayAmIDI1MikgPj4gMiAvLyAyNTIgPSAoMl42IC0gMSkgPDwgMlxuXG5cdFx0XHQvLyBTZXQgdGhlIDQgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG5cdFx0XHRiID0gKGNodW5rICYgMykgICA8PCA0IC8vIDMgICA9IDJeMiAtIDFcblxuXHRcdFx0YmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArICc9PSdcblx0XHR9IGVsc2UgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMikge1xuXHRcdFx0Y2h1bmsgPSAoYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCkgfCBieXRlc1ttYWluTGVuZ3RoICsgMV1cblxuXHRcdFx0YSA9IChjaHVuayAmIDY0NTEyKSA+PiAxMCAvLyA2NDUxMiA9ICgyXjYgLSAxKSA8PCAxMFxuXHRcdFx0YiA9IChjaHVuayAmIDEwMDgpICA+PiAgNCAvLyAxMDA4ICA9ICgyXjYgLSAxKSA8PCA0XG5cblx0XHRcdC8vIFNldCB0aGUgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cblx0XHRcdGMgPSAoY2h1bmsgJiAxNSkgICAgPDwgIDIgLy8gMTUgICAgPSAyXjQgLSAxXG5cblx0XHRcdGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyAnPSdcblx0XHR9XG5cblx0XHRyZXR1cm4gYmFzZTY0XG5cdH1cblxuXHRmdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NCkge1xuXHRcdHZhciBiaW5hcnlfc3RyaW5nID0gIGF0b2IoYmFzZTY0KTtcblx0XHR2YXIgbGVuID0gYmluYXJ5X3N0cmluZy5sZW5ndGg7XG5cdFx0dmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoIGxlbiApO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspICAgICAgICB7XG5cdFx0XHR2YXIgYXNjaWkgPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRieXRlc1tpXSA9IGFzY2lpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZXMuYnVmZmVyO1xuXHR9XG5cblx0LyogTW9zdCBCdWZmZXJVdGlscyBtZXRob2RzIHRoYXQgcmV0dXJuIGEgYmluYXJ5IG9iamVjdCByZXR1cm4gYW4gQXJyYXlCdWZmZXJcblx0ICogaWYgc3VwcG9ydGVkLCBlbHNlIGEgQ3J5cHRvSlMgV29yZEFycmF5LiBUaGUgZXhjZXB0aW9uIGlzIHRvQnVmZmVyLCB3aGljaFxuXHQgKiByZXR1cm5zIGEgVWludDhBcnJheSAoYW5kIHdvbid0IHdvcmsgb24gYnJvd3NlcnMgdG9vIG9sZCB0byBzdXBwb3J0IGl0KSAqL1xuXHRmdW5jdGlvbiBCdWZmZXJVdGlscygpIHt9XG5cblx0QnVmZmVyVXRpbHMuYmFzZTY0Q2hhclNldCA9IGJhc2U2NENoYXJTZXQ7XG5cdEJ1ZmZlclV0aWxzLmhleENoYXJTZXQgPSBoZXhDaGFyU2V0O1xuXG5cdHZhciBpc0J1ZmZlciA9IEJ1ZmZlclV0aWxzLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7IHJldHVybiBpc0FycmF5QnVmZmVyKGJ1ZikgfHwgaXNXb3JkQXJyYXkoYnVmKSB8fCBpc1R5cGVkQXJyYXkoYnVmKTsgfTtcblxuXHQvKiBJbiBicm93c2VycywgcmV0dXJucyBhIFVpbnQ4QXJyYXkgKi9cblx0dmFyIHRvQnVmZmVyID0gQnVmZmVyVXRpbHMudG9CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZighQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgdG8gQnVmZmVyOiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG5lY2Vzc2FyeSB0eXBlc1wiKTtcblx0XHR9XG5cblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikpIHtcblx0XHRcdHJldHVybiBuZXcgVWludDhBcnJheShidWYpO1xuXHRcdH1cblxuXHRcdGlmKGlzVHlwZWRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlcik7XG5cdFx0fVxuXG5cdFx0aWYoaXNXb3JkQXJyYXkoYnVmKSkge1xuXHRcdFx0LyogQmFja3BvcnRlZCBmcm9tIHVucmVsZWFzZWQgQ3J5cHRvSlNcblx0XHRcdCogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvc291cmNlL2Jyb3dzZS9icmFuY2hlcy8zLngvc3JjL2xpYi10eXBlZGFycmF5cy5qcz9yPTY2MSAqL1xuXHRcdFx0dmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1Zi5zaWdCeXRlcyk7XG5cdFx0XHR2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5zaWdCeXRlczsgaSsrKSB7XG5cdFx0XHRcdHVpbnQ4Vmlld1tpXSA9IChidWYud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdWludDhWaWV3O1xuXHRcdH07XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJVdGlscy50b0J1ZmZlciBleHBlY3RlZCBhbiBhcnJheWJ1ZmZlciwgdHlwZWQgYXJyYXksIG9yIENyeXB0b0pTIHdvcmRhcnJheVwiKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKSB7XG5cdFx0XHRyZXR1cm4gYnVmO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9CdWZmZXIoYnVmKS5idWZmZXI7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc1R5cGVkQXJyYXkoYnVmKSkge1xuXHRcdFx0YnVmID0gYnVmLmJ1ZmZlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGlzV29yZEFycmF5KGJ1ZikgPyBidWYgOiBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmNyZWF0ZShidWYpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzV29yZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVpbnQ4Vmlld1RvQmFzZTY0KHRvQnVmZmVyKGJ1ZikpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJhc2U2NERlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdGlmKEFycmF5QnVmZmVyICYmIGF0b2IpIHtcblx0XHRcdHJldHVybiBiYXNlNjRUb0FycmF5QnVmZmVyKHN0cik7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInBhcnNlXCJdKShzdHIpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmhleEVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGJ1ZiA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1Zik7XG5cdFx0cmV0dXJuIE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2hleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic3RyaW5naWZ5XCJdKShidWYpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmhleERlY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHZhciB3b3JkQXJyYXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInBhcnNlXCJdKShzdHJpbmcpO1xuXHRcdHJldHVybiBBcnJheUJ1ZmZlciA/IEJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXIod29yZEFycmF5KSA6IHdvcmRBcnJheTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy51dGY4RW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0aWYoVGV4dEVuY29kZXIpIHtcblx0XHRcdHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShzdHJpbmcpLmJ1ZmZlcjtcblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlXCJdKShzdHJpbmcpO1xuXHR9O1xuXG5cdC8qIEZvciB1dGY4IGRlY29kaW5nIHdlIGFwcGx5IHNsaWdodGx5IHN0cmljdGVyIGlucHV0IHZhbGlkYXRpb24gdGhhbiB0b1xuXHQgKiBoZXhFbmNvZGUvYmFzZTY0RW5jb2RlL2V0YzogaW4gdGhvc2Ugd2UgYWNjZXB0IGFueXRoaW5nIHRoYXQgQnVmZmVyLmZyb21cblx0ICogY2FuIHRha2UgKGluIHBhcnRpY3VsYXIgYWxsb3dpbmcgc3RyaW5ncywgd2hpY2ggYXJlIGp1c3QgaW50ZXJwcmV0ZWQgYXNcblx0ICogYmluYXJ5KTsgaGVyZSB3ZSBlbnN1cmUgdGhhdCB0aGUgaW5wdXQgaXMgYWN0dWFsbHkgYSBidWZmZXIgc2luY2UgdHJ5aW5nXG5cdCAqIHRvIHV0ZjgtZGVjb2RlIGEgc3RyaW5nIHRvIGFub3RoZXIgc3RyaW5nIGlzIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlICovXG5cdEJ1ZmZlclV0aWxzLnV0ZjhEZWNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZighaXNCdWZmZXIoYnVmKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOGRlY29kZSB0byBiZSBhbiBhcnJheWJ1ZmZlciwgdHlwZWQgYXJyYXksIG9yIENyeXB0b0pTIHdvcmRhcnJheVwiKTtcblx0XHR9XG5cdFx0aWYoVGV4dERlY29kZXIgJiYgIWlzV29yZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiAobmV3IFRleHREZWNvZGVyKCkpLmRlY29kZShidWYpO1xuXHRcdH1cblx0XHRidWYgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYpO1xuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJzdHJpbmdpZnlcIl0pKGJ1Zik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuYnVmZmVyQ29tcGFyZSA9IGZ1bmN0aW9uKGJ1ZjEsIGJ1ZjIpIHtcblx0XHRpZighYnVmMSkgcmV0dXJuIC0xO1xuXHRcdGlmKCFidWYyKSByZXR1cm4gMTtcblx0XHRidWYxID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmMSk7XG5cdFx0YnVmMiA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1ZjIpO1xuXHRcdGJ1ZjEuY2xhbXAoKTsgYnVmMi5jbGFtcCgpO1xuXG5cdFx0dmFyIGNtcCA9IGJ1ZjEuc2lnQnl0ZXMgLSBidWYyLnNpZ0J5dGVzO1xuXHRcdGlmKGNtcCAhPSAwKSByZXR1cm4gY21wO1xuXHRcdGJ1ZjEgPSBidWYxLndvcmRzOyBidWYyID0gYnVmMi53b3Jkcztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYnVmMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y21wID0gYnVmMVtpXSAtIGJ1ZjJbaV07XG5cdFx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSB8fCBpc1R5cGVkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIGJ1Zi5ieXRlTGVuZ3RoXG5cdFx0fSBlbHNlIGlmKGlzV29yZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiBidWYuc2lnQnl0ZXM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJldHVybnMgQXJyYXlCdWZmZXIgb24gYnJvd3NlciBhbmQgQnVmZmVyIG9uIE5vZGUuanMgKi9cblx0QnVmZmVyVXRpbHMudHlwZWRBcnJheVRvQnVmZmVyID0gZnVuY3Rpb24odHlwZWRBcnJheSkge1xuXHRcdHJldHVybiB0eXBlZEFycmF5LmJ1ZmZlcjtcblx0fTtcblxuXHRyZXR1cm4gQnVmZmVyVXRpbHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEJ1ZmZlclV0aWxzKTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cblxudmFyIEh0dHAgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHRmdW5jdGlvbiBIdHRwKCkge31cblxuXHR2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG5cdFx0LyogSUUgOCAqL1xuXHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBzaG91bGRGYWxsYmFjayhlcnIpIHtcblx0XHR2YXIgc3RhdHVzQ29kZSA9IGVyci5zdGF0dXNDb2RlO1xuXHRcdC8qIDQwMCArIG5vIGNvZGUgPSBhIGdlbmVyaWMgeGhyIG9uZXJyb3IuIEJyb3dzZXIgZG9lc24ndCBnaXZlIHVzIGVub3VnaFxuXHRcdCAqIGRldGFpbCB0byBrbm93IHdoZXRoZXIgaXQncyBmYWxsYmFjay1maXhhYmxlLCBidXQgaXQgbWF5IGJlIChlZyBpZiBhXG5cdFx0ICogbmV0d29yayBpc3N1ZSksIHNvIHRyeSBqdXN0IGluIGNhc2UgKi9cblx0XHRyZXR1cm4gKHN0YXR1c0NvZGUgPT09IDQwOCAmJiAhZXJyLmNvZGUpIHx8XG5cdFx0XHQoc3RhdHVzQ29kZSA9PT0gNDAwICYmICFlcnIuY29kZSkgICAgICB8fFxuXHRcdFx0KHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhvc3RzKGNsaWVudCkge1xuXHRcdC8qIElmIHdlJ3JlIGEgY29ubmVjdGVkIHJlYWx0aW1lIGNsaWVudCwgdHJ5IHRoZSBlbmRwb2ludCB3ZSdyZSBjb25uZWN0ZWRcblx0XHQgKiB0byBmaXJzdCAtLSBidXQgc3RpbGwgaGF2ZSBmYWxsYmFja3MsIGJlaW5nIGNvbm5lY3RlZCBpcyBub3QgYW4gYWJzb2x1dGVcblx0XHQgKiBndWFyYW50ZWUgdGhhdCBhIGRhdGFjZW50ZXIgaGFzIGZyZWUgY2FwYWNpdHkgdG8gc2VydmljZSBSRVNUIHJlcXVlc3RzLiAqL1xuXHRcdHZhciBjb25uZWN0aW9uID0gY2xpZW50LmNvbm5lY3Rpb24sXG5cdFx0XHRjb25uZWN0aW9uSG9zdCA9IGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5ob3N0O1xuXG5cdFx0aWYoY29ubmVjdGlvbkhvc3QpIHtcblx0XHRcdHJldHVybiBbY29ubmVjdGlvbkhvc3RdLmNvbmNhdChfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0RmFsbGJhY2tIb3N0cyhjbGllbnQub3B0aW9ucykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0SG9zdHMoY2xpZW50Lm9wdGlvbnMpO1xuXHR9XG5cdEh0dHAuX2dldEhvc3RzID0gZ2V0SG9zdHM7XG5cblx0SHR0cC5tZXRob2RzID0gWydnZXQnLCAnZGVsZXRlJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ107XG5cdEh0dHAubWV0aG9kc1dpdGhvdXRCb2R5ID0gWydnZXQnLCAnZGVsZXRlJ107XG5cdEh0dHAubWV0aG9kc1dpdGhCb2R5ID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyclN1YnRyYWN0KEh0dHAubWV0aG9kcywgSHR0cC5tZXRob2RzV2l0aG91dEJvZHkpO1xuXG5cdC8qIC0gSHR0cC5nZXQsIEh0dHAucG9zdCwgSHR0cC5wdXQsIC4uLlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBmb3IgYSBnaXZlbiBwYXRoIGFnYWluc3QgcHJpbWUgYW5kIGZhbGxiYWNrIEFibHkgaG9zdHNcblx0ICogQHBhcmFtIHJlc3Rcblx0ICogQHBhcmFtIHBhdGggdGhlIGZ1bGwgcGF0aFxuXHQgKiBAcGFyYW0gaGVhZGVycyBvcHRpb25hbCBoYXNoIG9mIGhlYWRlcnNcblx0ICogW29ubHkgZm9yIG1ldGhvZHMgd2l0aCBib2R5OiBAcGFyYW0gYm9keSBvYmplY3Qgb3IgYnVmZmVyIGNvbnRhaW5pbmcgcmVxdWVzdCBib2R5XVxuXHQgKiBAcGFyYW0gcGFyYW1zIG9wdGlvbmFsIGhhc2ggb2YgcGFyYW1zXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCByZXNwb25zZSlcblx0ICpcblx0ICogLSBIdHRwLmdldFVyaSwgSHR0cC5wb3N0VXJpLCBIdHRwLnB1dFVyaSwgLi4uXG5cdCAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGZvciBhIGdpdmVuIGZ1bGwgVVJJXG5cdCAqIEBwYXJhbSByZXN0XG5cdCAqIEBwYXJhbSB1cmkgdGhlIGZ1bGwgVVJJXG5cdCAqIEBwYXJhbSBoZWFkZXJzIG9wdGlvbmFsIGhhc2ggb2YgaGVhZGVyc1xuXHQgKiBbb25seSBmb3IgbWV0aG9kcyB3aXRoIGJvZHk6IEBwYXJhbSBib2R5IG9iamVjdCBvciBidWZmZXIgY29udGFpbmluZyByZXF1ZXN0IGJvZHldXG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHJlc3BvbnNlKVxuXHQgKi9cblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goSHR0cC5tZXRob2RzV2l0aG91dEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdEh0dHBbbWV0aG9kXSA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdEh0dHBbJ2RvJ10obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBudWxsLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHRcdEh0dHBbbWV0aG9kICsgJ1VyaSddID0gZnVuY3Rpb24ocmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRIdHRwLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBudWxsLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9KTtcblxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChIdHRwLm1ldGhvZHNXaXRoQm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0SHR0cFttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cFsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdFx0SHR0cFttZXRob2QgKyAnVXJpJ10gPSBmdW5jdGlvbihyZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdC8qIFVubGlrZSBmb3IgZG9VcmksIHRoZSAncmVzdCcgcGFyYW0gaGVyZSBpcyBtYW5kYXRvcnksIGFzIGl0J3MgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaG9zdHMgKi9cblx0SHR0cFsnZG8nXSA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblx0XHR2YXIgdXJpRnJvbUhvc3QgPSAodHlwZW9mKHBhdGgpID09ICdmdW5jdGlvbicpID8gcGF0aCA6IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIHJlc3QuYmFzZVVyaShob3N0KSArIHBhdGg7IH07XG5cdFx0dmFyIGJpbmFyeSA9IChoZWFkZXJzICYmIGhlYWRlcnMuYWNjZXB0ICE9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0dmFyIGRvQXJncyA9IGFyZ3VtZW50cztcblxuXHRcdHZhciBjdXJyZW50RmFsbGJhY2sgPSByZXN0Ll9jdXJyZW50RmFsbGJhY2s7XG5cdFx0aWYoY3VycmVudEZhbGxiYWNrKSB7XG5cdFx0XHRpZihjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IG5vdygpKSB7XG5cdFx0XHRcdC8qIFVzZSBzdG9yZWQgZmFsbGJhY2sgKi9cblx0XHRcdFx0SHR0cC5SZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGlmKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpKSB7XG5cdFx0XHRcdFx0XHQvKiB1bnN0b3JlIHRoZSBmYWxsYmFjayBhbmQgc3RhcnQgZnJvbSB0aGUgdG9wIHdpdGggdGhlIGRlZmF1bHQgc2VxdWVuY2UgKi9cblx0XHRcdFx0XHRcdHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRIdHRwWydkbyddLmFwcGx5KEh0dHAsIGRvQXJncyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBGYWxsYmFjayBleHBpcmVkOyByZW1vdmUgaXQgYW5kIGZhbGx0aHJvdWdoIHRvIG5vcm1hbCBzZXF1ZW5jZSAqL1xuXHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBob3N0cyA9IGdldEhvc3RzKHJlc3QpO1xuXG5cdFx0LyogaWYgdGhlcmUgaXMgb25seSBvbmUgaG9zdCBkbyBpdCAqL1xuXHRcdGlmKGhvc3RzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRIdHRwLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoaG9zdHNbMF0pLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBob3N0cyBpcyBhbiBhcnJheSB3aXRoIHByZWZlcnJlZCBob3N0IHBsdXMgYXQgbGVhc3Qgb25lIGZhbGxiYWNrICovXG5cdFx0dmFyIHRyeUFIb3N0ID0gZnVuY3Rpb24oY2FuZGlkYXRlSG9zdHMsIHBlcnNpc3RPblN1Y2Nlc3MpIHtcblx0XHRcdHZhciBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihwZXJzaXN0T25TdWNjZXNzKSB7XG5cdFx0XHRcdFx0LyogUlNDMTVmICovXG5cdFx0XHRcdFx0cmVzdC5fY3VycmVudEZhbGxiYWNrID0ge1xuXHRcdFx0XHRcdFx0aG9zdDogaG9zdCxcblx0XHRcdFx0XHRcdHZhbGlkVW50aWw6IG5vdygpICsgcmVzdC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHR0cnlBSG9zdChob3N0cyk7XG5cdH07XG5cblx0SHR0cC5kb1VyaSA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0SHR0cC5SZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKTtcblx0fTtcblxuXHRIdHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSBmYWxzZTtcblx0SHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID0gZmFsc2U7XG5cdHJldHVybiBIdHRwO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChIdHRwKTtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxuXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0XHR0aGlzLmFueSA9IFtdO1xuXHRcdHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR0aGlzLmFueU9uY2UgPSBbXTtcblx0XHR0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHR9XG5cblx0LyogQ2FsbCB0aGUgbGlzdGVuZXIsIGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCBsb2csIGJ1dCBjb250aW51ZSBvcGVyYXRpb24qL1xuXHRmdW5jdGlvbiBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncykge1xuXHRcdHRyeSB7XG5cdFx0XHRsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnRXZlbnRFbWl0dGVyLmVtaXQoKScsICdVbmV4cGVjdGVkIGxpc3RlbmVyIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyAoZSAmJiBlLnN0YWNrKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCBsaXN0ZW5lclxuXHQgKiBAcGFyYW0gdGFyZ2V0TGlzdGVuZXJzIGlzIGFuIGFycmF5IG9mIGxpc3RlbmVyIGFycmF5cyBvciBldmVudCBvYmplY3RzIHdpdGggYXJyYXlzIG9mIGxpc3RlbmVyc1xuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGNhbGxiYWNrIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0gZXZlbnRGaWx0ZXIgKG9wdGlvbmFsKSBldmVudCBuYW1lIGluc3RydWN0aW5nIHRoZSBmdW5jdGlvbiB0byBvbmx5IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XG5cdFx0dmFyIGxpc3RlbmVycywgaWR4LCBldmVudE5hbWUsIHRhcmdldExpc3RlbmVyc0luZGV4O1xuXG5cdFx0Zm9yICh0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xuXHRcdFx0bGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XTtcblx0XHRcdGlmIChldmVudEZpbHRlcikgeyBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbZXZlbnRGaWx0ZXJdOyB9XG5cblx0XHRcdGlmIChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGxpc3RlbmVycykpIHtcblx0XHRcdFx0d2hpbGUgKChpZHggPSBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKGxpc3RlbmVycywgbGlzdGVuZXIpKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogSWYgZXZlbnRzIG9iamVjdCBoYXMgYW4gZXZlbnQgbmFtZSBrZXkgd2l0aCBubyBsaXN0ZW5lcnMgdGhlblxuXHRcdFx0XHQgICByZW1vdmUgdGhlIGtleSB0byBzdG9wIHRoZSBsaXN0IGdyb3dpbmcgaW5kZWZpbml0ZWx5ICovXG5cdFx0XHRcdGlmIChldmVudEZpbHRlciAmJiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkpIHtcblx0XHRcdFx0XHRkZWxldGUgdGFyZ2V0TGlzdGVuZXJzW3RhcmdldExpc3RlbmVyc0luZGV4XVtldmVudEZpbHRlcl07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNPYmplY3QobGlzdGVuZXJzKSkge1xuXHRcdFx0XHQvKiBldmVudHMgKi9cblx0XHRcdFx0Zm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwobGlzdGVuZXJzLCBldmVudE5hbWUpICYmIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkobGlzdGVuZXJzW2V2ZW50TmFtZV0pKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVMaXN0ZW5lcihbbGlzdGVuZXJzXSwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHQgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqICAgICAgICBpZiBub3Qgc3VwcGxpZWQsIGFsbCBldmVudHMgdHJpZ2dlciBhIGNhbGwgdG8gdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihldmVudCkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5hbnkucHVzaChldmVudCk7XG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcblx0XHR9IGVsc2UgaWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShldmVudCkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlbGYub24oZXYsIGxpc3RlbmVyKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5ldmVudHNbZXZlbnRdID0gW10pKTtcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBvbmUgb3IgbW9yZSBldmVudCBsaXN0ZW5lcnNcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHdob3NlIGxpc3RlbmVyXG5cdCAqICAgICAgICBpcyB0byBiZSByZW1vdmVkLiBJZiBub3Qgc3VwcGxpZWQsIHRoZSBsaXN0ZW5lciBpc1xuXHQgKiAgICAgICAgdHJlYXRlZCBhcyBhbiAnYW55JyBsaXN0ZW5lclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgKG9wdGlvbmFsKSB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlLiBJZiBub3Rcblx0ICogICAgICAgIHN1cHBsaWVkLCBhbGwgbGlzdGVuZXJzIGFyZSByZW1vdmVkLlxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDAgfHwgKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoZXZlbnQpICYmIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcobGlzdGVuZXIpKSkge1xuXHRcdFx0dGhpcy5hbnkgPSBbXTtcblx0XHRcdHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdFx0dGhpcy5ldmVudHNPbmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRpZih0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Lyogd2UgdGFrZSB0aGlzIHRvIGJlIHRoZSBsaXN0ZW5lciBhbmQgdHJlYXQgdGhlIGV2ZW50IGFzIFwiYW55XCIgLi4gKi9cblx0XHRcdFx0bGlzdGVuZXIgPSBldmVudDtcblx0XHRcdFx0ZXZlbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0LyogLi4uIG9yIHdlIHRha2UgZXZlbnQgdG8gYmUgdGhlIGFjdHVhbCBldmVudCBuYW1lIGFuZCBsaXN0ZW5lciB0byBiZSBhbGwgKi9cblx0XHR9XG5cblx0XHRpZihsaXN0ZW5lciAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShldmVudCkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlbGYub2ZmKGV2LCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKiBcIm5vcm1hbFwiIGNhc2Ugd2hlcmUgZXZlbnQgaXMgYW4gYWN0dWFsIGV2ZW50ICovXG5cdFx0aWYobGlzdGVuZXIpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKFt0aGlzLmV2ZW50cywgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIsIGV2ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzW2V2ZW50XTtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQ7IGV4Y2x1ZGVzIG9uY2UgZXZlbnRzXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgb3Igbm9uZSBmb3IgJ2FueSdcblx0ICogQHJldHVybiBhcnJheSBvZiBldmVudHMsIG9yIG51bGwgaWYgbm9uZVxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmKGV2ZW50KSB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXSk7XG5cdFx0XHRpZih0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuXHRcdFx0cmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGFuIGV2ZW50XG5cdCAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCAgLyogLCBhcmdzLi4uICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdHZhciBldmVudFRoaXMgPSB7ZXZlbnQ6ZXZlbnR9O1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuXHRcdGlmKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcblx0XHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdH1cblx0XHRpZih0aGlzLmFueS5sZW5ndGgpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnkpO1xuXHRcdH1cblx0XHR2YXIgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG5cdFx0aWYoZXZlbnRzT25jZUxpc3RlbmVycykge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNPbmNlTGlzdGVuZXJzKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdH1cblx0XHR2YXIgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuXHRcdGlmKGV2ZW50c0xpc3RlbmVycykge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNMaXN0ZW5lcnMpO1xuXHRcdH1cblxuXHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdFx0Y2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYW4gZXZlbnRcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbGYgPSB0aGlzO1xuXHRcdGlmKChhcmdDb3VudCA9PT0gMCB8fCAoYXJnQ291bnQgPT09IDEgJiYgdHlwZW9mIGV2ZW50ICE9PSAnZnVuY3Rpb24nKSkgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdFx0XHRcdHNlbGYub25jZShldmVudCwgcmVzb2x2ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihldmVudCkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5hbnlPbmNlLnB1c2goZXZlbnQpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5hbnlPbmNlLnB1c2gobGlzdGVuZXIpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGV2ZW50KSl7XG5cdFx0XHR2YXIgbGlzdGVuZXJXcmFwcGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRzZWxmLm9mZihldiwgbGlzdGVuZXJXcmFwcGVyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0fTtcblx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlbGYub24oZXYsIGxpc3RlbmVyV3JhcHBlcik7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdIHx8ICh0aGlzLmV2ZW50c09uY2VbZXZlbnRdID0gW10pKTtcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgQVBJXG5cdCAqXG5cdCAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG5cdCAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3Rcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24odGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgbGlzdGVuZXIgLyogLi4ubGlzdGVuZXJBcmdzICovKSB7XG5cdFx0dmFyIGV2ZW50VGhpcyA9IHtldmVudDp0YXJnZXRTdGF0ZX0sXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdGxpc3RlbmVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cblx0XHRpZigodHlwZW9mKHRhcmdldFN0YXRlKSAhPT0gJ3N0cmluZycpIHx8ICh0eXBlb2YoY3VycmVudFN0YXRlKSAhPT0gJ3N0cmluZycpKSB7XG5cdFx0XHR0aHJvdyhcIndoZW5TdGF0ZSByZXF1aXJlcyBhIHZhbGlkIGV2ZW50IFN0cmluZyBhcmd1bWVudFwiKTtcblx0XHR9XG5cdFx0aWYodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHRcdFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLndoZW5TdGF0ZS5hcHBseShzZWxmLCBbdGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgcmVzb2x2ZV0uY29uY2F0KGxpc3RlbmVyQXJncykpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmKHRhcmdldFN0YXRlID09PSBjdXJyZW50U3RhdGUpIHtcblx0XHRcdGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBsaXN0ZW5lckFyZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9uY2UodGFyZ2V0U3RhdGUsIGxpc3RlbmVyKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gRXZlbnRFbWl0dGVyO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFdmVudEVtaXR0ZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVzZW5jZW1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cblxuXG5cbnZhciBQcm90b2NvbE1lc3NhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gUHJvdG9jb2xNZXNzYWdlKCkge1xuXHRcdHRoaXMuYWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZmxhZ3MgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvdW50ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNoYW5uZWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jaGFubmVsU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubXNnU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubWVzc2FnZXMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmF1dGggPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wYXJhbXMgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHR2YXIgYWN0aW9ucyA9IFByb3RvY29sTWVzc2FnZS5BY3Rpb24gPSB7XG5cdFx0J0hFQVJUQkVBVCcgOiAwLFxuXHRcdCdBQ0snIDogMSxcblx0XHQnTkFDSycgOiAyLFxuXHRcdCdDT05ORUNUJyA6IDMsXG5cdFx0J0NPTk5FQ1RFRCcgOiA0LFxuXHRcdCdESVNDT05ORUNUJyA6IDUsXG5cdFx0J0RJU0NPTk5FQ1RFRCcgOiA2LFxuXHRcdCdDTE9TRScgOiA3LFxuXHRcdCdDTE9TRUQnIDogOCxcblx0XHQnRVJST1InIDogOSxcblx0XHQnQVRUQUNIJyA6IDEwLFxuXHRcdCdBVFRBQ0hFRCcgOiAxMSxcblx0XHQnREVUQUNIJyA6IDEyLFxuXHRcdCdERVRBQ0hFRCcgOiAxMyxcblx0XHQnUFJFU0VOQ0UnIDogMTQsXG5cdFx0J01FU1NBR0UnIDogMTUsXG5cdFx0J1NZTkMnIDogMTYsXG5cdFx0J0FVVEgnIDogMTdcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzID0gWyAnUFJFU0VOQ0UnLCAnUFVCTElTSCcsICdTVUJTQ1JJQkUnLCAnUFJFU0VOQ0VfU1VCU0NSSUJFJyBdO1xuXG5cdFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lID0gW107XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmtleXNBcnJheShQcm90b2NvbE1lc3NhZ2UuQWN0aW9uLCB0cnVlKSwgZnVuY3Rpb24obmFtZSkge1xuXHRcdFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lW2FjdGlvbnNbbmFtZV1dID0gbmFtZTtcblx0fSk7XG5cblx0dmFyIGZsYWdzID0ge1xuXHRcdC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXG5cdFx0J0hBU19QUkVTRU5DRSc6ICAgICAgIDEgPDwgMCxcblx0XHQnSEFTX0JBQ0tMT0cnOiAgICAgICAgMSA8PCAxLFxuXHRcdCdSRVNVTUVEJzogICAgICAgICAgICAxIDw8IDIsXG5cdFx0J1RSQU5TSUVOVCc6ICAgICAgICAgIDEgPDwgNCxcblx0XHQnQVRUQUNIX1JFU1VNRSc6ICAgICAgMSA8PCA1LFxuXHRcdC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xuXHRcdCdQUkVTRU5DRSc6ICAgICAgICAgICAxIDw8IDE2LFxuXHRcdCdQVUJMSVNIJzogICAgICAgICAgICAxIDw8IDE3LFxuXHRcdCdTVUJTQ1JJQkUnOiAgICAgICAgICAxIDw8IDE4LFxuXHRcdCdQUkVTRU5DRV9TVUJTQ1JJQkUnOiAxIDw8IDE5XG5cdH07XG5cdHZhciBmbGFnTmFtZXMgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmtleXNBcnJheShmbGFncyk7XG5cdGZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFO1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuaGFzRmxhZyA9IGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRyZXR1cm4gKCh0aGlzLmZsYWdzICYgZmxhZ3NbZmxhZ10pID4gMCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5zZXRGbGFnID0gZnVuY3Rpb24oZmxhZykge1xuXHRcdHJldHVybiB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8IGZsYWdzW2ZsYWddO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmZsYWdzICYmICh0aGlzLmZsYWdzICYgZmxhZ3MuTU9ERV9BTEwpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlTW9kZXNUb0ZsYWdzID0gZnVuY3Rpb24obW9kZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKG1vZGVzLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0XHRzZWxmLnNldEZsYWcobW9kZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5kZWNvZGVNb2Rlc0Zyb21GbGFncyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb2RlcyA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKFByb3RvY29sTWVzc2FnZS5jaGFubmVsTW9kZXMsIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHRcdGlmKHNlbGYuaGFzRmxhZyhtb2RlKSkge1xuXHRcdFx0XHRtb2Rlcy5wdXNoKG1vZGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB1bmRlZmluZWQ7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLnNlcmlhbGl6ZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlQm9keTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihzZXJpYWxpemVkLCBmb3JtYXQpIHtcblx0XHR2YXIgZGVzZXJpYWxpemVkID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGVCb2R5KHNlcmlhbGl6ZWQsIGZvcm1hdCk7XG5cdFx0cmV0dXJuIFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQgPSBmdW5jdGlvbihkZXNlcmlhbGl6ZWQpIHtcblx0XHR2YXIgZXJyb3IgPSBkZXNlcmlhbGl6ZWQuZXJyb3I7XG5cdFx0aWYoZXJyb3IpIGRlc2VyaWFsaXplZC5lcnJvciA9IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKGVycm9yKTtcblx0XHR2YXIgbWVzc2FnZXMgPSBkZXNlcmlhbGl6ZWQubWVzc2FnZXM7XG5cdFx0aWYobWVzc2FnZXMpIGZvcih2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykgbWVzc2FnZXNbaV0gPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMobWVzc2FnZXNbaV0pO1xuXHRcdHZhciBwcmVzZW5jZSA9IGRlc2VyaWFsaXplZC5wcmVzZW5jZTtcblx0XHRpZihwcmVzZW5jZSkgZm9yKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKSBwcmVzZW5jZVtpXSA9IF9wcmVzZW5jZW1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHByZXNlbmNlW2ldLCB0cnVlKTtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIGRlc2VyaWFsaXplZCk7XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRpZiAoYXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAnWyAnICsgcmVzdWx0LmpvaW4oJywgJykgKyAnIF0nO1xuXHR9XG5cblx0dmFyIHNpbXBsZUF0dHJpYnV0ZXMgPSAnaWQgY2hhbm5lbCBjaGFubmVsU2VyaWFsIGNvbm5lY3Rpb25JZCBjb25uZWN0aW9uS2V5IGNvbm5lY3Rpb25TZXJpYWwgY291bnQgbXNnU2VyaWFsIHRpbWVzdGFtcCcuc3BsaXQoJyAnKTtcblxuXHRQcm90b2NvbE1lc3NhZ2Uuc3RyaW5naWZ5ID0gZnVuY3Rpb24obXNnKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbUHJvdG9jb2xNZXNzYWdlJztcblx0XHRpZihtc2cuYWN0aW9uICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgYWN0aW9uPScgKyBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVttc2cuYWN0aW9uXSB8fCBmYWxzZTtcblxuXHRcdHZhciBhdHRyaWJ1dGU7XG5cdFx0Zm9yICh2YXIgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XG5cdFx0XHRhdHRyaWJ1dGUgPSBzaW1wbGVBdHRyaWJ1dGVzW2F0dHJpYkluZGV4XTtcblx0XHRcdGlmKG1zZ1thdHRyaWJ1dGVdICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyAnICsgYXR0cmlidXRlICsgJz0nICsgbXNnW2F0dHJpYnV0ZV07XG5cdFx0fVxuXG5cdFx0aWYobXNnLm1lc3NhZ2VzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IG1lc3NhZ2VzPScgKyB0b1N0cmluZ0FycmF5KF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlc0FycmF5KG1zZy5tZXNzYWdlcykpO1xuXHRcdGlmKG1zZy5wcmVzZW5jZSlcblx0XHRcdHJlc3VsdCArPSAnOyBwcmVzZW5jZT0nICsgdG9TdHJpbmdBcnJheShfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xuXHRcdGlmKG1zZy5lcnJvcilcblx0XHRcdHJlc3VsdCArPSAnOyBlcnJvcj0nICsgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMobXNnLmVycm9yKS50b1N0cmluZygpO1xuXHRcdGlmKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRva2VuPScgKyBtc2cuYXV0aC5hY2Nlc3NUb2tlbjtcblx0XHRpZihtc2cuZmxhZ3MpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZmxhZ3M9JyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRmlsdGVyKGZsYWdOYW1lcywgZnVuY3Rpb24oZmxhZykge1xuXHRcdFx0XHRyZXR1cm4gbXNnLmhhc0ZsYWcoZmxhZyk7XG5cdFx0XHR9KS5qb2luKCcsJyk7XG5cdFx0aWYobXNnLnBhcmFtcykge1xuXHRcdFx0dmFyIHN0cmluZ2lmaWVkUGFyYW1zID0gJyc7XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZvckluT3duTm9uTnVsbFByb3BzKG1zZy5wYXJhbXMsIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0aWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRzdHJpbmdpZmllZFBhcmFtcyArPSAnOyAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0cmluZ2lmaWVkUGFyYW1zICs9IHByb3AgKyAnPScgKyBtc2cucGFyYW1zW3Byb3BdO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoc3RyaW5naWZpZWRQYXJhbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXN1bHQgKz0gJzsgcGFyYW1zPVsnICsgc3RyaW5naWZpZWRQYXJhbXMgKyAnXSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiBPbmx5IHZhbGlkIGZvciBjaGFubmVsIG1lc3NhZ2VzICovXG5cdFByb3RvY29sTWVzc2FnZS5pc0R1cGxpY2F0ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRpZiAoYSAmJiBiKSB7XG5cdFx0XHRpZiAoKGEuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHwgYS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpICYmXG5cdFx0XHRcdChhLmFjdGlvbiA9PT0gYi5hY3Rpb24pICYmXG5cdFx0XHRcdChhLmNoYW5uZWwgPT09IGIuY2hhbm5lbCkgJiZcblx0XHRcdFx0KGEuaWQgPT09IGIuaWQpKSB7XG5cdFx0XHRcdGlmIChhLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGEubWVzc2FnZXMubGVuZ3RoID09PSBiLm1lc3NhZ2VzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYS5tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIGFNZXNzYWdlID0gYS5tZXNzYWdlc1tpXTtcblx0XHRcdFx0XHRcdHZhciBiTWVzc2FnZSA9IGIubWVzc2FnZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoKGFNZXNzYWdlLmV4dHJhcyAmJiBhTWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgYU1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZvcm1hdCkgIT09XG5cdFx0XHRcdFx0XHRcdChiTWVzc2FnZS5leHRyYXMgJiYgYk1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGJNZXNzYWdlLmV4dHJhcy5kZWx0YS5mb3JtYXQpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRyZXR1cm4gUHJvdG9jb2xNZXNzYWdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm90b2NvbE1lc3NhZ2UpO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxudmFyIE1lc3NhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gTWVzc2FnZSgpIHtcblx0XHR0aGlzLm5hbWUgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lbmNvZGluZyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmV4dHJhcyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNpemUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRpZDogdGhpcy5pZCxcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuXHRcdFx0Y29ubmVjdGlvbklkOiB0aGlzLmNvbm5lY3Rpb25JZCxcblx0XHRcdGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcblx0XHRcdGVuY29kaW5nOiB0aGlzLmVuY29kaW5nLFxuXHRcdFx0ZXh0cmFzOiB0aGlzLmV4dHJhc1xuXHRcdH07XG5cblx0XHQvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcblx0XHQgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcblx0XHQgKiBjYWxsIGlmIGl0IGhhcyBhIG5vbi1lbXB0eSBhcmd1bWVudHMgbGlzdCAqL1xuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdGlmKGRhdGEgJiYgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSkge1xuXHRcdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Lyogc3RyaW5naWZ5IGNhbGwgKi9cblx0XHRcdFx0dmFyIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcblx0XHRcdFx0cmVzdWx0LmVuY29kaW5nID0gZW5jb2RpbmcgPyAoZW5jb2RpbmcgKyAnL2Jhc2U2NCcpIDogJ2Jhc2U2NCc7XG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZShkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIENhbGxlZCBieSBtc2dwYWNrLiB0b0J1ZmZlciByZXR1cm5zIGEgZGF0YXR5cGUgdW5kZXJzdGFuZGFibGUgYnlcblx0XHRcdFx0ICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XG5cdFx0XHRcdCAqIGluIGJyb3dzZXJzKSAqL1xuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b0J1ZmZlcihkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzdWx0LmRhdGEgPSBkYXRhO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0TWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tNZXNzYWdlJztcblx0XHRpZih0aGlzLm5hbWUpXG5cdFx0XHRyZXN1bHQgKz0gJzsgbmFtZT0nICsgdGhpcy5uYW1lO1xuXHRcdGlmKHRoaXMuaWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG5cdFx0aWYodGhpcy50aW1lc3RhbXApXG5cdFx0XHRyZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcblx0XHRpZih0aGlzLmNsaWVudElkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuXHRcdGlmKHRoaXMuY29ubmVjdGlvbklkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNvbm5lY3Rpb25JZD0nICsgdGhpcy5jb25uZWN0aW9uSWQ7XG5cdFx0aWYodGhpcy5lbmNvZGluZylcblx0XHRcdHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcblx0XHRpZih0aGlzLmV4dHJhcylcblx0XHRcdHJlc3VsdCArPSAnOyBleHRyYXMgPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4dHJhcyk7XG5cdFx0aWYodGhpcy5kYXRhKSB7XG5cdFx0XHRpZiAodHlwZW9mKHRoaXMuZGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG5cdFx0XHRlbHNlIGlmIChwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuZXh0cmFzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGV4dHJhcz0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRNZXNzYWdlLmVuY3J5cHQgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGRhdGEgPSBtc2cuZGF0YSxcblx0XHRcdGVuY29kaW5nID0gbXNnLmVuY29kaW5nLFxuXHRcdFx0Y2lwaGVyID0gb3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuXG5cdFx0ZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvJykgOiAnJztcblx0XHRpZighcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSkge1xuXHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOEVuY29kZShTdHJpbmcoZGF0YSkpO1xuXHRcdFx0ZW5jb2RpbmcgPSBlbmNvZGluZyArICd1dGYtOC8nO1xuXHRcdH1cblx0XHRjaXBoZXIuZW5jcnlwdChkYXRhLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bXNnLmRhdGEgPSBkYXRhO1xuXHRcdFx0bXNnLmVuY29kaW5nID0gZW5jb2RpbmcgKyAnY2lwaGVyKycgKyBjaXBoZXIuYWxnb3JpdGhtO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbXNnKTtcblx0XHR9KTtcblx0fTtcblxuXHRNZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uKG1zZywgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHR2YXIgZGF0YSA9IG1zZy5kYXRhLCBlbmNvZGluZyxcblx0XHRcdG5hdGl2ZURhdGFUeXBlID0gdHlwZW9mKGRhdGEpID09ICdzdHJpbmcnIHx8IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIW5hdGl2ZURhdGFUeXBlKSB7XG5cdFx0XHRpZiAoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc09iamVjdChkYXRhKSB8fCBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0bXNnLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0XHRcdFx0bXNnLmVuY29kaW5nID0gKGVuY29kaW5nID0gbXNnLmVuY29kaW5nKSA/IChlbmNvZGluZyArICcvanNvbicpIDogJ2pzb24nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkJywgNDAwMTMsIDQwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRNZXNzYWdlLmVuY3J5cHQobXNnLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG1zZyk7XG5cdFx0fVxuXHR9O1xuXG5cdE1lc3NhZ2UuZW5jb2RlQXJyYXkgPSBmdW5jdGlvbihtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHR2YXIgcHJvY2Vzc2VkID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRNZXNzYWdlLmVuY29kZShtZXNzYWdlc1tpXSwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBtc2cpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2Nlc3NlZCsrO1xuXHRcdFx0XHRpZiAocHJvY2Vzc2VkID09IG1lc3NhZ2VzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIG1lc3NhZ2VzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdE1lc3NhZ2Uuc2VyaWFsaXplID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5lbmNvZGVCb2R5O1xuXG5cdE1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24obWVzc2FnZSwgY29udGV4dCkge1xuXHRcdC8qIFRoZSBzZWNvbmQgYXJndW1lbnQgY291bGQgYmUgZWl0aGVyIEVuY29kaW5nRGVjb2RpbmdDb250ZXh0IHRoYXQgY29udGFpbnMgQ2hhbm5lbE9wdGlvbnMgb3IgQ2hhbm5lbE9wdGlvbnMgKi9cblx0XHRpZighY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xuXHRcdFx0dmFyIGNoYW5uZWxPcHRpb25zID0gY29udGV4dDtcblx0XHRcdGNvbnRleHQgPSB7XG5cdFx0XHRcdGNoYW5uZWxPcHRpb25zOiBjaGFubmVsT3B0aW9ucyxcblx0XHRcdFx0cGx1Z2luczogeyB9LFxuXHRcdFx0XHRiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciBsYXN0UGF5bG9hZCA9IG1lc3NhZ2UuZGF0YTtcblx0XHR2YXIgZW5jb2RpbmcgPSBtZXNzYWdlLmVuY29kaW5nO1xuXHRcdGlmKGVuY29kaW5nKSB7XG5cdFx0XHR2YXIgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoJy8nKSxcblx0XHRcdFx0bGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXgsIGVuY29kaW5nc1RvUHJvY2VzcyA9IHhmb3Jtcy5sZW5ndGgsXG5cdFx0XHRcdGRhdGEgPSBtZXNzYWdlLmRhdGE7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdoaWxlKChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9IGVuY29kaW5nc1RvUHJvY2VzcykgPiAwKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoID0geGZvcm1zWy0tZW5jb2RpbmdzVG9Qcm9jZXNzXS5tYXRjaCgvKFtcXC1cXHddKykoXFwrKFtcXHdcXC1dKykpPy8pO1xuXHRcdFx0XHRcdGlmKCFtYXRjaCkgYnJlYWs7XG5cdFx0XHRcdFx0dmFyIHhmb3JtID0gbWF0Y2hbMV07XG5cdFx0XHRcdFx0c3dpdGNoKHhmb3JtKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdiYXNlNjQnOlxuXHRcdFx0XHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjREZWNvZGUoU3RyaW5nKGRhdGEpKTtcblx0XHRcdFx0XHRcdFx0aWYobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdGxhc3RQYXlsb2FkID0gZGF0YTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGNhc2UgJ3V0Zi04Jzpcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOERlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRjYXNlICdqc29uJzpcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAnY2lwaGVyJzpcblx0XHRcdFx0XHRcdFx0aWYoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHhmb3JtQWxnb3JpdGhtID0gbWF0Y2hbM10sIGNpcGhlciA9IGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcjtcblx0XHRcdFx0XHRcdFx0XHQvKiBkb24ndCBhdHRlbXB0IHRvIGRlY3J5cHQgdW5sZXNzIHRoZSBjaXBoZXIgcGFyYW1zIGFyZSBjb21wYXRpYmxlICovXG5cdFx0XHRcdFx0XHRcdFx0aWYoeGZvcm1BbGdvcml0aG0gIT0gY2lwaGVyLmFsZ29yaXRobSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIHdpdGggZ2l2ZW4gY2lwaGVyOyBpbmNvbXBhdGlibGUgY2lwaGVyIHBhcmFtcycpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gY2lwaGVyLmRlY3J5cHQoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlOyBub3QgYW4gZW5jcnlwdGVkIGNoYW5uZWwnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FzZSAndmNkaWZmJzpcblx0XHRcdFx0XHRcdFx0aWYoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01pc3NpbmcgVmNkaWZmIGRlY29kZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5LWZvcmtzL3ZjZGlmZi1kZWNvZGVyKScsIDQwMDE5LCA0MDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0RlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSknLCA0MDAyMCwgNDAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBkZWx0YUJhc2UgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWx0YUJhc2UgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiB2Y2RpZmYgZXhwZWN0cyBVaW50OEFycmF5cywgY2FuJ3QgY29weSB3aXRoIEFycmF5QnVmZmVycy4gKGFsc28sIGlmIHdlXG5cdFx0XHRcdFx0XHRcdFx0ICogZG9uJ3QgaGF2ZSBhIFRleHREZWNvZGVyLCBkZWx0YUJhc2UgbWlnaHQgYmUgYSBXb3JkQXJyYXkgaGVyZSwgc28gbmVlZFxuXHRcdFx0XHRcdFx0XHRcdCAqIHRvIHByb2Nlc3MgaXQgaW50byBhIGJ1ZmZlciBhbnl3YXkpICovXG5cdFx0XHRcdFx0XHRcdFx0ZGVsdGFCYXNlID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b0J1ZmZlcihkZWx0YUJhc2UpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udHlwZWRBcnJheVRvQnVmZmVyKGNvbnRleHQucGx1Z2lucy52Y2RpZmYuZGVjb2RlKGRhdGEsIGRlbHRhQmFzZSkpO1xuXHRcdFx0XHRcdFx0XHRcdGxhc3RQYXlsb2FkID0gZGF0YTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVmNkaWZmIGRlbHRhIGRlY29kZSBmYWlsZWQgd2l0aCAnICsgZSwgNDAwMTgsIDQwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0Vycm9yIHByb2Nlc3NpbmcgdGhlICcgKyB4Zm9ybSArICcgZW5jb2RpbmcsIGRlY29kZXIgcmV0dXJuZWQg4oCYJyArIGUubWVzc2FnZSArICfigJknLCBlLmNvZGUgfHwgNDAwMTMsIDQwMCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRtZXNzYWdlLmVuY29kaW5nID0gKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4IDw9IDApID8gbnVsbCA6IHhmb3Jtcy5zbGljZSgwLCBsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCkuam9pbignLycpO1xuXHRcdFx0XHRtZXNzYWdlLmRhdGEgPSBkYXRhO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkID0gbGFzdFBheWxvYWQ7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XG5cdFx0aWYoZm9ybWF0KSB7XG5cdFx0XHRib2R5ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtc2cgPSBib2R5W2ldID0gTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0pO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0TWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJvZHk7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IE1lc3NhZ2UoKSwgdmFsdWVzKTtcblx0fTtcblxuXHRNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlciAmJiAhb3B0aW9ucy5jaXBoZXIuY2hhbm5lbENpcGhlcikge1xuXHRcdFx0aWYoIXBsYXRmb3JtX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuXHRcdFx0dmFyIGNpcGhlciA9IHBsYXRmb3JtX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldENpcGhlcihvcHRpb25zLmNpcGhlcik7XG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG5cdFx0XHRvcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBjaXBoZXIuY2lwaGVyO1xuXHRcdH1cblx0fVxuXG5cdE1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbihlbmNvZGVkLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1zZyA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcblx0XHRub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpO1xuXHRcdC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG5cdFx0ICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXG5cdFx0dHJ5IHtcblx0XHRcdE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1zZztcblx0fTtcblxuXHRNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbihlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcblx0XHRub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpO1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyck1hcChlbmNvZGVkQXJyYXksIGZ1bmN0aW9uKGVuY29kZWQpIHtcblx0XHRcdHJldHVybiBNZXNzYWdlLmZyb21FbmNvZGVkKGVuY29kZWQsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xuXHRcdHZhciBzaXplID0gMDtcblx0XHRpZihtc2cubmFtZSkge1xuXHRcdFx0c2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XG5cdFx0fVxuXHRcdGlmKG1zZy5jbGllbnRJZCkge1xuXHRcdFx0c2l6ZSArPSBtc2cuY2xpZW50SWQubGVuZ3RoO1xuXHRcdH1cblx0XHRpZihtc2cuZXh0cmFzKSB7XG5cdFx0XHRzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcblx0XHR9XG5cdFx0aWYobXNnLmRhdGEpIHtcblx0XHRcdHNpemUgKz0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kYXRhU2l6ZUJ5dGVzKG1zZy5kYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNpemU7XG5cdH07XG5cblx0LyogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9uIGVuY29kZSgpZCAoYW5kIGVuY3J5cHQoKWQpIE1lc3NhZ2VzIChhcyBpdFxuXHQgKiBhc3N1bWVzIHRoZSBkYXRhIGlzIGEgc3RyaW5nIG9yIGJ1ZmZlcikgKi9cblx0TWVzc2FnZS5nZXRNZXNzYWdlc1NpemUgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdHZhciBtc2csIHRvdGFsID0gMDtcblx0XHRmb3IodmFyIGk9MDsgaTxtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bXNnID0gbWVzc2FnZXNbaV07XG5cdFx0XHR0b3RhbCArPSAobXNnLnNpemUgfHwgKG1zZy5zaXplID0gZ2V0TWVzc2FnZVNpemUobXNnKSkpXG5cdFx0fVxuXHRcdHJldHVybiB0b3RhbDtcblx0fTtcblxuXHRyZXR1cm4gTWVzc2FnZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTWVzc2FnZSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBDaGVjayBpZiB0eXBlZCBhcnJheXMgYXJlIHN1cHBvcnRlZFxuXHQgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XG5cdCAgICB2YXIgc3VwZXJJbml0ID0gV29yZEFycmF5LmluaXQ7XG5cblx0ICAgIC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xuXHQgICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdCAgICAgICAgLy8gQ29udmVydCBidWZmZXJzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuXHQgICAgICAgICAgICAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcblx0ICAgICAgICApIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIEV4dHJhY3QgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxuXHQgICAgICAgICAgICBzdXBlckluaXQuY2FsbCh0aGlzLCB3b3JkcywgdHlwZWRBcnJheUJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEVsc2UgY2FsbCBub3JtYWwgaW5pdFxuXHQgICAgICAgICAgICBzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBzdWJJbml0LnByb3RvdHlwZSA9IFdvcmRBcnJheTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cblxuXG5cblxudmFyIFByZXNlbmNlTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gdG9BY3Rpb25WYWx1ZShhY3Rpb25TdHJpbmcpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zLCBhY3Rpb25TdHJpbmcpXG5cdH1cblxuXHRmdW5jdGlvbiBQcmVzZW5jZU1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVuY29kaW5nID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc2l6ZSA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zID0gW1xuXHRcdCdhYnNlbnQnLFxuXHRcdCdwcmVzZW50Jyxcblx0XHQnZW50ZXInLFxuXHRcdCdsZWF2ZScsXG5cdFx0J3VwZGF0ZSdcblx0XTtcblxuXHQvKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBwcmVzZW5jZU1lc3NhZ2UgaXMgc3ludGhlc2l6ZWQsIGkuZS4gd2FzIG5vdCBhY3R1YWxseVxuXHQgKiBzZW50IGJ5IHRoZSBjb25uZWN0aW9uICh1c3VhbGx5IG1lYW5zIGEgbGVhdmUgZXZlbnQgc2VudCAxNXMgYWZ0ZXIgYVxuXHQgKiBkaXNjb25uZWN0aW9uKS4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBzeW50aGVzaXplZCBtZXNzYWdlcyBjYW5ub3QgYmVcblx0ICogY29tcGFyZWQgZm9yIG5ld25lc3MgYnkgaWQgbGV4aWNvZ3JhcGhpY2FsbHkgLSBSVFAyYjFcblx0ICovXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUuaXNTeW50aGVzaXplZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlkLnN1YnN0cmluZyh0aGlzLmNvbm5lY3Rpb25JZC5sZW5ndGgsIDApICE9PSB0aGlzLmNvbm5lY3Rpb25JZDtcblx0fTtcblxuXHQvKiBSVFAyYjIgKi9cblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS5wYXJzZUlkID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5pZC5zcGxpdCgnOicpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb25uZWN0aW9uSWQ6IHBhcnRzWzBdLFxuXHRcdFx0bXNnU2VyaWFsOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuXHRcdFx0aW5kZXg6IHBhcnNlSW50KHBhcnRzWzJdLCAxMClcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG5cdFx0XHQvKiBDb252ZXJ0IHByZXNlbmNlIGFjdGlvbiBiYWNrIHRvIGFuIGludCBmb3Igc2VuZGluZyB0byBBYmx5ICovXG5cdFx0XHRhY3Rpb246IHRvQWN0aW9uVmFsdWUodGhpcy5hY3Rpb24pLFxuXHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2Rpbmdcblx0XHR9O1xuXG5cdFx0LyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG5cdFx0ICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG5cdFx0ICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRpZihkYXRhICYmIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8qIHN0cmluZ2lmeSBjYWxsICovXG5cdFx0XHRcdHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG5cdFx0XHRcdHJlc3VsdC5lbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy9iYXNlNjQnKSA6ICdiYXNlNjQnO1xuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUoZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG5cdFx0XHRcdCAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxuXHRcdFx0XHQgKiBpbiBicm93c2VycykgKi9cblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc3VsdC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tQcmVzZW5jZU1lc3NhZ2UnO1xuXHRcdHJlc3VsdCArPSAnOyBhY3Rpb249JyArIHRoaXMuYWN0aW9uO1xuXHRcdGlmKHRoaXMuaWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG5cdFx0aWYodGhpcy50aW1lc3RhbXApXG5cdFx0XHRyZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcblx0XHRpZih0aGlzLmNsaWVudElkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuXHRcdGlmKHRoaXMuY29ubmVjdGlvbklkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNvbm5lY3Rpb25JZD0nICsgdGhpcy5jb25uZWN0aW9uSWQ7XG5cdFx0aWYodGhpcy5lbmNvZGluZylcblx0XHRcdHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcblx0XHRpZih0aGlzLmRhdGEpIHtcblx0XHRcdGlmICh0eXBlb2YodGhpcy5kYXRhKSA9PSAnc3RyaW5nJylcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcblx0XHRcdGVsc2UgaWYgKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIodGhpcy5kYXRhKSlcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChqc29uKT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKTtcblx0XHR9XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRQcmVzZW5jZU1lc3NhZ2UuZW5jb2RlID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5lbmNvZGU7XG5cdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUgPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdCkge1xuXHRcdFx0Ym9keSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdH1cblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbXNnID0gYm9keVtpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKGJvZHlbaV0sIHRydWUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBib2R5O1xuXHR9O1xuXG5cdC8qIENyZWF0ZXMgYSBQcmVzZW5jZU1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgdmFsdWVzLCB3aXRoIGEgc3RyaW5nIHByZXNlbmNlIGFjdGlvbiAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKSB7XG5cdFx0aWYoc3RyaW5naWZ5QWN0aW9uKSB7XG5cdFx0XHR2YWx1ZXMuYWN0aW9uID0gUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnNbdmFsdWVzLmFjdGlvbl1cblx0XHR9XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByZXNlbmNlTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24oZW5jb2RlZCwgb3B0aW9ucykge1xuXHRcdHZhciBtc2cgPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkLCB0cnVlKTtcblx0XHQvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuXHRcdCAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuXHRcdHRyeSB7XG5cdFx0XHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbXNnO1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24oZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyTWFwKGVuY29kZWRBcnJheSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRcdFx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRNZXNzYWdlc1NpemU7XG5cblx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJlc2VuY2VNZXNzYWdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHs7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LypnbG9iYWxzIHdpbmRvdywgZ2xvYmFsLCByZXF1aXJlKi9cblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblxuXHQgICAgdmFyIGNyeXB0bztcblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93LmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiBcImZ1bmN0aW9uXCIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblx0ICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICB9XG5cblx0ICAgIC8qXG5cdCAgICAgKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Jcblx0ICAgICAqXG5cdCAgICAgKiBBcyBNYXRoLnJhbmRvbSgpIGlzIGNyeXB0b2dyYXBoaWNhbGx5IG5vdCBzYWZlIHRvIHVzZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3J5cHRvU2VjdXJlUmFuZG9tSW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmIChjcnlwdG8pIHtcblx0ICAgICAgICAgICAgLy8gVXNlIGdldFJhbmRvbVZhbHVlcyBtZXRob2QgKEJyb3dzZXIpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXNlIHJhbmRvbUJ5dGVzIG1ldGhvZCAoTm9kZUpTKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRJbnQzMkxFKCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBjcnlwdG8gbW9kdWxlIGNvdWxkIG5vdCBiZSB1c2VkIHRvIGdldCBzZWN1cmUgcmFuZG9tIG51bWJlci4nKTtcblx0ICAgIH07XG5cblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsbCBvZiBPYmplY3QuY3JlYXRlXG5cblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge31cblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cblxudmFyIENvbm5lY3Rpb25FcnJvciA9IHtcblx0ZGlzY29ubmVjdGVkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDAzLFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZSdcblx0fSksXG5cdHN1c3BlbmRlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAwMixcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdW5hdmFpbGFibGUnXG5cdH0pLFxuXHRmYWlsZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMDAsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXInXG5cdH0pLFxuXHRjbG9zaW5nOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDE3LFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NpbmcnXG5cdH0pLFxuXHRjbG9zZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMTcsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2VkJ1xuXHR9KSxcblx0dW5rbm93bkNvbm5lY3Rpb25FcnI6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA1MDAsXG5cdFx0Y29kZTogNTAwMDIsXG5cdFx0bWVzc2FnZTogJ0ludGVybmFsIGNvbm5lY3Rpb24gZXJyb3InXG5cdH0pLFxuXHR1bmtub3duQ2hhbm5lbEVycjogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDUwMCxcblx0XHRjb2RlOiA1MDAwMSxcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY2hhbm5lbCBlcnJvcidcblx0fSlcbn07XG5cbkNvbm5lY3Rpb25FcnJvci5pc1JldHJpYWJsZSA9IGZ1bmN0aW9uKGVycikge1xuXHRpZiAoIWVyci5zdGF0dXNDb2RlIHx8ICFlcnIuY29kZSB8fCBlcnIuc3RhdHVzQ29kZSA+PSA1MDApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHR2YXIgcmV0cmlhYmxlID0gZmFsc2U7XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0udmFsdWVzQXJyYXkoQ29ubmVjdGlvbkVycm9yKS5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5FcnIpIHtcblx0XHRpZiAoY29ubkVyci5jb2RlICYmIGNvbm5FcnIuY29kZSA9PSBlcnIuY29kZSkge1xuXHRcdFx0cmV0cmlhYmxlID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcmV0cmlhYmxlO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25uZWN0aW9uRXJyb3IpO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvaHR0cC5qc1xudmFyIGh0dHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL211bHRpY2FzdGVyLmpzXG52YXIgbXVsdGljYXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYnVmZmVydXRpbHMuanNcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby5qc1xudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9iYXNlNjQuanNcbi8qXG4gQ29weXJpZ2h0IChjKSAyMDA4IEZyZWQgUGFsbWVyIGZyZWQucGFsbWVyX2F0X2dtYWlsLmNvbVxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBCYXNlNjQgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIFN0cmluZ0J1ZmZlcigpXG5cdHtcblx0XHR0aGlzLmJ1ZmZlciA9IFtdO1xuXHR9XG5cblx0U3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyaW5nKVxuXHR7XG5cdFx0dGhpcy5idWZmZXIucHVzaChzdHJpbmcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdFN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5idWZmZXIuam9pbihcIlwiKTtcblx0fTtcblxuXHR2YXIgQmFzZTY0ID1cblx0e1xuXHRcdGNvZGV4IDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuXG5cdFx0ZW5jb2RlIDogZnVuY3Rpb24gKGlucHV0KVxuXHRcdHtcblx0XHRcdHZhciBvdXRwdXQgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG5cdFx0XHR2YXIgY29kZXggPSBCYXNlNjQuY29kZXg7XG5cblx0XHRcdHZhciBlbnVtZXJhdG9yID0gbmV3IFV0ZjhFbmNvZGVFbnVtZXJhdG9yKGlucHV0KTtcblx0XHRcdHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjaHIxID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0dmFyIGNocjIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHR2YXIgY2hyMyA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHR2YXIgZW5jMSA9IGNocjEgPj4gMjtcblx0XHRcdFx0dmFyIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuXHRcdFx0XHR2YXIgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuXHRcdFx0XHR2YXIgZW5jNCA9IGNocjMgJiA2MztcblxuXHRcdFx0XHRpZiAoaXNOYU4oY2hyMikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmMzID0gZW5jNCA9IDY0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGlzTmFOKGNocjMpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jNCA9IDY0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3V0cHV0LmFwcGVuZChjb2RleC5jaGFyQXQoZW5jMSkgKyBjb2RleC5jaGFyQXQoZW5jMikgKyBjb2RleC5jaGFyQXQoZW5jMykgKyBjb2RleC5jaGFyQXQoZW5jNCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0LnRvU3RyaW5nKCk7XG5cdFx0fSxcblxuXHRcdGRlY29kZSA6IGZ1bmN0aW9uIChpbnB1dClcblx0XHR7XG5cdFx0XHR2YXIgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuXG5cdFx0XHR2YXIgZW51bWVyYXRvciA9IG5ldyBCYXNlNjREZWNvZGVFbnVtZXJhdG9yKGlucHV0KTtcblx0XHRcdHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjaGFyQ29kZSA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSk7XG5cdFx0XHRcdGVsc2UgaWYgKChjaGFyQ29kZSA+IDE5MSkgJiYgKGNoYXJDb2RlIDwgMjI0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0XHR2YXIgY2hhckNvZGUyID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY2hhckNvZGUgJiAzMSkgPDwgNikgfCAoY2hhckNvZGUyICYgNjMpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMyA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRcdG91dHB1dC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNoYXJDb2RlICYgMTUpIDw8IDEyKSB8ICgoY2hhckNvZGUyICYgNjMpIDw8IDYpIHwgKGNoYXJDb2RlMyAmIDYzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gVXRmOEVuY29kZUVudW1lcmF0b3IoaW5wdXQpXG5cdHtcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdHRoaXMuX2luZGV4ID0gLTE7XG5cdFx0dGhpcy5fYnVmZmVyID0gW107XG5cdH1cblxuXHRVdGY4RW5jb2RlRW51bWVyYXRvci5wcm90b3R5cGUgPVxuXHR7XG5cdFx0Y3VycmVudDogTnVtYmVyLk5hTixcblxuXHRcdG1vdmVOZXh0OiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLl9pbmRleCA+PSAodGhpcy5faW5wdXQubGVuZ3RoIC0gMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IE51bWJlci5OYU47XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gdGhpcy5faW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuX2luZGV4KTtcblxuXHRcdFx0XHQvLyBcIlxcclxcblwiIC0+IFwiXFxuXCJcblx0XHRcdFx0Ly9cblx0XHRcdFx0aWYgKChjaGFyQ29kZSA9PSAxMykgJiYgKHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKSA9PSAxMCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjaGFyQ29kZSA9IDEwO1xuXHRcdFx0XHRcdHRoaXMuX2luZGV4ICs9IDI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBjaGFyQ29kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICgoY2hhckNvZGUgPiAxMjcpICYmIChjaGFyQ29kZSA8IDIwNDgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gKGNoYXJDb2RlID4+IDYpIHwgMTkyO1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKChjaGFyQ29kZSAmIDYzKSB8IDEyOCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gKGNoYXJDb2RlID4+IDEyKSB8IDIyNDtcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoKGNoYXJDb2RlID4+IDYpICYgNjMpIHwgMTI4KTtcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoY2hhckNvZGUgJiA2MykgfCAxMjgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpXG5cdHtcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdHRoaXMuX2luZGV4ID0gLTE7XG5cdFx0dGhpcy5fYnVmZmVyID0gW107XG5cdH1cblxuXHRCYXNlNjREZWNvZGVFbnVtZXJhdG9yLnByb3RvdHlwZSA9XG5cdHtcblx0XHRjdXJyZW50OiA2NCxcblxuXHRcdG1vdmVOZXh0OiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLl9pbmRleCA+PSAodGhpcy5faW5wdXQubGVuZ3RoIC0gMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IDY0O1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbmMxID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblx0XHRcdFx0dmFyIGVuYzIgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXHRcdFx0XHR2YXIgZW5jMyA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cdFx0XHRcdHZhciBlbmM0ID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblxuXHRcdFx0XHR2YXIgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG5cdFx0XHRcdHZhciBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG5cdFx0XHRcdHZhciBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IGNocjE7XG5cblx0XHRcdFx0aWYgKGVuYzMgIT0gNjQpXG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goY2hyMik7XG5cblx0XHRcdFx0aWYgKGVuYzQgIT0gNjQpXG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goY2hyMyk7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlNjQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXNlNjQgPSAoQmFzZTY0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYnVpbGQvaG1hYy1zaGEyNTYuanNcbnZhciBobWFjX3NoYTI1NiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGhtYWNfc2hhMjU2X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGhtYWNfc2hhMjU2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYnVpbGQvZW5jLWJhc2U2NC5qc1xudmFyIGVuY19iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9hdXRoLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGF1dGhfQXV0aCA9IChmdW5jdGlvbigpIHtcblx0dmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRmdW5jdGlvbiByYW5kb20oKSB7IHJldHVybiAoJzAwMDAwMCcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxRTE2KSkuc2xpY2UoLTE2KTsgfVxuXHRmdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcblx0XHQvKiBBIGNsaWVudCBhdXRoIGNhbGxiYWNrIG1heSBnaXZlIGVycm9ycyBpbiBhbnkgbnVtYmVyIG9mIGZvcm1hdHM7IG5vcm1hbGlzZSB0byBhbiBlcnJvcmluZm8gKi9cblx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNFcnJvckluZm8oZXJyKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10odXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuXHRcdH1cblx0XHQvKiBuZXR3b3JrIGVycm9ycyB3aWxsIG5vdCBoYXZlIGFuIGluaGVyZW50IGVycm9yIGNvZGUgKi9cblx0XHRpZighZXJyLmNvZGUpIHtcblx0XHRcdGlmKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcblx0XHRcdFx0ZXJyLmNvZGUgPSA0MDMwMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVyci5jb2RlID0gNDAxNzA7XG5cdFx0XHRcdC8qIG5vcm1hbGlzZSBzdGF0dXNDb2RlIHRvIDQwMSBwZXIgUlNBNGUgKi9cblx0XHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSA0MDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlcnI7XG5cdH1cblxuXHR2YXIgaG1hYywgdG9CYXNlNjQ7XG5cdGlmKHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlSG1hYykge1xuXHRcdHRvQmFzZTY0ID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiAoQnVmZmVyLmZyb20oc3RyLCAnYXNjaWknKSkudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9O1xuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcblx0XHRcdHZhciBpbnN0ID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVIbWFjKCdTSEEyNTYnLCBrZXkpO1xuXHRcdFx0aW5zdC51cGRhdGUodGV4dCk7XG5cdFx0XHRyZXR1cm4gaW5zdC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dG9CYXNlNjQgPSBiYXNlNjQuZW5jb2RlO1xuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcblx0XHRcdHJldHVybiBPYmplY3QoZW5jX2Jhc2U2NFtcInN0cmluZ2lmeVwiXSkoaG1hY19zaGEyNTZfZGVmYXVsdCgpKHRleHQsIGtleSkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcblx0XHRpZighY2FwYWJpbGl0eSlcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGlmKHR5cGVvZihjYXBhYmlsaXR5KSA9PSAnc3RyaW5nJylcblx0XHRcdGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuXG5cdFx0dmFyIGMxNG5DYXBhYmlsaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR2YXIga2V5cyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmtleXNBcnJheShjYXBhYmlsaXR5LCB0cnVlKTtcblx0XHRpZigha2V5cylcblx0XHRcdHJldHVybiAnJztcblx0XHRrZXlzLnNvcnQoKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YzE0bkNhcGFiaWxpdHlba2V5c1tpXV0gPSBjYXBhYmlsaXR5W2tleXNbaV1dLnNvcnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGMxNG5DYXBhYmlsaXR5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKGF1dGhPcHRpb25zKSB7XG5cdFx0aWYoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIHN1cHBsaWVkIHRva2VuIG9ubHknKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG1zZyA9ICdhdXRoT3B0aW9ucyBtdXN0IGluY2x1ZGUgdmFsaWQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyc7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzaWNBdXRoRm9yY2VkKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gJ3VzZVRva2VuQXV0aCcgaW4gb3B0aW9ucyAmJiAhb3B0aW9ucy51c2VUb2tlbkF1dGg7XG5cdH1cblxuXHQvKiBSU0E0ICovXG5cdGZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMudXNlVG9rZW5BdXRoIHx8XG5cdFx0XHQoIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJlxuXHRcdFx0IChvcHRpb25zLmF1dGhDYWxsYmFjayB8fFxuXHRcdFx0ICBvcHRpb25zLmF1dGhVcmwgICAgICB8fFxuXHRcdFx0ICBvcHRpb25zLnRva2VuICAgICAgICB8fFxuXHRcdFx0ICBvcHRpb25zLnRva2VuRGV0YWlscykpXG5cdH1cblxuXHQvKiBSU0E0YSAqL1xuXHRmdW5jdGlvbiBub1dheVRvUmVuZXcob3B0aW9ucykge1xuXHRcdHJldHVybiAhb3B0aW9ucy5rZXkgJiZcblx0XHRcdCFvcHRpb25zLmF1dGhDYWxsYmFjayAmJlxuXHRcdFx0IW9wdGlvbnMuYXV0aFVybDtcblx0fVxuXG5cdHZhciB0cklkID0gMDtcblx0ZnVuY3Rpb24gZ2V0VG9rZW5SZXF1ZXN0SWQoKSB7XG5cdFx0cmV0dXJuIHRySWQrKztcblx0fVxuXG5cdGZ1bmN0aW9uIEF1dGgoY2xpZW50LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG5cdFx0dGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuXHRcdC8qIFRoZSBpZCBvZiB0aGUgY3VycmVudCB0b2tlbiByZXF1ZXN0IGlmIG9uZSBpcyBpbiBwcm9ncmVzcywgZWxzZSBudWxsICovXG5cdFx0dGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBudWxsO1xuXHRcdHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZih1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcblx0XHRcdC8qIFRva2VuIGF1dGggKi9cblx0XHRcdGlmKG9wdGlvbnMua2V5ICYmICFobWFjKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnY2xpZW50LXNpZGUgdG9rZW4gcmVxdWVzdCBzaWduaW5nIG5vdCBzdXBwb3J0ZWQnO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHRcdH1cblx0XHRcdGlmKG5vV2F5VG9SZW5ldyhvcHRpb25zKSkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCAnV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHAnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NhdmVUb2tlbk9wdGlvbnMob3B0aW9ucy5kZWZhdWx0VG9rZW5QYXJhbXMsIG9wdGlvbnMpO1xuXHRcdFx0bG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIEJhc2ljIGF1dGggKi9cblx0XHRcdGlmKCFvcHRpb25zLmtleSkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ05vIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnMgcHJvdmlkZWQ7IG5lZWQgb25lIG9mOiBrZXksIGF1dGhVcmwsIG9yIGF1dGhDYWxsYmFjayAob3IgZm9yIHRlc3Rpbmcgb25seSwgdG9rZW4gb3IgdG9rZW5EZXRhaWxzKSc7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE2MCwgNDAxKTtcblx0XHRcdH1cblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICdhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGgnKTtcblx0XHRcdHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RydWN0cyB0aGUgbGlicmFyeSB0byBnZXQgYSB0b2tlbiBpbW1lZGlhdGVseSBhbmQgZW5zdXJlcyBUb2tlbiBBdXRoXG5cdCAqIGlzIHVzZWQgZm9yIGFsbCBmdXR1cmUgcmVxdWVzdHMsIHN0b3JpbmcgdGhlIHRva2VuUGFyYW1zIGFuZCBhdXRoT3B0aW9uc1xuXHQgKiBnaXZlbiBhcyB0aGUgbmV3IGRlZmF1bHRzIGZvciBzdWJzZXF1ZW50IHVzZS5cblx0ICpcblx0ICogQHBhcmFtIHRva2VuUGFyYW1zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuXHQgKlxuXHQgKiAtIHR0bDogICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIGFueSBuZXcgdG9rZW4gaW4gbXMuIElmIG5vbmVcblx0ICogICAgICAgICAgICAgICBpcyBzcGVjaWZpZWQgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWVcblx0ICogICAgICAgICAgICAgICBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdCBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZFxuXHQgKiAgICAgICAgICAgICAgIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIC0gY2FwYWJpbGl0eTogKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuXHQgKiAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuXHQgKiAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cblx0ICpcblx0ICogLSBjbGllbnRJZDogICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlblxuXHQgKlxuXHQgKiAtIHRpbWVzdGFtcDogIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcblx0ICogICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cblx0ICpcblx0ICogQHBhcmFtIGF1dGhPcHRpb25zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIGF1dGggb3B0aW9ucyByZWxldmFudCB0byB0b2tlbiBhdXRoOlxuXHQgKlxuXHQgKiAtIHF1ZXJ5VGltZSAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIEFibHkgc3lzdGVtIHNob3VsZCBiZVxuXHQgKiAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LlxuXHQgKlxuXHQgKiAtIHRva2VuRGV0YWlsczogKG9wdGlvbmFsKSBvYmplY3Q6IEFuIGF1dGhlbnRpY2F0ZWQgVG9rZW5EZXRhaWxzIG9iamVjdC5cblx0ICpcblx0ICogLSB0b2tlbjogICAgICAgIChvcHRpb25hbCkgc3RyaW5nOiB0aGUgYHRva2VuYCBwcm9wZXJ0eSBvZiBhIHRva2VuRGV0YWlscyBvYmplY3Rcblx0ICpcblx0ICogLSBhdXRoQ2FsbGJhY2s6ICAob3B0aW9uYWwpIGEgSmF2YVNjcmlwdCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdG8gZ2V0IGF1dGggaW5mb3JtYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICAgYXV0aENhbGxiYWNrIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9mICh0b2tlblBhcmFtcywgY2FsbGJhY2spIHRoYXQgY2FsbHNcblx0ICogICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgd2l0aCAoZXJyLCByZXN1bHQpLCB3aGVyZSByZXN1bHQgaXMgYW55IG9mOlxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlblJlcXVlc3Qgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLmNyZWF0ZVRva2VuUmVxdWVzdCBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5yZXF1ZXN0VG9rZW4gY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuIHN0cmluZ1xuXHQgKlxuXHQgKiAtIGF1dGhVcmw6ICAgICAgIChvcHRpb25hbCkgYSBVUkwgdG8gYmUgdXNlZCB0byBHRVQgb3IgUE9TVCBhIHNldCBvZiB0b2tlbiByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgcGFyYW1zLCB0byBvYnRhaW4gYSBzaWduZWQgdG9rZW4gcmVxdWVzdC5cblx0ICpcblx0ICogLSBhdXRoSGVhZGVyczogICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhlYWRlcnMgdG8gYmUgYWRkZWQgdG8gYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKiAtIGF1dGhQYXJhbXM6ICAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgcXVlcnkgcGFyYW1zIHRvIGJlIGFkZGVkIHRvIGFueVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3QgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICpcblx0ICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxuXHQgKlxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgdG9rZW5EZXRhaWxzKVxuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG5cdFx0aWYodHlwZW9mKHRva2VuUGFyYW1zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSB0b2tlblBhcmFtcztcblx0XHRcdGF1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnYXV0aG9yaXplJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogUlNBMTBhOiBhdXRob3JpemUoKSBjYWxsIGltcGxpZXMgdG9rZW4gYXV0aC4gSWYgYSBrZXkgaXMgcGFzc2VkIGl0LCB3ZVxuXHRcdCAqIGp1c3QgY2hlY2sgaWYgaXQgZG9lc24ndCBjbGFzaCBhbmQgYXNzdW1lIHdlJ3JlIGdlbmVyYXRpbmcgYSB0b2tlbiBmcm9tIGl0ICovXG5cdFx0aWYoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMua2V5ICYmICh0aGlzLmF1dGhPcHRpb25zLmtleSAhPT0gYXV0aE9wdGlvbnMua2V5KSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5JywgNDAxMDIsIDQwMSk7XG5cdFx0fVxuXG5cdFx0aWYoYXV0aE9wdGlvbnMgJiYgKCdmb3JjZScgaW4gYXV0aE9wdGlvbnMpKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLmF1dGhvcml6ZScsICdEZXByZWNhdGlvbiB3YXJuaW5nOiBzcGVjaWZ5aW5nIHtmb3JjZTogdHJ1ZX0gaW4gYXV0aE9wdGlvbnMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSwgYXV0aG9yaXplKCkgbm93IGFsd2F5cyBnZXRzIGEgbmV3IHRva2VuLiBQbGVhc2UgcmVtb3ZlIHRoaXMsIGFzIGluIHZlcnNpb24gMS4wIGFuZCBsYXRlciwgaGF2aW5nIGEgbm9uLW51bGwgYXV0aE9wdGlvbnMgd2lsbCBvdmVyd3JpdGUgc3RvcmVkIGxpYnJhcnkgYXV0aE9wdGlvbnMsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudCcpO1xuXHRcdFx0LyogRW11bGF0ZSB0aGUgb2xkIGJlaGF2aW91cjogaWYgJ2ZvcmNlJyB3YXMgdGhlIG9ubHkgbWVtYmVyIG9mIGF1dGhPcHRpb25zLFxuXHRcdFx0ICogc2V0IGl0IHRvIG51bGwgc28gaXQgZG9lc24ndCBvdmVyd3JpdGUgc3RvcmVkLiBUT0RPOiByZW1vdmUgaW4gdmVyc2lvbiAxLjAgKi9cblx0XHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT25seVByb3BJbihhdXRoT3B0aW9ucywgJ2ZvcmNlJykpIHtcblx0XHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGlmKHNlbGYuY2xpZW50LmNvbm5lY3Rpb24pIHtcblx0XHRcdFx0XHQvKiBXZSBpbnRlcnByZXQgUlNBNGQgYXMgaW5jbHVkaW5nIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgbGliIHRvXG5cdFx0XHRcdFx0ICogYXV0aGVudGljYXRlIHRyaWdnZXJlZCBieSBhbiBleHBsaWNpdCBhdXRob3JpemUoKSBvciBhbiBBVVRIIHJlY2VpdmVkIGZyb21cblx0XHRcdFx0XHQgKiBhYmx5LCBub3QganVzdCBjb25uZWN0LXNlcXVlbmNlLXRyaWdnZXJlZCB0b2tlbiBmZXRjaGVzICovXG5cdFx0XHRcdFx0c2VsZi5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogUlRDOFxuXHRcdFx0ICogLSBXaGVuIGF1dGhvcml6ZSBjYWxsZWQgYnkgYW4gZW5kIHVzZXIgYW5kIGhhdmUgYSByZWFsdGltZSBjb25uZWN0aW9uLFxuXHRcdFx0ICogZG9uJ3QgY2FsbCBiYWNrIHRpbGwgbmV3IHRva2VuIGhhcyB0YWtlbiBlZmZlY3QuXG5cdFx0XHQgKiAtIFVzZSBzZWxmLmNsaWVudC5jb25uZWN0aW9uIGFzIGEgcHJveHkgZm9yIChzZWxmLmNsaWVudCBpbnN0YW5jZW9mIFJlYWx0aW1lKSxcblx0XHRcdCAqIHdoaWNoIGRvZXNuJ3Qgd29yayBpbiBub2RlIGFzIFJlYWx0aW1lIGlzbid0IHBhcnQgb2YgdGhlIHZtIGNvbnRleHQgZm9yIFJlc3QgY2xpZW50cyAqL1xuXHRcdFx0aWYoc2VsZi5jbGllbnQuY29ubmVjdGlvbikge1xuXHRcdFx0XHRzZWxmLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuYXV0aG9yaXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ0F1dGguYXV0aG9yaXNlJywgJ0F1dGguYXV0aG9yaXplJyk7XG5cdFx0dGhpcy5hdXRob3JpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHQvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXG5cdCAqIGFzIHNvb24gYXMgd2UgaGF2ZSB0aGUgbmV3IHRva2VuLCByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBpdCB0byB0YWtlXG5cdCAqIGVmZmVjdCBvbiB0aGUgY29ubmVjdGlvbiBhcyAjYXV0aG9yaXplIGRvZXMgKi9cblx0QXV0aC5wcm90b3R5cGUuX2ZvcmNlTmV3VG9rZW4gPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogZ2V0IHJpZCBvZiBjdXJyZW50IHRva2VuIGV2ZW4gaWYgc3RpbGwgdmFsaWQgKi9cblx0XHR0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG5cblx0XHQvKiBfc2F2ZSBub3JtYWxpc2VzIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnMgYW5kIHVwZGF0ZXMgdGhlIGF1dGhcblx0XHQgKiBvYmplY3QuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgc2hvdWxkIHVzZSB0aGUgdmFsdWVzIG9uIGB0aGlzYCxcblx0XHQgKiBub3QgdGhlIHBhc3NlZCBpbiBvbmVzLiAqL1xuXHRcdHRoaXMuX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKTtcblxuXHRcdGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSwgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdC8qIFJTQTEwZyAqL1xuXHRcdFx0ZGVsZXRlIHNlbGYudG9rZW5QYXJhbXMudGltZXN0YW1wO1xuXHRcdFx0ZGVsZXRlIHNlbGYuYXV0aE9wdGlvbnMucXVlcnlUaW1lO1xuXHRcdFx0Y2FsbGJhY2soZXJyLCB0b2tlbkRldGFpbHMpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3QgYW4gYWNjZXNzIHRva2VuXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuXHQgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLlxuXHQgKlxuXHQgKiAtIGF1dGhDYWxsYmFjazogIChvcHRpb25hbCkgYSBKYXZhU2NyaXB0IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB0byBnZXQgYXV0aCBpbmZvcm1hdGlvbi5cblx0ICogICAgICAgICAgICAgICAgICBhdXRoQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgKHRva2VuUGFyYW1zLCBjYWxsYmFjaykgdGhhdCBjYWxsc1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBjYWxsYmFjayB3aXRoIChlcnIsIHJlc3VsdCksIHdoZXJlIHJlc3VsdCBpcyBhbnkgb2Y6XG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuUmVxdWVzdCBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGguY3JlYXRlVG9rZW5SZXF1ZXN0IGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbkRldGFpbHMgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLnJlcXVlc3RUb2tlbiBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW4gc3RyaW5nXG5cdCAqXG5cdCAqIC0gYXV0aFVybDogICAgICAgKG9wdGlvbmFsKSBhIFVSTCB0byBiZSB1c2VkIHRvIEdFVCBvciBQT1NUIGEgc2V0IG9mIHRva2VuIHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBwYXJhbXMsIHRvIG9idGFpbiBhIHNpZ25lZCB0b2tlbiByZXF1ZXN0LlxuXHQgKlxuXHQgKiAtIGF1dGhIZWFkZXJzOiAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgaGVhZGVycyB0byBiZSBhZGRlZCB0byBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqIC0gYXV0aFBhcmFtczogICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBxdWVyeSBwYXJhbXMgdG8gYmUgYWRkZWQgdG8gYW55XG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdCBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuXHQgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG5cdCAqXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIHRva2VuUGFyYW1zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuXHQgKiAtIHR0bDogICAgICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1pbGxpc2Vjb25kcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcblx0ICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuXHQgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cblx0ICpcblx0ICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG5cdCAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuXHQgKlxuXHQgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcblx0ICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cblx0ICpcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHRva2VuRGV0YWlscylcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLnJlcXVlc3RUb2tlbiA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZighY2FsbGJhY2sgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdFRva2VuJywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHQvKiBSU0E4ZTogaWYgYXV0aE9wdGlvbnMgcGFzc2VkIGluLCB0aGV5J3JlIHVzZWQgaW5zdGVhZCBvZiBzdG9yZWQsIGRvbid0IG1lcmdlIHRoZW0gKi9cblx0XHRhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG5cdFx0dG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuXHRcdC8qIGZpcnN0IHNldCB1cCB3aGF0ZXZlciBjYWxsYmFjayB3aWxsIGJlIHVzZWQgdG8gZ2V0IHNpZ25lZFxuXHRcdCAqIHRva2VuIHJlcXVlc3RzICovXG5cdFx0dmFyIHRva2VuUmVxdWVzdENhbGxiYWNrLCBjbGllbnQgPSB0aGlzLmNsaWVudDtcblxuXHRcdGlmKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aENhbGxiYWNrJyk7XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaztcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbihwYXJhbXMsIGNiKSB7XG5cdFx0XHRcdHZhciBhdXRoSGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHthY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluJ30sIGF1dGhPcHRpb25zLmF1dGhIZWFkZXJzKSxcblx0XHRcdFx0XHR1c2VQb3N0ID0gYXV0aE9wdGlvbnMuYXV0aE1ldGhvZCAmJiBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdwb3N0Jztcblx0XHRcdFx0aWYoIXVzZVBvc3QpIHtcblx0XHRcdFx0XHQvKiBDb21iaW5lIGF1dGhQYXJhbXMgd2l0aCBhbnkgcXMgcGFyYW1zIGdpdmVuIGluIHRoZSBhdXRoVXJsICovXG5cdFx0XHRcdFx0dmFyIHF1ZXJ5SWR4ID0gYXV0aE9wdGlvbnMuYXV0aFVybC5pbmRleE9mKCc/Jyk7XG5cdFx0XHRcdFx0aWYocXVlcnlJZHggPiAtMSkge1xuXHRcdFx0XHRcdFx0dmFyIHByb3ZpZGVkUXNQYXJhbXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wYXJzZVF1ZXJ5U3RyaW5nKGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UocXVlcnlJZHgpKTtcblx0XHRcdFx0XHRcdGF1dGhPcHRpb25zLmF1dGhVcmwgPSBhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcblx0XHRcdFx0XHRcdC8qIEluIGNhc2Ugb2YgY29uZmxpY3QsIGF1dGhQYXJhbXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgcXMgcGFyYW1zIGluIHRoZSBhdXRoVXJsICovXG5cdFx0XHRcdFx0XHRhdXRoT3B0aW9ucy5hdXRoUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocHJvdmlkZWRRc1BhcmFtcywgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIFJTQThjMiAqL1xuXHRcdFx0XHR2YXIgYXV0aFBhcmFtcyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHt9LCBhdXRoT3B0aW9ucy5hdXRoUGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuXHRcdFx0XHR2YXIgYXV0aFVybFJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdFx0XHR2YXIgY29udGVudFR5cGU7XG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZCBFcnJvcjogJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXTtcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogJyArIGNvbnRlbnRUeXBlICsgJzsgYm9keTogJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RCb2R5KGJvZHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoZXJyIHx8IHVucGFja2VkKSByZXR1cm4gY2IoZXJyLCBib2R5KTtcblx0XHRcdFx0XHRpZihidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0J1ZmZlcihib2R5KSkgYm9keSA9IGJvZHkudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRpZighY29udGVudFR5cGUpIHtcblx0XHRcdFx0XHRcdGNiKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2F1dGhVcmwgcmVzcG9uc2UgaXMgbWlzc2luZyBhIGNvbnRlbnQtdHlwZSBoZWFkZXInLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBqc29uID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEsXG5cdFx0XHRcdFx0XHR0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMTtcblx0XHRcdFx0XHRpZighanNvbiAmJiAhdGV4dCkge1xuXHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlICcgKyBjb250ZW50VHlwZSArICcsIHNob3VsZCBiZSBlaXRoZXIgdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vand0IG9yIGFwcGxpY2F0aW9uL2pzb24nLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGpzb24pIHtcblx0XHRcdFx0XHRcdGlmKGJvZHkubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuXHRcdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbnNlIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gJyArIGUubWVzc2FnZSwgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZXF1ZXN0aW5nIHRva2VuIGZyb20gJyArIGF1dGhPcHRpb25zLmF1dGhVcmwgKyAnOyBQYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSArICc7IG1ldGhvZDogJyArICh1c2VQb3N0ID8gJ1BPU1QnIDogJ0dFVCcpKTtcblx0XHRcdFx0aWYodXNlUG9zdCkge1xuXHRcdFx0XHRcdC8qIHNlbmQgYm9keSBmb3JtLWVuY29kZWQgKi9cblx0XHRcdFx0XHR2YXIgaGVhZGVycyA9IGF1dGhIZWFkZXJzIHx8IHt9O1xuXHRcdFx0XHRcdGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG5cdFx0XHRcdFx0dmFyIGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS50b1F1ZXJ5U3RyaW5nKGF1dGhQYXJhbXMpLnNsaWNlKDEpOyAvKiBzbGljZSBpcyB0byByZW1vdmUgdGhlIGluaXRpYWwgJz8nICovXG5cdFx0XHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5wb3N0VXJpKGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgaGVhZGVycywgYm9keSwge30sIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0VXJpKGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgYXV0aEhlYWRlcnMgfHwge30sIGF1dGhQYXJhbXMsIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5rZXkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24ocGFyYW1zLCBjYikgeyBzZWxmLmNyZWF0ZVRva2VuUmVxdWVzdChwYXJhbXMsIGF1dGhPcHRpb25zLCBjYik7IH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSBcIk5lZWQgYSBuZXcgdG9rZW4sIGJ1dCBhdXRoT3B0aW9ucyBkb2VzIG5vdCBpbmNsdWRlIGFueSB3YXkgdG8gcmVxdWVzdCBvbmUgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KVwiO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgJ2xpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzEsIDQwMykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIG5vcm1hbGlzZSB0b2tlbiBwYXJhbXMgKi9cblx0XHRpZignY2FwYWJpbGl0eScgaW4gdG9rZW5QYXJhbXMpXG5cdFx0XHR0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcblxuXHRcdHZhciB0b2tlblJlcXVlc3QgPSBmdW5jdGlvbihzaWduZWRUb2tlblBhcmFtcywgdG9rZW5DYikge1xuXHRcdFx0dmFyIGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLFxuXHRcdFx0XHRwYXRoID0gJy9rZXlzLycgKyBrZXlOYW1lICsgJy9yZXF1ZXN0VG9rZW4nLFxuXHRcdFx0XHR0b2tlblVyaSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIGNsaWVudC5iYXNlVXJpKGhvc3QpICsgcGF0aDsgfTtcblxuXHRcdFx0dmFyIHJlcXVlc3RIZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKCk7XG5cdFx0XHRpZihhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycykgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocmVxdWVzdEhlYWRlcnMsIGF1dGhPcHRpb25zLnJlcXVlc3RIZWFkZXJzKTtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkucmVxdWVzdFRva2VuJywgJ1NlbmRpbmcgUE9TVCB0byAnICsgcGF0aCArICc7IFRva2VuIHBhcmFtczogJyArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSk7XG5cdFx0XHRzaWduZWRUb2tlblBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKTtcblx0XHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ucG9zdChjbGllbnQsIHRva2VuVXJpLCByZXF1ZXN0SGVhZGVycywgc2lnbmVkVG9rZW5QYXJhbXMsIG51bGwsIHRva2VuQ2IpO1xuXHRcdH07XG5cblx0XHR2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IGZhbHNlLFxuXHRcdFx0dGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgbXNnID0gJ1Rva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyICcgKyAodGltZW91dExlbmd0aCAvIDEwMDApICsgJyBzZWNvbmRzJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHR9LCB0aW1lb3V0TGVuZ3RoKTtcblxuXHRcdHRva2VuUmVxdWVzdENhbGxiYWNrKHRva2VuUGFyYW1zLCBmdW5jdGlvbihlcnIsIHRva2VuUmVxdWVzdE9yRGV0YWlscywgY29udGVudFR5cGUpIHtcblx0XHRcdGlmKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpIHJldHVybjtcblx0XHRcdGNsZWFyVGltZW91dCh0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQpO1xuXG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IHNpZ25pbmcgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0Y2FsbGJhY2sobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIHRoZSByZXNwb25zZSBmcm9tIHRoZSBjYWxsYmFjayBtaWdodCBiZSBhIHRva2VuIHN0cmluZywgYSBzaWduZWQgcmVxdWVzdCBvciBhIHRva2VuIGRldGFpbHMgKi9cblx0XHRcdGlmKHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZih0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gc3RyaW5nIGlzIGVtcHR5JywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiBzdHJpbmcgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGggKHdhcyAnICsgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAndW5kZWZpbmVkJyB8fCB0b2tlblJlcXVlc3RPckRldGFpbHMgPT09ICdudWxsJykge1xuXHRcdFx0XHRcdC8qIGNvbW1vbiBmYWlsdXJlIG1vZGUgd2l0aCBwb29ybHktaW1wbGVtZW50ZWQgYXV0aENhbGxiYWNrcyAqL1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyB3YXMgbGl0ZXJhbCBudWxsL3VuZGVmaW5lZCcsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIGlmKCh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09ICd7JykgJiYgIShjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qd3QnKSA+IC0xKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHdhcyBkb3VibGUtZW5jb2RlZDsgbWFrZSBzdXJlIHlvdVxcJ3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHMnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwge3Rva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHN9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nIG9yIHRva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QsIGJ1dCBnb3QgYSAnICsgdHlwZW9mKHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xuXHRcdFx0aWYob2JqZWN0U2l6ZSA+IE1BWF9UT0tFTl9MRU5HVEggJiYgIWF1dGhPcHRpb25zLnN1cHByZXNzTWF4TGVuZ3RoQ2hlY2spIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyAnICsgb2JqZWN0U2l6ZSArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZignaXNzdWVkJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcblx0XHRcdFx0LyogYSB0b2tlbkRldGFpbHMgb2JqZWN0ICovXG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuUmVxdWVzdE9yRGV0YWlscyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCEoJ2tleU5hbWUnIGluIHRva2VuUmVxdWVzdE9yRGV0YWlscykpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdFeHBlY3RlZCB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRvIGNhbGwgYmFjayB3aXRoIGEgdG9rZW4gc3RyaW5nLCB0b2tlbiByZXF1ZXN0IG9iamVjdCwgb3IgdG9rZW4gZGV0YWlscyBvYmplY3QnO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogaXQncyBhIHRva2VuIHJlcXVlc3QsIHNvIG1ha2UgdGhlIHJlcXVlc3QgKi9cblx0XHRcdHRva2VuUmVxdWVzdCh0b2tlblJlcXVlc3RPckRldGFpbHMsIGZ1bmN0aW9uKGVyciwgdG9rZW5SZXNwb25zZSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdW5wYWNrZWQpIHRva2VuUmVzcG9uc2UgPSBKU09OLnBhcnNlKHRva2VuUmVzcG9uc2UpO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndG9rZW4gcmVjZWl2ZWQnKTtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5SZXNwb25zZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuZCBzaWduIGEgdG9rZW4gcmVxdWVzdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cblx0ICogTk9URSB0aGlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUga2V5IHZhbHVlIGlzIGF2YWlsYWJsZSBsb2NhbGx5LlxuXHQgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuXHQgKiBvd25lciAoZWl0aGVyIHVzaW5nIHRoZSB0b2tlbiByZXF1ZXN0IGNhbGxiYWNrIG9yIHVybCkuXG5cdCAqXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxuXHQgKiAtIGtleTogICAgICAgICAgIHRoZSBrZXkgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCBhIGtleSBwYXNzZWQgaW4gY29uc3RydWN0aW5nXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuXHQgKlxuXHQgKiAtIHF1ZXJ5VGltZSAgICAgIChvcHRpb25hbCkgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGFibHkgc3lzdGVtIHNob3VsZCBiZVxuXHQgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG5cdCAqXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIHRva2VuUGFyYW1zXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuXHQgKiAtIHR0bDogICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1zLiBJZiBub25lIGlzIHNwZWNpZmllZFxuXHQgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cblx0ICpcblx0ICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG5cdCAqICAgICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuXHQgKlxuXHQgKiAtIGNsaWVudElkOiAgICAgIChvcHRpb25hbCkgYSBjbGllbnQgSWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuOyBpZiBub3Rcblx0ICogICAgICAgICAgICAgICAgICBzcGVjaWZpZWQsIGEgY2xpZW50SWQgcGFzc2VkIGluIGNvbnN0cnVjdGluZyB0aGUgUmVzdCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkXG5cdCAqXG5cdCAqIC0gdGltZXN0YW1wOiAgICAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBzeXN0ZW0gd2lsbCBiZSBxdWVyaWVkIGZvciBhIHRpbWUgdmFsdWUgdG8gdXNlLlxuXHQgKlxuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuY3JlYXRlVG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG5cdFx0aWYodHlwZW9mKHRva2VuUGFyYW1zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSB0b2tlblBhcmFtcztcblx0XHRcdGF1dGhPcHRpb25zID0gdG9rZW5QYXJhbXMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGF1dGhPcHRpb25zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZighY2FsbGJhY2sgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnY3JlYXRlVG9rZW5SZXF1ZXN0JywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHQvKiBSU0E5aDogaWYgYXV0aE9wdGlvbnMgcGFzc2VkIGluLCB0aGV5J3JlIHVzZWQgaW5zdGVhZCBvZiBzdG9yZWQsIGRvbid0IG1lcmdlIHRoZW0gKi9cblx0XHRhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG5cdFx0dG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcyB8fCB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb3B5KHRoaXMudG9rZW5QYXJhbXMpO1xuXG5cdFx0dmFyIGtleSA9IGF1dGhPcHRpb25zLmtleTtcblx0XHRpZigha2V5KSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdObyBrZXkgc3BlY2lmaWVkJywgNDAxMDEsIDQwMykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIga2V5UGFydHMgPSBrZXkuc3BsaXQoJzonKSxcblx0XHRcdGtleU5hbWUgPSBrZXlQYXJ0c1swXSxcblx0XHRcdGtleVNlY3JldCA9IGtleVBhcnRzWzFdO1xuXG5cdFx0aWYoIWtleVNlY3JldCkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnSW52YWxpZCBrZXkgc3BlY2lmaWVkJywgNDAxMDEsIDQwMykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHRva2VuUGFyYW1zLmNsaWVudElkID09PSAnJykge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgY2Fu4oCZdCBiZSBhbiBlbXB0eSBzdHJpbmcnLCA0MDAxMiwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKSB7XG5cdFx0XHR0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHsga2V5TmFtZToga2V5TmFtZSB9LCB0b2tlblBhcmFtcyksXG5cdFx0XHRjbGllbnRJZCA9IHRva2VuUGFyYW1zLmNsaWVudElkIHx8ICcnLFxuXHRcdFx0dHRsID0gdG9rZW5QYXJhbXMudHRsIHx8ICcnLFxuXHRcdFx0Y2FwYWJpbGl0eSA9IHRva2VuUGFyYW1zLmNhcGFiaWxpdHkgfHwgJycsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdChmdW5jdGlvbihhdXRob3Jpc2VDYikge1xuXHRcdFx0aWYocmVxdWVzdC50aW1lc3RhbXApIHtcblx0XHRcdFx0YXV0aG9yaXNlQ2IoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fTtcblx0XHRcdHNlbGYuZ2V0VGltZXN0YW1wKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLnF1ZXJ5VGltZSwgZnVuY3Rpb24oZXJyLCB0aW1lKSB7XG5cdFx0XHRcdGlmKGVycikge2NhbGxiYWNrKGVycik7IHJldHVybjt9XG5cdFx0XHRcdHJlcXVlc3QudGltZXN0YW1wID0gdGltZTtcblx0XHRcdFx0YXV0aG9yaXNlQ2IoKTtcblx0XHRcdH0pO1xuXHRcdH0pKGZ1bmN0aW9uKCkge1xuXHRcdFx0Lyogbm9uY2UgKi9cblx0XHRcdC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuXHRcdFx0ICogc3BlY2lmaWVzIHRoZSBub25jZTsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG5cdFx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcblx0XHRcdCAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cblx0XHRcdHZhciBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksXG5cdFx0XHRcdHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuXG5cdFx0XHR2YXIgc2lnblRleHRcblx0XHRcdD1cdHJlcXVlc3Qua2V5TmFtZSArICdcXG4nXG5cdFx0XHQrXHR0dGwgKyAnXFxuJ1xuXHRcdFx0K1x0Y2FwYWJpbGl0eSArICdcXG4nXG5cdFx0XHQrXHRjbGllbnRJZCArICdcXG4nXG5cdFx0XHQrXHR0aW1lc3RhbXAgKyAnXFxuJ1xuXHRcdFx0K1x0bm9uY2UgKyAnXFxuJztcblxuXHRcdFx0LyogbWFjICovXG5cdFx0XHQvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcblx0XHRcdCAqIHNwZWNpZmllcyB0aGUgbWFjOyB0aGlzIGlzIGRvbmUgYnkgdGhlIGxpYnJhcnlcblx0XHRcdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuXHRcdFx0ICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xuXHRcdFx0cmVxdWVzdC5tYWMgPSByZXF1ZXN0Lm1hYyB8fCBobWFjKHNpZ25UZXh0LCBrZXlTZWNyZXQpO1xuXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuUmVxdWVzdCgpJywgJ2dlbmVyYXRlZCBzaWduZWQgcmVxdWVzdCcpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVxdWVzdCk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxuXHQgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhQYXJhbXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGlmKHRoaXMubWV0aG9kID09ICdiYXNpYycpXG5cdFx0XHRjYWxsYmFjayhudWxsLCB7a2V5OiB0aGlzLmtleX0pO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB7YWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW59KTtcblx0XHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHVzZSBmb3IgYSBSRVNUIG9yIGNvbWV0IHJlcXVlc3QsXG5cdCAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuXHQgKi9cblx0QXV0aC5wcm90b3R5cGUuZ2V0QXV0aEhlYWRlcnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGlmKHRoaXMubWV0aG9kID09ICdiYXNpYycpIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHthdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIHRoaXMuYmFzaWNLZXl9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHthdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0b0Jhc2U2NCh0b2tlbkRldGFpbHMudG9rZW4pfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCB0aW1lIGJhc2VkIG9uIHRoZSBsb2NhbCBjbG9jayxcblx0ICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cblx0ICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG5cdCAqIG9ubHkgb25lIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIHRpbWUgaXMgZXZlciBuZWVkZWRcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHF1ZXJ5VGltZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIXRoaXMuaXNUaW1lT2Zmc2V0U2V0KCkgJiYgKHF1ZXJ5VGltZSB8fCB0aGlzLmF1dGhPcHRpb25zLnF1ZXJ5VGltZSkpIHtcblx0XHRcdHRoaXMuY2xpZW50LnRpbWUoY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpO1xuXHRcdH1cblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3coKSArICh0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0IHx8IDApO1xuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLmlzVGltZU9mZnNldFNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLl9zYXZlQmFzaWNPcHRpb25zID0gZnVuY3Rpb24oYXV0aE9wdGlvbnMpIHtcblx0XHR0aGlzLm1ldGhvZCA9ICdiYXNpYyc7XG5cdFx0dGhpcy5rZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG5cdFx0dGhpcy5iYXNpY0tleSA9IHRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG5cdFx0dGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xuXHRcdGlmKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcblx0XHRcdHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG5cdFx0fVxuXHR9XG5cblx0QXV0aC5wcm90b3R5cGUuX3NhdmVUb2tlbk9wdGlvbnMgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcblx0XHR0aGlzLm1ldGhvZCA9ICd0b2tlbic7XG5cblx0XHRpZih0b2tlblBhcmFtcykge1xuXHRcdFx0LyogV2UgdGVtcG9yYXJpbHkgcGVyc2lzdCB0b2tlblBhcmFtcy50aW1lc3RhbXAgaW4gY2FzZSBhIG5ldyB0b2tlbiBuZWVkc1xuXHRcdFx0ICogdG8gYmUgcmVxdWVzdGVkLCB0aGVuIG51bGwgaXQgb3V0IGluIHRoZSBjYWxsYmFjayBvZlxuXHRcdFx0ICogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIGZvciBSU0ExMGcgY29tcGxpYW5jZSAqL1xuXHRcdFx0dGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuXHRcdH1cblxuXHRcdGlmKGF1dGhPcHRpb25zKSB7XG5cdFx0XHQvKiBub3JtYWxpc2UgKi9cblx0XHRcdGlmKGF1dGhPcHRpb25zLnRva2VuKSB7XG5cdFx0XHRcdC8qIG9wdGlvbnMudG9rZW4gbWF5IGNvbnRhaW4gYSB0b2tlbiBzdHJpbmcgb3IsIGZvciBjb252ZW5pZW5jZSwgYSBUb2tlbkRldGFpbHMgKi9cblx0XHRcdFx0YXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzID0gKHR5cGVvZihhdXRoT3B0aW9ucy50b2tlbikgPT09ICdzdHJpbmcnKSA/IHt0b2tlbjogYXV0aE9wdGlvbnMudG9rZW59IDogYXV0aE9wdGlvbnMudG9rZW47XG5cdFx0XHR9XG5cblx0XHRcdGlmKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuXHRcdFx0XHR0aGlzLnRva2VuRGV0YWlscyA9IGF1dGhPcHRpb25zLnRva2VuRGV0YWlscztcblx0XHRcdH1cblxuXHRcdFx0aWYoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEBwYXJhbSBmb3JjZVN1cGVyc2VkZTogZm9yY2UgYSBuZXcgdG9rZW4gcmVxdWVzdCBldmVuIGlmIHRoZXJlJ3Mgb25lIGluXG5cdCAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG5cdEF1dGgucHJvdG90eXBlLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKGZvcmNlU3VwZXJzZWRlLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XG5cblx0XHRpZih0b2tlbikge1xuXHRcdFx0aWYodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuXHRcdFx0XHQvKiA0MDMgdG8gdHJpZ2dlciBhIHBlcm1hbmVudGx5IGZhaWxlZCBjbGllbnQgLSBSU0ExNWMgKi9cblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTWlzbWF0Y2ggYmV0d2VlbiBjbGllbnRJZCBpbiB0b2tlbiAoJyArIHRva2VuLmNsaWVudElkICsgJykgYW5kIGN1cnJlbnQgY2xpZW50SWQgKCcgKyB0aGlzLmNsaWVudElkICsgJyknLCA0MDEwMiwgNDAzKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIFJTQTRiMSAtLSBpZiB3ZSBoYXZlIGEgc2VydmVyIHRpbWUgb2Zmc2V0IHNldCBhbHJlYWR5LCB3ZSBjYW5cblx0XHRcdCAqIGF1dG9yZW1vdmUgZXhwaXJlZCB0b2tlbnMuIEVsc2UganVzdCB1c2UgdGhlIGNhY2hlZCB0b2tlbi4gSWYgaXQgaXNcblx0XHRcdCAqIGV4cGlyZWQgQWJseSB3aWxsIHRlbGwgdXMgYW5kIHdlJ2xsIGRpc2NhcmQgaXQgdGhlbi4gKi9cblx0XHRcdGlmKCF0aGlzLmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8ICh0b2tlbi5leHBpcmVzID49IHRoaXMuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQoKSkpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3VzaW5nIGNhY2hlZCB0b2tlbjsgZXhwaXJlcyA9ICcgKyB0b2tlbi5leHBpcmVzKTtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW4pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBleHBpcmVkLCBzbyByZW1vdmUgYW5kIGZhbGx0aHJvdWdoIHRvIGdldHRpbmcgYSBuZXcgb25lICovXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAnZGVsZXRpbmcgZXhwaXJlZCB0b2tlbicpO1xuXHRcdFx0dGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdCh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IE9iamVjdChtdWx0aWNhc3RlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoKSkpLnB1c2goY2FsbGJhY2spO1xuXHRcdGlmKHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkICE9PSBudWxsICYmICFmb3JjZVN1cGVyc2VkZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIFJlcXVlc3QgYSBuZXcgdG9rZW4gKi9cblx0XHR2YXIgdG9rZW5SZXF1ZXN0SWQgPSB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCk7XG5cdFx0dGhpcy5yZXF1ZXN0VG9rZW4odGhpcy50b2tlblBhcmFtcywgdGhpcy5hdXRoT3B0aW9ucywgZnVuY3Rpb24oZXJyLCB0b2tlblJlc3BvbnNlKSB7XG5cdFx0XHRpZihzZWxmLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA+IHRva2VuUmVxdWVzdElkKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKCknLCAnRGlzY2FyZGluZyB0b2tlbiByZXF1ZXN0IHJlc3BvbnNlOyBvdmVydGFrZW4gYnkgbmV3ZXIgb25lJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcblx0XHRcdHZhciBjYWxsYmFja3MgPSBzZWxmLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgbm9vcDtcblx0XHRcdHNlbGYud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2tzKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrcyhudWxsLCAoc2VsZi50b2tlbkRldGFpbHMgPSB0b2tlblJlc3BvbnNlKSk7XG5cdFx0fSk7XG5cdH07XG5cblxuXHQvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG5cdEF1dGgucHJvdG90eXBlLl91c2VyU2V0Q2xpZW50SWQgPSBmdW5jdGlvbihjbGllbnRJZCkge1xuXHRcdGlmKCEodHlwZW9mKGNsaWVudElkKSA9PT0gJ3N0cmluZycgfHwgY2xpZW50SWQgPT09IG51bGwpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG5cdFx0fSBlbHNlIGlmKGNsaWVudElkID09PSAnKicpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIGluc3RhbnRpYXRlIHRoZSBsaWJyYXJ5IHdpdGgge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KSwgb3IgaWYgY2FsbGluZyBhdXRob3JpemUoKSwgcGFzcyBpdCBpbiBhcyBhIHRva2VuUGFyYW06IGF1dGhvcml6ZSh7Y2xpZW50SWQ6IFwiKlwifSwgYXV0aE9wdGlvbnMpJywgNDAwMTIsIDQwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG5cdFx0XHRpZihlcnIpIHRocm93IGVycjtcblx0XHR9XG5cdH07XG5cblx0LyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuXHRBdXRoLnByb3RvdHlwZS5fdW5jaGVja2VkU2V0Q2xpZW50SWQgPSBmdW5jdGlvbihjbGllbnRJZCkge1xuXHRcdGlmKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaChjbGllbnRJZCkpIHtcblx0XHRcdC8qIFNob3VsZCBuZXZlciBoYXBwZW4gaW4gbm9ybWFsIGNpcmN1bXN0YW5jZXMgYXMgcmVhbHRpbWUgc2hvdWxkXG5cdFx0XHQgKiByZWNvZ25pc2UgbWlzbWF0Y2ggYW5kIHJldHVybiBhbiBlcnJvciAqL1xuXHRcdFx0dmFyIG1zZyA9ICdVbmV4cGVjdGVkIGNsaWVudElkIG1pc21hdGNoOiBjbGllbnQgaGFzICcgKyB0aGlzLmNsaWVudElkICsgJywgcmVxdWVzdGVkICcgKyBjbGllbnRJZDtcblx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxMDIsIDQwMSk7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLl91bmNoZWNrZWRTZXRDbGllbnRJZCgpJywgbXNnKTtcblx0XHRcdHJldHVybiBlcnI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIFJTQTdhNDogaWYgb3B0aW9ucy5jbGllbnRJZCBpcyBwcm92aWRlZCBhbmQgaXMgbm90XG5cdFx0XHQgKiBudWxsLCBpdCBvdmVycmlkZXMgZGVmYXVsdFRva2VuUGFyYW1zLmNsaWVudElkICovXG5cdFx0XHR0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLl90b2tlbkNsaWVudElkTWlzbWF0Y2ggPSBmdW5jdGlvbih0b2tlbkNsaWVudElkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50SWQgJiZcblx0XHRcdCh0aGlzLmNsaWVudElkICE9PSAnKicpICYmXG5cdFx0XHR0b2tlbkNsaWVudElkICYmXG5cdFx0XHQodG9rZW5DbGllbnRJZCAhPT0gJyonKSAmJlxuXHRcdFx0KHRoaXMuY2xpZW50SWQgIT09IHRva2VuQ2xpZW50SWQpO1xuXHR9O1xuXG5cdEF1dGguaXNUb2tlbkVyciA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0cmV0dXJuIGVycm9yLmNvZGUgJiYgKGVycm9yLmNvZGUgPj0gNDAxNDApICYmIChlcnJvci5jb2RlIDwgNDAxNTApO1xuXHR9O1xuXG5cdHJldHVybiBBdXRoO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYXV0aCA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGF1dGhfQXV0aCk7XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG5cblxudmFyIENvbWV0VHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBSRVFfU0VORCA9IDAsXG5cdFx0UkVRX1JFQ1YgPSAxLFxuXHRcdFJFUV9SRUNWX1BPTEwgPSAyLFxuXHRcdFJFUV9SRUNWX1NUUkVBTSA9IDM7XG5cblx0LyogVE9ETzogY2FuIHJlbW92ZSBvbmNlIHJlYWx0aW1lIHNlbmRzIHByb3RvY29sIG1lc3NhZ2UgcmVzcG9uc2VzIGZvciBjb21ldCBlcnJvcnMgKi9cblx0ZnVuY3Rpb24gc2hvdWxkQmVFcnJvckFjdGlvbihlcnIpIHtcblx0XHR2YXIgVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTID0gWzgwMDE1LCA4MDAxNywgODAwMzBdO1xuXHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRpZihfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKGVycikpIHJldHVybiBmYWxzZTtcblx0XHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTLCBlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIChlcnIuY29kZSA+PSA0MDAwMCAmJiBlcnIuY29kZSA8IDUwMDAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogTGlrZWx5IGEgbmV0d29yayBvciB0cmFuc3BvcnQgZXJyb3Igb2Ygc29tZSBraW5kLiBDZXJ0YWlubHkgbm90IGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuXHRcdC8qIGVyciB3aWxsIGJlIGVpdGhlciBhIGxlZ2FjeSAobm9uLXByb3RvY29sbWVzc2FnZSkgY29tZXQgZXJyb3IgcmVzcG9uc2Vcblx0XHQgKiAod2hpY2ggd2lsbCBoYXZlIGFuIGVyci5jb2RlKSwgb3IgYSB4aHIvbmV0d29yayBlcnJvciAod2hpY2ggd29uJ3QpLiAqL1xuXHRcdGlmKHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSkge1xuXHRcdFx0cmV0dXJuIFtfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkVSUk9SLCBlcnJvcjogZXJyfSldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW190eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb24uRElTQ09OTkVDVEVELCBlcnJvcjogZXJyfSldO1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIEEgYmFzZSBjb21ldCB0cmFuc3BvcnQgY2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIENvbWV0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHQvKiBiaW5hcnkgbm90IHN1cHBvcnRlZCBmb3IgY29tZXQsIHNvIGp1c3QgZmFsbCBiYWNrIHRvIGRlZmF1bHQgKi9cblx0XHRwYXJhbXMuZm9ybWF0ID0gdW5kZWZpbmVkO1xuXHRcdHBhcmFtcy5oZWFydGJlYXRzID0gdHJ1ZTtcblx0XHRfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0Lyogc3RyZWFtaW5nIGRlZmF1bHRzIHRvIHRydWUgKi9cblx0XHR0aGlzLnN0cmVhbSA9ICgnc3RyZWFtJyBpbiBwYXJhbXMpID8gcGFyYW1zLnN0cmVhbSA6IHRydWU7XG5cdFx0dGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG5cdFx0dGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0dGhpcy5wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xuXHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKENvbWV0VHJhbnNwb3J0LCBfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRDb21ldFRyYW5zcG9ydC5SRVFfU0VORCA9IFJFUV9TRU5EO1xuXHRDb21ldFRyYW5zcG9ydC5SRVFfUkVDViA9IFJFUV9SRUNWO1xuXHRDb21ldFRyYW5zcG9ydC5SRVFfUkVDVl9QT0xMID0gUkVRX1JFQ1ZfUE9MTDtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1ZfU1RSRUFNID0gUkVRX1JFQ1ZfU1RSRUFNO1xuXG5cdC8qIHB1YmxpYyBpbnN0YW5jZSBtZXRob2RzICovXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuXHRcdF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucHJvdG90eXBlLmNvbm5lY3QuY2FsbCh0aGlzKTtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cdFx0dmFyIGhvc3QgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xuXHRcdHZhciBwb3J0ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRQb3J0KG9wdGlvbnMpO1xuXHRcdHZhciBjb21ldFNjaGVtZSA9IG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcblxuXHRcdHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArICc6JyArIHBvcnQgKyAnL2NvbWV0Lyc7XG5cdFx0dmFyIGNvbm5lY3RVcmkgPSB0aGlzLmJhc2VVcmkgKyAnY29ubmVjdCc7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyBjb25uZWN0VXJpKTtcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoc2VsZi5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuYXV0aFBhcmFtcyA9IGF1dGhQYXJhbXM7XG5cdFx0XHR2YXIgY29ubmVjdFBhcmFtcyA9IHNlbGYucGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG5cdFx0XHRpZignc3RyZWFtJyBpbiBjb25uZWN0UGFyYW1zKSBzZWxmLnN0cmVhbSA9IGNvbm5lY3RQYXJhbXMuc3RyZWFtO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdjb25uZWN0UGFyYW1zOicgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcykpO1xuXG5cdFx0XHQvKiB0aGlzIHdpbGwgYmUgdGhlICdyZWN2UmVxdWVzdCcgc28gdGhpcyBjb25uZWN0aW9uIGNhbiBzdHJlYW0gbWVzc2FnZXMgKi9cblx0XHRcdHZhciBwcmVjb25uZWN0ZWQgPSBmYWxzZSxcblx0XHRcdFx0Y29ubmVjdFJlcXVlc3QgPSBzZWxmLnJlY3ZSZXF1ZXN0ID0gc2VsZi5jcmVhdGVSZXF1ZXN0KGNvbm5lY3RVcmksIG51bGwsIGNvbm5lY3RQYXJhbXMsIG51bGwsIChzZWxmLnN0cmVhbSA/IFJFUV9SRUNWX1NUUkVBTSA6IFJFUV9SRUNWKSk7XG5cblx0XHRcdGNvbm5lY3RSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRpZighc2VsZi5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRcdC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXByZWNvbm5lY3RlZCkge1xuXHRcdFx0XHRcdHByZWNvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdwcmVjb25uZWN0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5vbkRhdGEoZGF0YSk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbm5lY3RSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVyciwgX2JvZHksIGhlYWRlcnMpIHtcblx0XHRcdFx0aWYoIXNlbGYucmVjdlJlcXVlc3QpIHtcblx0XHRcdFx0XHQvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG5cdFx0XHRcdFx0ZXJyID0gZXJyIHx8IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1JlcXVlc3QgY2FuY2VsbGVkJywgODAwMDMsIDQwMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdC8qIENvbm5lY3QgcmVxdWVzdCBtYXkgY29tcGxldGUgd2l0aG91dCBhIGVtaXR0aW5nICdkYXRhJyBldmVudCBzaW5jZSB0aGF0IGlzIG5vdFxuXHRcdFx0XHQgKiBlbWl0dGVkIGZvciBlLmcuIGEgbm9uLXN0cmVhbWVkIGVycm9yIHJlc3BvbnNlLiBTdGlsbCBpbXBsaWVzIHByZWNvbm5lY3QuICovXG5cdFx0XHRcdGlmKCFwcmVjb25uZWN0ZWQgJiYgIWVycikge1xuXHRcdFx0XHRcdHByZWNvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdwcmVjb25uZWN0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5vbkFjdGl2aXR5KCk7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG5cdFx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG5cdFx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYucmVjdigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0Y29ubmVjdFJlcXVlc3QuZXhlYygpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknKTtcblx0XHR0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QodHJ1ZSk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KCknKTtcblx0XHR0aGlzLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QoZmFsc2UpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0ID0gZnVuY3Rpb24oY2xvc2luZykge1xuXHRcdHZhciBjbG9zZU9yRGlzY29ubmVjdFVyaSA9IGNsb3NpbmcgPyB0aGlzLmNsb3NlVXJpIDogdGhpcy5kaXNjb25uZWN0VXJpO1xuXHRcdGlmKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QoY2xvc2VPckRpc2Nvbm5lY3RVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgUkVRX1NFTkQpO1xuXG5cdFx0XHRyZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3QnICsgKGNsb3NpbmcgPyAnQ2xvc2UoKScgOiAnRGlzY29ubmVjdCgpJyksICdyZXF1ZXN0IHJldHVybmVkIGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRzZWxmLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXF1ZXN0LmV4ZWMoKTtcblx0XHR9XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuXHRcdGlmKCF0aGlzLmlzRGlzcG9zZWQpIHtcblx0XHRcdHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG5cdFx0XHRpZih0aGlzLnJlY3ZSZXF1ZXN0KSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnYWJvcnRpbmcgcmVjdiByZXF1ZXN0Jyk7XG5cdFx0XHRcdHRoaXMucmVjdlJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdFx0dGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvKiBJbiBhbG1vc3QgYWxsIGNhc2VzIHRoZSB0cmFuc3BvcnQgd2lsbCBiZSBmaW5pc2hlZCBiZWZvcmUgaXQnc1xuXHRcdFx0ICogZGlzcG9zZWQuIEZpbmlzaCBoZXJlIGp1c3QgdG8gbWFrZSBzdXJlLiAqL1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kaXNjb25uZWN0ZWQpO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdkaXNwb3NlZCcpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0LyogaWYgdGhpcyB0cmFuc3BvcnQgaGFzIGJlZW4gZGlzcG9zZWQgd2hpbHN0IGF3YWl0aW5nIGNvbm5lY3Rpb24sIGRvIG5vdGhpbmcgKi9cblx0XHRpZih0aGlzLmlzRGlzcG9zZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiB0aGUgY29ubmVjdGlvbktleSBpbiBhIGNvbWV0IGNvbm5lY3RlZCByZXNwb25zZSBpcyByZWFsbHlcblx0XHQgKiA8aW5zdElkPi08Y29ubmVjdGlvbktleT4gKi9cblx0XHR2YXIgY29ubmVjdGlvblN0ciA9IG1lc3NhZ2UuY29ubmVjdGlvbktleTtcblx0XHRfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuXHRcdHZhciBiYXNlQ29ubmVjdGlvblVyaSA9ICB0aGlzLmJhc2VVcmkgKyBjb25uZWN0aW9uU3RyO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb21ldFRyYW5zcG9ydC5vbkNvbm5lY3QoKScsICdiYXNlVXJpID0gJyArIGJhc2VDb25uZWN0aW9uVXJpICsgJzsgY29ubmVjdGlvbktleSA9ICcgKyBtZXNzYWdlLmNvbm5lY3Rpb25LZXkpO1xuXHRcdHRoaXMuc2VuZFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9zZW5kJztcblx0XHR0aGlzLnJlY3ZVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvcmVjdic7XG5cdFx0dGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9jbG9zZSc7XG5cdFx0dGhpcy5kaXNjb25uZWN0VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Rpc2Nvbm5lY3QnO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdGlmKHRoaXMuc2VuZFJlcXVlc3QpIHtcblx0XHRcdC8qIHRoZXJlIGlzIGEgcGVuZGluZyBzZW5kLCBzbyBxdWV1ZSB0aGlzIG1lc3NhZ2UgKi9cblx0XHRcdHRoaXMucGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG5cdFx0XHR0aGlzLnBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvKiBzZW5kIHRoaXMsIHBsdXMgYW55IHBlbmRpbmcsIG5vdyAqL1xuXHRcdHZhciBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcblx0XHRwZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcblx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG5cblx0XHR0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kQW55UGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcztcblxuXHRcdGlmKCFwZW5kaW5nSXRlbXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG5cdFx0dGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcblx0fVxuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kSXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdHNlbmRSZXF1ZXN0ID0gdGhpcy5zZW5kUmVxdWVzdCA9IHNlbGYuY3JlYXRlUmVxdWVzdChzZWxmLnNlbmRVcmksIG51bGwsIHNlbGYuYXV0aFBhcmFtcywgdGhpcy5lbmNvZGVSZXF1ZXN0KGl0ZW1zKSwgUkVRX1NFTkQpO1xuXG5cdFx0c2VuZFJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdFx0XHRpZihlcnIpIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5zZW5kSXRlbXMoKScsICdvbiBjb21wbGV0ZTogZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0c2VsZi5zZW5kUmVxdWVzdCA9IG51bGw7XG5cblx0XHRcdC8qIHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QsIGV2ZW4gaWYgYSBuYWNrLCBpcyB1c3VhbGx5IGEgcHJvdG9jb2wgcmVzcG9uc2Vcblx0XHRcdCAqIGNvbnRhaW5lZCBpbiB0aGUgZGF0YS4gQW4gZXJyIGlzIGFub21vbG91cywgYW5kIGluZGljYXRlcyBzb21lIGlzc3VlIHdpdGggdGhlXG5cdFx0XHQgKiBuZXR3b3JrLHRyYW5zcG9ydCwgb3IgY29ubmVjdGlvbiAqL1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG5cdFx0XHRcdFx0ICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcblx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG5cdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG5cdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKGRhdGEpIHtcblx0XHRcdFx0c2VsZi5vbkRhdGEoZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHNlbGYucGVuZGluZ0l0ZW1zKSB7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogSWYgdGhlcmUncyBhIG5ldyBzZW5kIHJlcXVlc3QgYnkgbm93LCBhbnkgcGVuZGluZyBpdGVtcyB3aWxsIGhhdmVcblx0XHRcdFx0XHQgKiBiZWVuIHBpY2tlZCB1cCBieSB0aGF0OyBhbnkgbmV3IG9uZXMgYWRkZWQgc2luY2UgdGhlbiB3aWxsIGJlXG5cdFx0XHRcdFx0ICogcGlja2VkIHVwIGFmdGVyIHRoYXQgb25lIGNvbXBsZXRlcyAqL1xuXHRcdFx0XHRcdGlmKCFzZWxmLnNlbmRSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbmRBbnlQZW5kaW5nKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZW5kUmVxdWVzdC5leGVjKCk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnJlY3YgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSByZXF1ZXN0LCB3aGljaCBtaWdodCBiZSBzdHJlYW1pbmcgKi9cblx0XHRpZih0aGlzLnJlY3ZSZXF1ZXN0KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0LyogSWYgd2UncmUgbm8gbG9uZ2VyIGNvbm5lY3RlZCwgZG8gbm90aGluZyAqL1xuXHRcdGlmKCF0aGlzLmlzQ29ubmVjdGVkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0cmVjdlJlcXVlc3QgPSB0aGlzLnJlY3ZSZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KHRoaXMucmVjdlVyaSwgbnVsbCwgdGhpcy5hdXRoUGFyYW1zLCBudWxsLCAoc2VsZi5zdHJlYW0gPyBSRVFfUkVDVl9TVFJFQU0gOiBSRVFfUkVDVl9QT0xMKSk7XG5cblx0XHRyZWN2UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdH0pO1xuXHRcdHJlY3ZSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0c2VsZi5yZWN2UmVxdWVzdCA9IG51bGw7XG5cdFx0XHQvKiBBIHJlcXVlc3QgY29tcGxldGluZyBtdXN0IGJlIGNvbnNpZGVyZWQgYWN0aXZpdHksIGFzIHJlYWx0aW1lIHNlbmRzXG5cdFx0XHQgKiBoZWFydGJlYXRzIGV2ZXJ5IDE1cyBzaW5jZSBhIHJlcXVlc3QgYmVnYW4sIG5vdCBldmVyeSAxNXMgYWJzb2x1dGVseSAqL1xuXHRcdFx0c2VsZi5vbkFjdGl2aXR5KCk7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0aWYoZXJyLmNvZGUpIHtcblx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcblx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuXHRcdFx0XHRcdCAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cblx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcblx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYucmVjdigpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmVjdlJlcXVlc3QuZXhlYygpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihyZXNwb25zZURhdGEpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5kZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpO1xuXHRcdFx0aWYoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKVxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5vblByb3RvY29sTWVzc2FnZShfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbURlc2VyaWFsaXplZChpdGVtc1tpXSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5vbkRhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmVuY29kZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0SXRlbXMpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVxdWVzdEl0ZW1zKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGVjb2RlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZURhdGEpIHtcblx0XHRpZih0eXBlb2YocmVzcG9uc2VEYXRhKSA9PSAnc3RyaW5nJylcblx0XHRcdHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcblx0XHRyZXR1cm4gcmVzcG9uc2VEYXRhO1xuXHR9O1xuXG5cdC8qIEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG5cdCAqIHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cblx0ICogUHJvYmxlbSBpcyBKU09OUCAtIHlvdSBjYW4ndCBjYW5jZWwgdHJ1bHkgYWJvcnQgYSByZWN2IG9uY2Ugc3RhcnRlZC4gU29cblx0ICogd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuXHQgKiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcblx0ICogaW5zdGVhZCwgYW5kIGRvbid0IG5lZWQgdG8gYWJvcnQgdGhlIHJlY3YgKi9cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMpIHtcblx0XHR0aGlzLmF1dGhQYXJhbXMgPSB7YWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW59O1xuXHR9O1xuXG5cdHJldHVybiBDb21ldFRyYW5zcG9ydDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29tZXRUcmFuc3BvcnQpO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxudmFyIFdlYlN0b3JhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBzZXNzaW9uU3VwcG9ydGVkLFxuXHRcdGxvY2FsU3VwcG9ydGVkLFxuXHRcdHRlc3QgPSAnYWJseWpzLXN0b3JhZ2UtdGVzdCc7XG5cblx0LyogRXZlbiBqdXN0IGFjY2Vzc2luZyB0aGUgc2Vzc2lvbi9sb2NhbFN0b3JhZ2Ugb2JqZWN0IGNhbiB0aHJvdyBhXG5cdCAqIHNlY3VyaXR5IGV4Y2VwdGlvbiBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2l0aCBzb21lIGJyb3dzZXJzLiBJblxuXHQgKiBvdGhlcnMsIGNhbGxpbmcgc2V0SXRlbSB3aWxsIHRocm93LiBTbyBoYXZlIHRvIGNoZWNrIGluIHRoaXNcblx0ICogc29tZXdoYXQgcm91bmRhYm91dCB3YXkuIChJZiB1bnN1cHBvcnRlZCBvciBubyBnbG9iYWwgb2JqZWN0LFxuXHQgKiB3aWxsIHRocm93IG9uIGFjY2Vzc2luZyBhIHByb3BlcnR5IG9mIHVuZGVmaW5lZCkgKi9cblx0dHJ5IHtcblx0XHRnbG9iYWwuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcblx0XHRnbG9iYWwuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcblx0XHRzZXNzaW9uU3VwcG9ydGVkID0gdHJ1ZTtcblx0fSBjYXRjaChlKSB7XG5cdFx0c2Vzc2lvblN1cHBvcnRlZCA9IGZhbHNlO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG5cdFx0Z2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuXHRcdGxvY2FsU3VwcG9ydGVkID0gdHJ1ZTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bG9jYWxTdXBwb3J0ZWQgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYlN0b3JhZ2UoKSB7fVxuXG5cdGZ1bmN0aW9uIHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikge1xuXHRcdHJldHVybiBzZXNzaW9uID8gZ2xvYmFsLnNlc3Npb25TdG9yYWdlIDogZ2xvYmFsLmxvY2FsU3RvcmFnZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSwgdHRsLCBzZXNzaW9uKSB7XG5cdFx0dmFyIHdyYXBwZWRWYWx1ZSA9IHt2YWx1ZTogdmFsdWV9O1xuXHRcdGlmKHR0bCkge1xuXHRcdFx0d3JhcHBlZFZhbHVlLmV4cGlyZXMgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgKyB0dGw7XG5cdFx0fVxuXHRcdHJldHVybiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkod3JhcHBlZFZhbHVlKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXQobmFtZSwgc2Vzc2lvbikge1xuXHRcdHZhciByYXdJdGVtID0gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5nZXRJdGVtKG5hbWUpO1xuXHRcdGlmKCFyYXdJdGVtKSByZXR1cm4gbnVsbDtcblx0XHR2YXIgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcblx0XHRpZih3cmFwcGVkVmFsdWUuZXhwaXJlcyAmJiAod3JhcHBlZFZhbHVlLmV4cGlyZXMgPCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkpKSB7XG5cdFx0XHRzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHdyYXBwZWRWYWx1ZS52YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZShuYW1lLCBzZXNzaW9uKSB7XG5cdFx0cmV0dXJuIHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcblx0fVxuXG5cdGlmKGxvY2FsU3VwcG9ydGVkKSB7XG5cdFx0V2ViU3RvcmFnZS5zZXQgICAgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgdHRsKSB7IHJldHVybiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgZmFsc2UpOyB9O1xuXHRcdFdlYlN0b3JhZ2UuZ2V0ICAgID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gZ2V0KG5hbWUsIGZhbHNlKTsgfTtcblx0XHRXZWJTdG9yYWdlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIHJlbW92ZShuYW1lLCBmYWxzZSk7IH07XG5cdH1cblxuXHRpZihzZXNzaW9uU3VwcG9ydGVkKSB7XG5cdFx0V2ViU3RvcmFnZS5zZXRTZXNzaW9uICAgID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHR0bCkgeyByZXR1cm4gc2V0KG5hbWUsIHZhbHVlLCB0dGwsIHRydWUpOyB9O1xuXHRcdFdlYlN0b3JhZ2UuZ2V0U2Vzc2lvbiAgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGdldChuYW1lLCB0cnVlKTsgfTtcblx0XHRXZWJTdG9yYWdlLnJlbW92ZVNlc3Npb24gPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiByZW1vdmUobmFtZSwgdHJ1ZSk7IH07XG5cdH1cblxuXHRyZXR1cm4gV2ViU3RvcmFnZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV2ViU3RvcmFnZSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gYml0c0NvbWJpbmVkIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXG5cblxuXG5cblxudmFyIENyeXB0byA9IChmdW5jdGlvbigpIHtcblx0dmFyIERFRkFVTFRfQUxHT1JJVEhNID0gJ2Flcyc7XG5cdHZhciBERUZBVUxUX0tFWUxFTkdUSCA9IDI1NjsgLy8gYml0c1xuXHR2YXIgREVGQVVMVF9NT0RFID0gJ2NiYyc7XG5cdHZhciBERUZBVUxUX0JMT0NLTEVOR1RIID0gMTY7IC8vIGJ5dGVzXG5cdHZhciBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTID0gNDsgLy8gMzItYml0IHdvcmRzXG5cdHZhciBVSU5UMzJfU1VQID0gMHgxMDAwMDAwMDA7XG5cdHZhciBJTlQzMl9TVVAgPSAweDgwMDAwMDAwO1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogZ2VuZXJhdGUgYW4gYXJyYXkgb2Ygc2VjdXJlIHJhbmRvbSB3b3JkcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsZW5ndGggb2YgYnl0ZXNcblx0ICogQHBhcmFtIGJ5dGVzXG5cdCAqIEBwYXJhbSBjYWxsYmFja1xuXHQgKi9cblx0dmFyIGdlbmVyYXRlUmFuZG9tO1xuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVdvcmRBcnJheSkge1xuXHRcdGdlbmVyYXRlUmFuZG9tID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21Xb3JkQXJyYXk7XG5cdH0gZWxzZSBpZih0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdFx0dmFyIGJsb2NrUmFuZG9tQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyk7XG5cdFx0Z2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbihieXRlcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciB3b3JkcyA9IGJ5dGVzIC8gNCwgbmF0aXZlQXJyYXkgPSAod29yZHMgPT0gREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUykgPyBibG9ja1JhbmRvbUFycmF5IDogbmV3IFVpbnQzMkFycmF5KHdvcmRzKTtcblx0XHRcdHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycmF5LCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyLCBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KG5hdGl2ZUFycmF5KSlcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Z2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbihieXRlcywgY2FsbGJhY2spIHtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01BSk9SLCAnQWJseS5DcnlwdG8uZ2VuZXJhdGVSYW5kb20oKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21uZXNzIGdlbmVyYXRpb247IGZhbGxpbmcgYmFjayB0byBpbnNlY3VyZSBNYXRoLnJhbmRvbSgpJyk7XG5cdFx0XHR2YXIgd29yZHMgPSBieXRlcyAvIDQsIGFycmF5ID0gbmV3IEFycmF5KHdvcmRzKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB3b3JkczsgaSsrKSB7XG5cdFx0XHRcdC8qIGNyeXB0b2pzIHdvcmRhcnJheXMgdXNlIHNpZ25lZCBpbnRzLiBXaGVuIFdvcmRBcnJheS5jcmVhdGUgaXMgZmVkIGFcblx0XHRcdFx0KiBVaW50MzJBcnJheSB1bnNpZ25lZCBhcmUgY29udmVydGVkIHRvIHNpZ25lZCBhdXRvbWF0aWNhbGx5LCBidXQgd2hlblxuXHRcdFx0XHQqIGZlZCBhIG5vcm1hbCBhcnJheSB0aGV5IGFyZW4ndCwgc28gbmVlZCB0byBkbyBzbyBvdXJzZWx2ZXMgYnlcblx0XHRcdFx0KiBzdWJ0cmFjdGluZyBJTlQzMl9TVVAgKi9cblx0XHRcdFx0YXJyYXlbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBVSU5UMzJfU1VQKSAtIElOVDMyX1NVUDtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoYXJyYXkpKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBjYWxjdWxhdGUgdGhlIHBhZGRlZCBsZW5ndGggb2YgYSBnaXZlbiBwbGFpbnRleHRcblx0ICogdXNpbmcgUEtDUzUuXG5cdCAqIEBwYXJhbSBwbGFpbnRleHRMZW5ndGhcblx0ICogQHJldHVyblxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCkge1xuXHRcdHJldHVybiAocGxhaW50ZXh0TGVuZ3RoICsgREVGQVVMVF9CTE9DS0xFTkdUSCkgJiAtREVGQVVMVF9CTE9DS0xFTkdUSDtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogY2hlY2tzIHRoYXQgdGhlIGNpcGhlclBhcmFtcyBhcmUgYSB2YWxpZCBjb21iaW5hdGlvbi4gQ3VycmVudGx5XG5cdCAqIGp1c3QgY2hlY2tzIHRoYXQgdGhlIGNhbGN1bGF0ZWQga2V5TGVuZ3RoIGlzIGEgdmFsaWQgb25lIGZvciBhZXMtY2JjXG5cdCAqL1xuXHRmdW5jdGlvbiB2YWxpZGF0ZUNpcGhlclBhcmFtcyhwYXJhbXMpIHtcblx0XHRpZihwYXJhbXMuYWxnb3JpdGhtID09PSAnYWVzJyAmJiBwYXJhbXMubW9kZSA9PT0gJ2NiYycpIHtcblx0XHRcdGlmKHBhcmFtcy5rZXlMZW5ndGggPT09IDEyOCB8fCBwYXJhbXMua2V5TGVuZ3RoID09PSAyNTYpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoICcgKyBwYXJhbXMua2V5TGVuZ3RoICsgJyBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycyknKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBub3JtYWxpc2VCYXNlNjQoc3RyaW5nKSB7XG5cdFx0LyogdXJsLXNhZmUgYmFzZTY0IHN0cmluZ3MgdXNlIF8gYW5kIC0gaW5zdHJlYWQgb2YgLyBhbmQgKyAqL1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgnXycsICcvJykucmVwbGFjZSgnLScsICcrJyk7XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGEgYmxvY2sgY29udGFpbmluZyB6ZXJvc1xuXHQgKi9cblx0dmFyIGVtcHR5QmxvY2sgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMCwwLDAsMF0pO1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogb2J0YWluIHRoZSBwa2NzNSBwYWRkaW5nIHN0cmluZyBmb3IgYSBnaXZlbiBwYWRkZWQgbGVuZ3RoO1xuXHQgKi9cblx0dmFyIHBrY3M1UGFkZGluZyA9IFtcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMF0sIDE2KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMTAwMDAwMF0sIDEpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAyMDIwMDAwXSwgMiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDMwMzAzMDBdLCAzKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNDA0MDQwNF0sIDQpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA1MDUwNTA1LDB4MDUwMDAwMDBdLCA1KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNjA2MDYwNiwweDA2MDYwMDAwXSwgNiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDcwNzA3MDcsMHgwNzA3MDcwMF0sIDcpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA4MDgwODA4LDB4MDgwODA4MDhdLCA4KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwOTA5MDkwOSwweDA5MDkwOTA5LDB4MDkwMDAwMDBdLCA5KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYTBhMGEwYSwweDBhMGEwYTBhLDB4MGEwYTAwMDBdLCAxMCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGIwYjBiMGIsMHgwYjBiMGIwYiwweDBiMGIwYjAwXSwgMTEpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBjMGMwYzBjLDB4MGMwYzBjMGMsMHgwYzBjMGMwY10sIDEyKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZDBkMGQwZCwweDBkMGQwZDBkLDB4MGQwZDBkMGQsMHgwZDAwMDAwMF0sIDEzKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZTBlMGUwZSwweDBlMGUwZTBlLDB4MGUwZTBlMGUsMHgwZTBlMDAwMF0sIDE0KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZjBmMGYwZiwweDBmMGYwZjBmLDB4MGYwZjBmMGYsMHgwZjBmMGYwZl0sIDE1KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMF0sIDE2KVxuXHRdO1xuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGNsYXNzZXMgYW5kIGludGVyZmFjZXMgZm9yIG1lc3NhZ2UgcGF5bG9hZCBlbmNyeXB0aW9uLlxuXHQgKlxuXHQgKiBUaGlzIGNsYXNzIHN1cHBvcnRzIEFFUy9DQkMvUEtDUzUgd2l0aCBhIGRlZmF1bHQga2V5bGVuZ3RoIG9mIDEyOCBiaXRzXG5cdCAqIGJ1dCBzdXBwb3J0aW5nIG90aGVyIGtleWxlbmd0aHMuIE90aGVyIGFsZ29yaXRobXMgYW5kIGNoYWluaW5nIG1vZGVzIGFyZVxuXHQgKiBub3Qgc3VwcG9ydGVkIGRpcmVjdGx5LCBidXQgc3VwcG9ydGFibGUgYnkgZXh0ZW5kaW5nL2ltcGxlbWVudGluZyB0aGUgYmFzZVxuXHQgKiBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGhlcmUuXG5cdCAqXG5cdCAqIFNlY3VyZSByYW5kb20gZGF0YSBmb3IgY3JlYXRpb24gb2YgSW5pdGlhbGl6YXRpb24gVmVjdG9ycyAoSVZzKSBhbmQga2V5c1xuXHQgKiBpcyBvYnRhaW5lZCBmcm9tIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGlmIGF2YWlsYWJsZSwgb3IgZnJvbVxuXHQgKiBNYXRoLnJhbmRvbSgpIGlmIG5vdC4gQ2xpZW50cyB3aG8gZG8gbm90IHdhbnQgdG8gZGVwZW5kIG9uIE1hdGgucmFuZG9tKClcblx0ICogc2hvdWxkIHBvbHlmaWxsIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHdpdGggYSBsaWJyYXJ5IHRoYXQgc2VlZHNcblx0ICogYSBQUk5HIHdpdGggcmVhbCBlbnRyb3B5LlxuXHQgKlxuXHQgKiBFYWNoIG1lc3NhZ2UgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgd2l0aCBhbiBJViBpbiBDQkMgbW9kZSwgYW5kIHRoZSBJViBpc1xuXHQgKiBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcmVzdWx0aW5nIHJhdyBjaXBoZXJ0ZXh0IHRvIGNvbnN0cnVjdCB0aGUgXCJjaXBoZXJ0ZXh0XCJcblx0ICogZGF0YSBwYXNzZWQgdG8gdGhlIHJlY2lwaWVudC5cblx0ICovXG5cdGZ1bmN0aW9uIENyeXB0bygpIHt9XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgZW5jYXBzdWxhdGluZyB0aGUgY2xpZW50LXNwZWNpZmlhYmxlIHBhcmFtZXRlcnMgZm9yXG5cdCAqIHRoZSBjaXBoZXIuXG5cdCAqXG5cdCAqIGFsZ29yaXRobSBpcyB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtIGluIHRoZSBkZWZhdWx0IHN5c3RlbSBwcm92aWRlcixcblx0ICogb3IgdGhlIGxvd2VyLWNhc2VkIHZlcnNpb24gb2YgaXQ7IGVnIFwiYWVzXCIgb3IgXCJBRVNcIi5cblx0ICpcblx0ICogQ2xpZW50cyBhcmUgcmVjb21tZW5kZWQgdG8gbm90IGNhbGwgdGhpcyBkaXJlY3RseSwgYnV0IGluc3RlYWQgdG8gdXNlIHRoZVxuXHQgKiBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyBoZWxwZXIsIHdoaWNoIHdpbGwgZmlsbCBpbiBhbnkgZmllbGRzIG5vdCBzdXBwbGllZFxuXHQgKiB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCB2YWxpZGF0aW9uIHRoZSByZXN1bHQuXG5cdCAqL1xuXHRmdW5jdGlvbiBDaXBoZXJQYXJhbXMoKSB7XG5cdFx0dGhpcy5hbGdvcml0aG0gPSBudWxsO1xuXHRcdHRoaXMua2V5TGVuZ3RoID0gbnVsbDtcblx0XHR0aGlzLm1vZGUgPSBudWxsO1xuXHRcdHRoaXMua2V5ID0gbnVsbDtcblx0fVxuXHRDcnlwdG8uQ2lwaGVyUGFyYW1zID0gQ2lwaGVyUGFyYW1zO1xuXG5cdC8qKlxuXHQgKiBPYnRhaW4gYSBjb21wbGV0ZSBDaXBoZXJQYXJhbXMgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgcGFyYW1zLCBmaWxsaW5nXG5cdCAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxuXHQgKiB0aGUgc3VwcGxpZWQga2V5LCBhbmQgdmFsaWRhdGluZyB0aGUgcmVzdWx0LlxuXHQgKiBAcGFyYW0gcGFyYW1zIGFuIG9iamVjdCBjb250YWluaW5nIGF0IGEgbWluaW11bSBhIGBrZXlgIGtleSB3aXRoIHZhbHVlIHRoZVxuXHQgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSAoQXJyYXlCdWZmZXIsIEFycmF5LCBXb3JkQXJyYXkpIG9yIGFcblx0ICogYmFzZTY0LWVuY29kZWQgc3RyaW5nLiBNYXkgb3B0aW9uYWxseSBhbHNvIGNvbnRhaW46IGFsZ29yaXRobSAoZGVmYXVsdHMgdG9cblx0ICogQUVTKSwgbW9kZSAoZGVmYXVsdHMgdG8gJ2NiYycpXG5cdCAqL1xuXHRDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHZhciBrZXk7XG5cdFx0LyogQmFja3dhcmQgY29tcGF0aWJpbGl0eSAqL1xuXHRcdGlmKCh0eXBlb2YocGFyYW1zKSA9PT0gJ2Z1bmN0aW9uJykgfHwgKHR5cGVvZihwYXJhbXMpID09PSAnc3RyaW5nJykpIHtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVwcmVjYXRlZCgnQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoa2V5LCBjYWxsYmFjayknLCAnQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoe2tleToga2V5fSknKTtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleShmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRwYXJhbXMobnVsbCwgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMoe2tleToga2V5fSkpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0YXJndW1lbnRzWzFdKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IHBhcmFtc30pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgZm9yIENyeXB0by5nZXREZWZhdWx0UGFyYW1zJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoIXBhcmFtcy5rZXkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZihwYXJhbXMua2V5KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGtleSA9IE9iamVjdChjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicGFyc2VcIl0pKG5vcm1hbGlzZUJhc2U2NChwYXJhbXMua2V5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7IC8vIEV4cGVjdCBrZXkgdG8gYmUgYW4gQXJyYXksIEFycmF5QnVmZmVyLCBvciBXb3JkQXJyYXkgYXQgdGhpcyBwb2ludFxuXHRcdH1cblxuXHRcdHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKCk7XG5cdFx0Y2lwaGVyUGFyYW1zLmtleSA9IGtleTtcblx0XHRjaXBoZXJQYXJhbXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcblx0XHRjaXBoZXJQYXJhbXMua2V5TGVuZ3RoID0ga2V5LndvcmRzLmxlbmd0aCAqICg0ICogOCk7XG5cdFx0Y2lwaGVyUGFyYW1zLm1vZGUgPSBwYXJhbXMubW9kZSB8fCBERUZBVUxUX01PREU7XG5cblx0XHRpZihwYXJhbXMua2V5TGVuZ3RoICYmIHBhcmFtcy5rZXlMZW5ndGggIT09IGNpcGhlclBhcmFtcy5rZXlMZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5TGVuZ3RoIG9mICcgKyBwYXJhbXMua2V5TGVuZ3RoICsgJyB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoICcgKyBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKTtcblx0XHR9XG5cblx0XHR2YWxpZGF0ZUNpcGhlclBhcmFtcyhjaXBoZXJQYXJhbXMpO1xuXHRcdHJldHVybiBjaXBoZXJQYXJhbXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IGZyb20gdGhlIHN1cHBsaWVkIGtleWxlbmd0aCAob3IgdGhlXG5cdCAqIGRlZmF1bHQga2V5TGVuZ3RoIGlmIG5vbmUgc3VwcGxpZWQpIGFzIGEgQ3J5cHRvSlMgV29yZEFycmF5XG5cdCAqIEBwYXJhbSBrZXlMZW5ndGggKG9wdGlvbmFsKSB0aGUgcmVxdWlyZWQga2V5TGVuZ3RoIGluIGJpdHNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIGtleSlcblx0ICovXG5cdENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleSA9IGZ1bmN0aW9uKGtleUxlbmd0aCwgY2FsbGJhY2spIHtcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGtleUxlbmd0aCkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sgPSBrZXlMZW5ndGg7XG5cdFx0XHRrZXlMZW5ndGggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGdlbmVyYXRlUmFuZG9tKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDsgZ2V0IGEgQ2hhbm5lbENpcGhlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2lwaGVyUGFyYW1zXG5cdCAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuXHQgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuXHQgKi9cblx0Q3J5cHRvLmdldENpcGhlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHZhciBjaXBoZXJQYXJhbXMgPSAocGFyYW1zIGluc3RhbmNlb2YgQ2lwaGVyUGFyYW1zKSA/XG5cdFx0ICAgICAgICAgICAgICAgICAgIHBhcmFtcyA6XG5cdFx0ICAgICAgICAgICAgICAgICAgIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHBhcmFtcyk7XG5cblx0XHRyZXR1cm4ge2NpcGhlclBhcmFtczogY2lwaGVyUGFyYW1zLCBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTLCBwYXJhbXMuaXYpfTtcblx0fTtcblxuXHRmdW5jdGlvbiBDQkNDaXBoZXIocGFyYW1zLCBibG9ja0xlbmd0aFdvcmRzLCBpdikge1xuXHRcdHRoaXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSArICctJyArIFN0cmluZyhwYXJhbXMua2V5TGVuZ3RoKSArICctJyArIHBhcmFtcy5tb2RlO1xuXHRcdHRoaXMuY2pzQWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy1cXGQrJC8sICcnKTtcblx0XHR0aGlzLmtleSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7XG5cdFx0aWYoaXYpIHtcblx0XHRcdHRoaXMuaXYgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KGl2KS5jbG9uZSgpO1xuXHRcdH1cblx0XHR0aGlzLmJsb2NrTGVuZ3RoV29yZHMgPSBibG9ja0xlbmd0aFdvcmRzO1xuXHR9XG5cblx0Q0JDQ2lwaGVyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0LCBjYWxsYmFjaykge1xuXHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ0JDQ2lwaGVyLmVuY3J5cHQoKScsICcnKTtcblx0XHRwbGFpbnRleHQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBsYWludGV4dCk7XG5cdFx0dmFyIHBsYWludGV4dExlbmd0aCA9IHBsYWludGV4dC5zaWdCeXRlcyxcblx0XHRcdHBhZGRlZExlbmd0aCA9IGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHR2YXIgdGhlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5nZXRJdihmdW5jdGlvbihlcnIsIGl2KSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY2lwaGVyT3V0ID0gc2VsZi5lbmNyeXB0Q2lwaGVyLnByb2Nlc3MocGxhaW50ZXh0LmNvbmNhdChwa2NzNVBhZGRpbmdbcGFkZGVkTGVuZ3RoIC0gcGxhaW50ZXh0TGVuZ3RoXSkpO1xuXHRcdFx0XHR2YXIgY2lwaGVydGV4dCA9IGl2LmNvbmNhdChjaXBoZXJPdXQpO1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBjaXBoZXJ0ZXh0KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMuZW5jcnlwdENpcGhlcikge1xuXHRcdFx0aWYodGhpcy5pdikge1xuXHRcdFx0XHR0aGlzLmVuY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRW5jcnlwdG9yKHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuXHRcdFx0XHR0aGVuKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RILCBmdW5jdGlvbihlcnIsIGl2KSB7XG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bc2VsZi5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcihzZWxmLmtleSwgeyBpdjogaXYgfSk7XG5cdFx0XHRcdFx0c2VsZi5pdiA9IGl2O1xuXHRcdFx0XHRcdHRoZW4oKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoZW4oKTtcblx0XHR9XG5cdH07XG5cblx0Q0JDQ2lwaGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ0JDQ2lwaGVyLmRlY3J5cHQoKScsICcnKTtcblx0XHRjaXBoZXJ0ZXh0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShjaXBoZXJ0ZXh0KTtcblx0XHR2YXIgYmxvY2tMZW5ndGhXb3JkcyA9IHRoaXMuYmxvY2tMZW5ndGhXb3Jkcyxcblx0XHRcdGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHMsXG5cdFx0XHRpdiA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgwLCBibG9ja0xlbmd0aFdvcmRzKSksXG5cdFx0XHRjaXBoZXJ0ZXh0Qm9keSA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZShibG9ja0xlbmd0aFdvcmRzKSk7XG5cblx0XHR2YXIgZGVjcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVEZWNyeXB0b3IodGhpcy5rZXksIHsgaXY6IGl2IH0pO1xuXHRcdHZhciBwbGFpbnRleHQgPSBkZWNyeXB0Q2lwaGVyLnByb2Nlc3MoY2lwaGVydGV4dEJvZHkpO1xuXHRcdHZhciBlcGlsb2d1ZSA9IGRlY3J5cHRDaXBoZXIuZmluYWxpemUoKTtcblx0XHRkZWNyeXB0Q2lwaGVyLnJlc2V0KCk7XG5cdFx0aWYoZXBpbG9ndWUgJiYgZXBpbG9ndWUuc2lnQnl0ZXMpIHBsYWludGV4dC5jb25jYXQoZXBpbG9ndWUpO1xuXHRcdHJldHVybiBwbGFpbnRleHQ7XG5cdH07XG5cblx0Q0JDQ2lwaGVyLnByb3RvdHlwZS5nZXRJdiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0aWYodGhpcy5pdikge1xuXHRcdFx0dmFyIGl2ID0gdGhpcy5pdjtcblx0XHRcdHRoaXMuaXYgPSBudWxsO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgaXYpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIFNpbmNlIHRoZSBpdiBmb3IgYSBuZXcgYmxvY2sgaXMgdGhlIGNpcGhlcnRleHQgb2YgdGhlIGxhc3QsIHRoaXNcblx0XHQqIHNldHMgYSBuZXcgaXYgKD0gYWVzKHJhbmRvbUJsb2NrIFhPUiBsYXN0Q2lwaGVyVGV4dCkpIGFzIHdlbGwgYXNcblx0XHQqIHJldHVybmluZyBpdCAqL1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RILCBmdW5jdGlvbihlcnIsIHJhbmRvbUJsb2NrKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gXG5cdFx0XHRjYWxsYmFjayhudWxsLCBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhyYW5kb21CbG9jaykpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBDcnlwdG87XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENyeXB0byk7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG5cbnZhciBUcmFuc3BvcnQgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBhY3Rpb25zID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbjtcblx0dmFyIGNsb3NlTWVzc2FnZSA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuQ0xPU0V9KTtcblx0dmFyIGRpc2Nvbm5lY3RNZXNzYWdlID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5ESVNDT05ORUNUfSk7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKlxuXHQgKiBFdmVudEVtaXR0ZXIsIGdlbmVyYXRlcyB0aGUgZm9sbG93aW5nIGV2ZW50czpcblx0ICpcblx0ICogZXZlbnQgbmFtZSAgICAgICBkYXRhXG5cdCAqIGNsb3NlZCAgICAgICAgICAgZXJyb3Jcblx0ICogZmFpbGVkICAgICAgICAgICBlcnJvclxuXHQgKiBkaXNwb3NlZFxuXHQgKiBjb25uZWN0ZWQgICAgICAgIG51bGwgZXJyb3IsIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHNcblx0ICogc3luYyAgICAgICAgICAgICBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWRcblx0ICogZXZlbnQgICAgICAgICAgICBjaGFubmVsIG1lc3NhZ2Ugb2JqZWN0XG5cdCAqL1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQodGhpcyk7XG5cdFx0dGhpcy5hdXRoID0gYXV0aDtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0XHR0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG5cdFx0dGhpcy5mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFRyYW5zcG9ydCwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge307XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdENsb3NlKCk7XG5cdFx0fVxuXHRcdHRoaXMuZmluaXNoKCdjbG9zZWQnLCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNsb3NlZCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0LyogVXNlZCBmb3IgbmV0d29yay90cmFuc3BvcnQgaXNzdWVzIHRoYXQgbmVlZCB0byByZXN1bHQgaW4gdGhlIHRyYW5zcG9ydFxuXHRcdCAqIGJlaW5nIGRpc2Nvbm5lY3RlZCwgYnV0IHNob3VsZCBub3QgYWZmZWN0IHRoZSBjb25uZWN0aW9uICovXG5cdFx0aWYodGhpcy5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuXHRcdH1cblx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGlzY29ubmVjdGVkKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbihlcnIpIHtcblx0XHQvKiBVc2VkIGZvciBjbGllbnQtc2lkZS1kZXRlY3RlZCBmYXRhbCBjb25uZWN0aW9uIGlzc3VlcyAqL1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVyciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZhaWxlZCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihldmVudCwgZXJyKSB7XG5cdFx0aWYodGhpcy5pc0ZpbmlzaGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblx0XHR0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lcik7XG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xuXHRcdHRoaXMuZW1pdChldmVudCwgZXJyKTtcblx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uUHJvdG9jb2xNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdGlmIChfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zaG91bGRMb2coX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPKSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG9uICcgKyB0aGlzLnNob3J0TmFtZSArICc6ICcgKyBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5naWZ5KG1lc3NhZ2UpICsgJzsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcblx0XHR9XG5cdFx0dGhpcy5vbkFjdGl2aXR5KCk7XG5cblx0XHRzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcblx0XHRjYXNlIGFjdGlvbnMuSEVBUlRCRUFUOlxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgdGhpcy5zaG9ydE5hbWUgKyAnIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcblx0XHRcdHRoaXMuZW1pdCgnaGVhcnRiZWF0JywgbWVzc2FnZS5pZCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQ09OTkVDVEVEOlxuXHRcdFx0dGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XG5cdFx0XHR0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIG1lc3NhZ2UuZXJyb3IsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLCBtZXNzYWdlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5DTE9TRUQ6XG5cdFx0XHR0aGlzLm9uQ2xvc2UobWVzc2FnZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuRElTQ09OTkVDVEVEOlxuXHRcdFx0dGhpcy5vbkRpc2Nvbm5lY3QobWVzc2FnZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQUNLOlxuXHRcdFx0dGhpcy5lbWl0KCdhY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuTkFDSzpcblx0XHRcdHRoaXMuZW1pdCgnbmFjaycsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50LCBtZXNzYWdlLmVycm9yKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5TWU5DOlxuXHRcdFx0aWYobWVzc2FnZS5jb25uZWN0aW9uSWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvKiBhIHRyYW5zcG9ydCBTWU5DICovXG5cdFx0XHRcdHRoaXMuZW1pdCgnc3luYycsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwgU1lOQywgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQVVUSDpcblx0XHRcdHRoaXMuYXV0aC5hdXRob3JpemUoZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuRVJST1I6XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgKyAnOyBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KG1lc3NhZ2UuZXJyb3IpICsgKG1lc3NhZ2UuY2hhbm5lbCA/ICgnLCBjaGFubmVsOiAnICsgIG1lc3NhZ2UuY2hhbm5lbCkgOiAnJykpO1xuXHRcdFx0aWYobWVzc2FnZS5jaGFubmVsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5vbkZhdGFsRXJyb3IobWVzc2FnZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Lyogb3RoZXJ3aXNlIGl0J3MgYSBjaGFubmVsLXNwZWNpZmljIGVycm9yLCBzbyBoYW5kbGUgaXQgaW4gdGhlIGNoYW5uZWwgKi9cblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHQvKiBhbGwgb3RoZXIgYWN0aW9ucyBhcmUgY2hhbm5lbC1zcGVjaWZpYyAqL1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcblx0XHR2YXIgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG5cdFx0aWYobWF4UHJvbWlzZWRJZGxlKSB7XG5cdFx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG1heFByb21pc2VkSWRsZSArIHRoaXMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcblx0XHRcdHRoaXMub25BY3Rpdml0eSgpO1xuXHRcdH1cblx0XHQvKiBlbHNlIFJlYWx0aW1lIGRlY2xpbmVzIHRvIGd1YXJhbnRlZSBhbnkgbWF4aW11bSBpZGxlIGludGVydmFsIC0gQ0QyaCAqL1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25EaXNjb25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8qIFVzZWQgZm9yIHdoZW4gdGhlIHNlcnZlciBoYXMgZGlzY29ubmVjdGVkIHRoZSBjbGllbnQgKHVzdWFsbHkgd2l0aCBhXG5cdFx0ICogRElTQ09OTkVDVEVEIGFjdGlvbikgKi9cblx0XHR2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25EaXNjb25uZWN0KCknLCAnZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25GYXRhbEVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8qIE9uIHJlY2VpcHQgb2YgYSBmYXRhbCBjb25uZWN0aW9uIGVycm9yLCB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhlIHNlcnZlclxuXHRcdCAqIHdpbGwgY2xvc2UgdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSB0cmFuc3BvcnQsIGFuZCBkbyBub3QgbmVlZCB0byByZXF1ZXN0XG5cdFx0ICogYSBkaXNjb25uZWN0aW9uIC0gUlROMTVpICovXG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpJywgJ2VyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHR0aGlzLmZpbmlzaCgnZmFpbGVkJywgZXJyKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uQ2xvc2UoKScsICdlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0dGhpcy5maW5pc2goJ2Nsb3NlZCcsIGVycik7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJywgJycpO1xuXHRcdHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KCknLCAnJyk7XG5cdFx0dGhpcy5zZW5kKGRpc2Nvbm5lY3RNZXNzYWdlKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBtc2cgPSB7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkhFQVJUQkVBVH07XG5cdFx0aWYoaWQpIG1zZy5pZCA9IGlkO1xuXHRcdHRoaXMuc2VuZChfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhtc2cpKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcblx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHRcdHRoaXMub2ZmKCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkFjdGl2aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoIXRoaXMubWF4SWRsZUludGVydmFsKSB7IHJldHVybjsgfVxuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5sYXN0QWN0aXZpdHkgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpO1xuXHRcdHRoaXMuc2V0SWRsZVRpbWVyKHRoaXMubWF4SWRsZUludGVydmFsICsgMTAwKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnNldElkbGVUaW1lciA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuaWRsZVRpbWVyKSB7XG5cdFx0XHR0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYub25JZGxlVGltZXJFeHBpcmUoKTtcblx0XHRcdH0sIHRpbWVvdXQpO1xuXHRcdH1cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uSWRsZVRpbWVyRXhwaXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xuXHRcdHZhciBzaW5jZUxhc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHksXG5cdFx0XHR0aW1lUmVtYWluaW5nID0gdGhpcy5tYXhJZGxlSW50ZXJ2YWwgLSBzaW5jZUxhc3Q7XG5cdFx0aWYodGltZVJlbWFpbmluZyA8PSAwKSB7XG5cdFx0XHR2YXIgbXNnID0gJ05vIGFjdGl2aXR5IHNlZW4gZnJvbSByZWFsdGltZSBpbiAnICsgc2luY2VMYXN0ICsgJ21zOyBhc3N1bWluZyBjb25uZWN0aW9uIGhhcyBkcm9wcGVkJztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKScsIG1zZyk7XG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDAzLCA0MDgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRJZGxlVGltZXIodGltZVJlbWFpbmluZyArIDEwMCk7XG5cdFx0fVxuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uKCkge307XG5cblx0cmV0dXJuIFRyYW5zcG9ydDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVHJhbnNwb3J0KTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIENvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXRyeUluLCByZWFzb24pIHtcblx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcblx0XHRpZihyZXRyeUluKSB0aGlzLnJldHJ5SW4gPSByZXRyeUluO1xuXHRcdGlmKHJlYXNvbikgdGhpcy5yZWFzb24gPSByZWFzb247XG5cdH1cblxuXHRyZXR1cm4gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG52YXIgTXVsdGljYXN0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gTXVsdGljYXN0ZXIobWVtYmVycykge1xuXHRcdG1lbWJlcnMgPSBtZW1iZXJzIHx8IFtdO1xuXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBtZW1iZXIgPSBtZW1iZXJzW2ldO1xuXHRcdFx0XHRpZihtZW1iZXIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bWVtYmVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fSBjYXRjaChlKXtcblx0XHRcdFx0XHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ011bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXInLCAnVW5leHBlY3RlZCBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgZS5zdGFjayk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGhhbmRsZXIucHVzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWVtYmVycywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdHJldHVybiBoYW5kbGVyO1xuXHR9XG5cblx0cmV0dXJuIE11bHRpY2FzdGVyO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChNdWx0aWNhc3Rlcik7XG5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cblxuXG5cblxudmFyIEVycm9yUmVwb3J0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIEVycm9yUmVwb3J0ZXIoKSB7fVxuXG5cdHZhciBsZXZlbHMgPSBFcnJvclJlcG9ydGVyLmxldmVscyA9IFtcblx0XHQnZmF0YWwnLFxuXHRcdCdlcnJvcicsXG5cdFx0J3dhcm5pbmcnLFxuXHRcdCdpbmZvJyxcblx0XHQnZGVidWcnXG5cdF07XG5cblx0LyogKGxldmVsOiB0eXBlb2YgRXJyb3JSZXBvcnRlci5sZXZlbHNbbnVtYmVyXSwgbWVzc2FnZTogc3RyaW5nLCBmaW5nZXJwcmludD86IHN0cmluZywgdGFncz86IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9KTogdm9pZCAqL1xuXHRFcnJvclJlcG9ydGVyLnJlcG9ydCA9IGZ1bmN0aW9uKGxldmVsLCBtZXNzYWdlLCBmaW5nZXJwcmludCwgdGFncykge1xuXHRcdHZhciBldmVudElkID0gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmFuZG9tSGV4U3RyaW5nKDE2KTtcblxuXHRcdHZhciBldmVudCA9IHtcblx0XHRcdGV2ZW50X2lkOiBldmVudElkLFxuXHRcdFx0dGFnczogX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4oe1xuXHRcdFx0XHRhYmx5QWdlbnQ6IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWdlbnRcblx0XHRcdH0sIHRhZ3MpLFxuXHRcdFx0cGxhdGZvcm06ICdqYXZhc2NyaXB0Jyxcblx0XHRcdGxldmVsOiBsZXZlbCxcblx0XHRcdHJlbGVhc2U6IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0udmVyc2lvbixcblx0XHRcdGZpbmdlcnByaW50OiBmaW5nZXJwcmludCAmJiBbIGZpbmdlcnByaW50IF0sXG5cdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0cmVxdWVzdDoge1xuXHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0J1VzZXItQWdlbnQnOiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVzZXJBZ2VudFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cmw6IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY3VycmVudFVybFxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdFcnJvclJlcG9ydGVyJywgJ1BPU1RpbmcgdG8gZXJyb3IgcmVwb3J0ZXI6ICcgKyBtZXNzYWdlKTtcblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucG9zdFVyaShudWxsLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVycm9yUmVwb3J0aW5nVXJsLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVycm9yUmVwb3J0aW5nSGVhZGVycywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpLCB7fSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcblx0XHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Vycm9yUmVwb3J0ZXInLCAnUE9TVGluZyB0byBlcnJvciByZXBvcnRlciByZXN1bHRlZCBpbjogJyArXG5cdFx0XHRcdChlcnIgPyBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSA6IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RCb2R5KHJlcykpXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBFcnJvclJlcG9ydGVyO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFcnJvclJlcG9ydGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIG1zZ3BhY2sgPSAoZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBleHBvcnRzID0ge307XG5cblx0ZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblx0ZnVuY3Rpb24gaW5zcGVjdChidWZmZXIpIHtcblx0XHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gXCJ1bmRlZmluZWRcIjtcblx0XHR2YXIgdmlldztcblx0XHR2YXIgdHlwZTtcblx0XHRpZiAoIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR0eXBlID0gXCJBcnJheUJ1ZmZlclwiO1xuXHRcdFx0dmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXHRcdH0gZWxzZSBpZiAoIGJ1ZmZlciBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG5cdFx0XHR0eXBlID0gXCJEYXRhVmlld1wiO1xuXHRcdFx0dmlldyA9IGJ1ZmZlcjtcblx0XHR9XG5cdFx0aWYgKCF2aWV3KVxuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGJ1ZmZlcik7XG5cdFx0dmFyIGJ5dGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA+IDIwKSB7XG5cdFx0XHRcdGJ5dGVzLnB1c2goXCIuLi5cIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKS50b1N0cmluZygxNik7XG5cdFx0XHRpZiAoYnl0ZV8ubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRieXRlXyA9IFwiMFwiICsgYnl0ZV87XG5cdFx0XHRieXRlcy5wdXNoKGJ5dGVfKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwiPFwiICsgdHlwZSArIFwiIFwiICsgYnl0ZXMuam9pbihcIiBcIikgKyBcIj5cIjtcblx0fVxuXG5cdC8vIEVuY29kZSBzdHJpbmcgYXMgdXRmOCBpbnRvIGRhdGF2aWV3IGF0IG9mZnNldFxuXHRleHBvcnRzLnV0ZjhXcml0ZSA9IHV0ZjhXcml0ZTtcblx0ZnVuY3Rpb24gdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgc3RyaW5nKSB7XG5cdFx0dmFyIGJ5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cblx0XHRcdC8vIE9uZSBieXRlIG9mIFVURi04XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDdmIHwgMHgwMCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUd28gYnl0ZXMgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDFmIHwgMHhjMCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRocmVlIGJ5dGVzIG9mIFVURi04LlxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDB4MGYgfCAweGUwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3VyIGJ5dGVzIG9mIFVURi04XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxOCAmIDB4MDcgfCAweGYwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAxMiAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIGNvZGVwb2ludCBcIiArIGNvZGVQb2ludCk7XG5cdFx0fVxuXHR9XG5cblxuXHRleHBvcnRzLnV0ZjhSZWFkID0gdXRmOFJlYWQ7XG5cdGZ1bmN0aW9uIHV0ZjhSZWFkKHZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0dmFyIHN0cmluZyA9IFwiXCI7XG5cdFx0Zm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSk7XG5cdFx0XHQvLyBPbmUgYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweDgwKSA9PT0gMHgwMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlXyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVHdvIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDYpIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaHJlZSBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZjApID09PSAweGUwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCAxMikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRm91ciBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDA3KSA8PCAxOCkgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDEyKSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgXCIgKyBieXRlXy50b1N0cmluZygxNikpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9XG5cblxuXHRleHBvcnRzLnV0ZjhCeXRlQ291bnQgPSB1dGY4Qnl0ZUNvdW50O1xuXHRmdW5jdGlvbiB1dGY4Qnl0ZUNvdW50KHN0cmluZykge1xuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuXHRcdFx0XHRjb3VudCArPSAxO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuXHRcdFx0XHRjb3VudCArPSAyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIGNvZGVwb2ludCBcIiArIGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3VudDtcblx0fVxuXG5cblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIHNpemUgPSBzaXplb2YodmFsdWUsIHNwYXJzZSk7XG5cdFx0aWYoc2l6ZSA9PSAwKVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuXHRcdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0ZW5jb2RlKHZhbHVlLCB2aWV3LCAwLCBzcGFyc2UpO1xuXHRcdHJldHVybiBidWZmZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cblx0dmFyIFNIX0xfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcblx0ZnVuY3Rpb24gZ2V0SW50NjQodmlldywgb2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0SW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFVpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRyZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG5cdFx0aWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHg3ZmZmZmZmZik7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweDdmZmZmZmZmKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRVaW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcblx0XHRpZiAodmFsIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcblx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4ZmZmZmZmZmYpO1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHhmZmZmZmZmZik7XG5cdFx0fVxuXHR9XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2Zyc3l1a2kvNTQzMjU1OSAtIHY1IHNwZWNcbi8vXG4vLyBJJ3ZlIHVzZWQgb25lIGV4dGVuc2lvbiBwb2ludCBmcm9tIGBmaXhleHQgMWAgdG8gc3RvcmUgYHVuZGVmaW5lZGAuIE9uIHRoZSB3aXJlIHRoaXNcbi8vIHNob3VsZCB0cmFuc2xhdGUgdG8gZXhhY3RseSAweGQ0MDAwMFxuLy9cbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vIHwgIDB4ZDQgIHwgIDB4MDAgIHwgIDB4MDAgIHxcbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcbi8vICAgIF4gZml4ZXh0IHwgICAgICAgIF4gdmFsdWUgcGFydCB1bnVzZWQgKGZpeGVkIHRvIGJlIDApXG4vLyAgICAgICAgICAgICBeIGluZGljYXRlcyB1bmRlZmluZWQgdmFsdWVcbi8vXG5cblx0ZnVuY3Rpb24gRGVjb2Rlcih2aWV3LCBvZmZzZXQpIHtcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHRoaXMudmlldyA9IHZpZXc7XG5cdH1cblxuXG5cdERlY29kZXIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0aGlzLnBhcnNlKCk7XG5cdFx0XHR2YWx1ZVtrZXldID0gdGhpcy5wYXJzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuYmluID0gRGVjb2Rlci5wcm90b3R5cGUuYnVmID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG5cdFx0KG5ldyBVaW50OEFycmF5KHZhbHVlKSkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIsIHRoaXMub2Zmc2V0LCBsZW5ndGgpLCAwKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHV0ZjhSZWFkKHRoaXMudmlldywgdGhpcy5vZmZzZXQsIGxlbmd0aCk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlW2ldID0gdGhpcy5wYXJzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuZXh0ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0ge307XG5cdFx0Ly8gR2V0IHRoZSB0eXBlIGJ5dGVcblx0XHR2YWx1ZVsndHlwZSddID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuXHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0Ly8gR2V0IHRoZSBkYXRhIGFycmF5IChsZW5ndGgpXG5cdFx0dmFsdWVbJ2RhdGEnXSA9IHRoaXMuYnVmKGxlbmd0aCk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0KTtcblx0XHR2YXIgdmFsdWUsIGxlbmd0aDtcblxuXHRcdC8vIFBvc2l0aXZlIEZpeEludCAtIDB4eHh4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHg4MCkgPT09IDB4MDApIHtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cblx0XHQvLyBGaXhNYXAgLSAxMDAweHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZjApID09PSAweDgwKSB7XG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgwZjtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBGaXhBcnJheSAtIDEwMDF4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhmMCkgPT09IDB4OTApIHtcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gRml4U3RyIC0gMTAxeHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhhMCkge1xuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MWY7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVnYXRpdmUgRml4SW50IC0gMTExeHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhlMCkge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXG5cdFx0XHQvLyBuaWxcblx0XHRcdGNhc2UgMHhjMDpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIDB4YzEgbmV2ZXIgdXNlZCAtIHVzZSBmb3IgdW5kZWZpbmVkIChOT04tU1RBTkRBUkQpXG5cdFx0XHRjYXNlIDB4YzE6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzI6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly8gdHJ1ZVxuXHRcdFx0Y2FzZSAweGMzOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gYmluIDhcblx0XHRcdGNhc2UgMHhjNDpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG5cdFx0XHQvLyBiaW4gMTZcblx0XHRcdGNhc2UgMHhjNTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcblxuXHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRjYXNlIDB4YzY6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG5cblx0XHRcdC8vIGV4dCA4XG5cdFx0XHRjYXNlIDB4Yzc6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGV4dCAzMlxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmbG9hdCAzMlxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gZmxvYXQgNjRcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA5O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQ4XG5cdFx0XHRjYXNlIDB4Y2M6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0Y2FzZSAweGNkOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQgNjRcblx0XHRcdGNhc2UgMHhjZjpcblx0XHRcdFx0dmFsdWUgPSBnZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA5O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCA4XG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgMTZcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0dmFsdWUgPSBnZXRJbnQ2NCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdGxlbmd0aCA9IDI7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDhcblx0XHRcdGNhc2UgMHhkNzpcblx0XHRcdFx0bGVuZ3RoID0gODtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCAxNlxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHRsZW5ndGggPSAxNjtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIHN0cjhcblx0XHRcdGNhc2UgMHhkOTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cblx0XHRcdC8vIGFycmF5IDE2XG5cdFx0XHRjYXNlIDB4ZGM6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblxuXHRcdFx0Ly8gYXJyYXkgMzJcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuXG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdGNhc2UgMHhkZTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblxuXHRcdFx0Ly8gbWFwIDMyXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSAweFwiICsgdHlwZS50b1N0cmluZygxNikpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcblx0XHR2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXHRcdHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XG5cdFx0dmFyIHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuXHRcdGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQpICsgXCIgdHJhaWxpbmcgYnl0ZXNcIik7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSkge1xuXHRcdHZhciBrZXlzID0gW107IC8vIFRPRE86IHVzZSBPYmplY3Qua2V5cyB3aGVuIHdlIGFyZSBhYmxlIHRvIHRyYW5zcGlsZSB0byBFUzNcblx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdFx0cmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgdmFsID0gdmFsdWVbZV0sIHR5cGUgPSB0eXBlb2YodmFsKTtcblx0XHRcdHJldHVybiAoIXNwYXJzZSB8fCAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsKSkgJiYgKCdmdW5jdGlvbicgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0Ly8gU3RyaW5ncyBCeXRlc1xuXHRcdC8vIFRoZXJlIGFyZSBmb3VyIHN0cmluZyB0eXBlczogZml4c3RyL3N0cjgvc3RyMTYvc3RyMzJcblx0XHRpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuXG5cdFx0XHQvLyBmaXhzdHJcblx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGggfCAweGEwKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDEgKyBsZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0cjhcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkOSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDIsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0cjE2XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkYSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAzLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RyMzJcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkYik7XG5cdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyA1LCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG5cdFx0XHQvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcblx0XHRcdHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuXHRcdH1cblxuXHRcdC8vIFRoZXJlIGFyZSB0aHJlZSBiaW4gdHlwZXM6IGJpbjgvYmluMTYvYmluMzJcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdC8vIGJpbjhcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0KG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKSkuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMik7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiaW4xNlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzUpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHQobmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAzKTtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJpbiAzMlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM2KTtcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0KG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKSkuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgNSk7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG5cblx0XHRcdC8vIEZsb2F0aW5nIFBvaW50XG5cdFx0XHQvLyBOT1RFOiBXZSdyZSBhbHdheXMgdXNpbmcgZmxvYXQ2NFxuXHRcdFx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjYik7XG5cdFx0XHRcdHZpZXcuc2V0RmxvYXQ2NChvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnRlZ2Vyc1xuXHRcdFx0aWYgKHZhbHVlID49IDApIHtcblx0XHRcdFx0Ly8gcG9zaXRpdmUgZml4bnVtXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVpbnQgOFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNjKTtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDE2XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZCk7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVpbnQgMzJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZSk7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVpbnQgNjRcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNmKTtcblx0XHRcdFx0XHRzZXRVaW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBuZWdhdGl2ZSBmaXhudW1cblx0XHRcdGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuXHRcdFx0XHR2aWV3LnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW50IDhcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMCk7XG5cdFx0XHRcdHZpZXcuc2V0SW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW50IDE2XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMSk7XG5cdFx0XHRcdHZpZXcuc2V0SW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblx0XHRcdC8vIGludCAzMlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQyKTtcblx0XHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW50IDY0XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMyk7XG5cdFx0XHRcdHNldEludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgKC12YWx1ZSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG5cdFx0fVxuXG5cdFx0Ly8gdW5kZWZpbmVkIC0gdXNlIGQ0IChOT04tU1RBTkRBUkQpXG5cdFx0aWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGlmKHNwYXJzZSkgcmV0dXJuIDA7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkNCk7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIDB4MDApO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAyLCAweDAwKTtcblx0XHRcdHJldHVybiAzO1xuXHRcdH1cblxuXHRcdC8vIG51bGxcblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdGlmKHNwYXJzZSkgcmV0dXJuIDA7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjMCk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHQvLyBCb29sZWFuXG5cdFx0aWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgPyAweGMzIDogMHhjMik7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRpZignZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuXHRcdFx0cmV0dXJuIGVuY29kZSh2YWx1ZS50b0pTT04oKSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpO1xuXG5cdFx0Ly8gQ29udGFpbmVyIFR5cGVzXG5cdFx0aWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHZhciBsZW5ndGgsIHNpemUgPSAwO1xuXHRcdFx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuXHRcdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcblx0XHRcdFx0bGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaXplO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8ICggaXNBcnJheSA/IDB4OTAgOiAweDgwKSk7XG5cdFx0XHRcdHNpemUgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkYyA6IDB4ZGUpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHRzaXplID0gMztcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRkIDogMHhkZik7XG5cdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHNpemUgPSA1O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2l6ZSArPSBlbmNvZGUodmFsdWVbaV0sIHZpZXcsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZShrZXksIHZpZXcsIG9mZnNldCArIHNpemUpO1xuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKHZhbHVlW2tleV0sIHZpZXcsIG9mZnNldCArIHNpemUsIHNwYXJzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXHRcdGlmKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaXplb2YodmFsdWUsIHNwYXJzZSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0Ly8gZml4c3RyIG9yIHN0cjggb3Igc3RyMTYgb3Igc3RyMzJcblx0XHRpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHV0ZjhCeXRlQ291bnQodmFsdWUpO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0cmV0dXJuIDEgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuXHRcdFx0Ly8gZXh0cmFjdCB0aGUgYXJyYXlidWZmZXIgYW5kIGZhbGx0aHJvdWdoXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcblx0XHR9XG5cblx0XHQvLyBiaW44IG9yIGJpbjE2IG9yIGJpbjMyXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdC8vIEZsb2F0aW5nIFBvaW50ICgzMiBiaXRzKVxuXHRcdFx0Ly8gZG91YmxlXG5cdFx0XHRpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuXHRcdFx0XHRyZXR1cm4gOTtcblxuXHRcdFx0Ly8gSW50ZWdlcnNcblx0XHRcdGlmICh2YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdC8vIHBvc2l0aXZlIGZpeGludFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDgwKVxuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHQvLyB1aW50IDhcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDApXG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdC8vIHVpbnQgMTZcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMClcblx0XHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdFx0Ly8gdWludCAzMlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMClcblx0XHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdFx0Ly8gdWludCA2NFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwKVxuXHRcdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0XHQvLyBUb28gYmlnXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnIDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbmVnYXRpdmUgZml4aW50XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0Ly8gaW50IDhcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MClcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHQvLyBpbnQgMTZcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwKVxuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdC8vIGludCAzMlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDAwMDAwKVxuXHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdC8vIGludCA2NFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDAwMDAwMDAwMDAwMDApXG5cdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0Ly8gVG9vIHNtYWxsXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgdmFsdWUudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG5cdFx0fVxuXG5cdFx0Ly8gQm9vbGVhblxuXHRcdGlmICh0eXBlID09PSBcImJvb2xlYW5cIikgcmV0dXJuIDE7XG5cblx0XHQvLyB1bmRlZmluZWQsIG51bGxcblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBzcGFyc2UgPyAwIDogMTtcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHNwYXJzZSA/IDAgOiAzO1xuXG5cdFx0aWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcblx0XHRcdHJldHVybiBzaXplb2YodmFsdWUudG9KU09OKCksIHNwYXJzZSk7XG5cblx0XHQvLyBDb250YWluZXIgVHlwZXNcblx0XHRpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0dmFyIGxlbmd0aCwgc2l6ZSA9IDA7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSlcblx0XHRcdFx0bGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHJldHVybiAxICsgc2l6ZTtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHJldHVybiAzICsgc2l6ZTtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gNSArIHNpemU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBvciBvYmplY3QgdG9vIGxvbmcgMHhcIiArIGxlbmd0aC50b1N0cmluZygxNikpO1xuXHRcdH1cblx0XHRpZih0eXBlID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuXHR9XG5cblx0cmV0dXJuIGV4cG9ydHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKG1zZ3BhY2spO1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX211bHRpY2FzdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV90cmFuc3BvcnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYnNvY2tldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBDb25uZWN0aW9uTWFuYWdlciA9IChmdW5jdGlvbigpIHtcblx0dmFyIGhhdmVXZWJTdG9yYWdlID0gISEodHlwZW9mKHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldCk7XG5cdHZhciBoYXZlU2Vzc2lvblN0b3JhZ2UgPSAhISh0eXBlb2YocGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgIT09ICd1bmRlZmluZWQnICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0U2Vzc2lvbik7XG5cdHZhciBhY3Rpb25zID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbjtcblx0dmFyIFBlbmRpbmdNZXNzYWdlID0gX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUGVuZGluZ01lc3NhZ2U7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0dmFyIHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0udHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyO1xuXHR2YXIgb3B0aW1hbFRyYW5zcG9ydCA9IHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlclt0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIubGVuZ3RoIC0gMV07XG5cdHZhciB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSA9ICdhYmx5LXRyYW5zcG9ydC1wcmVmZXJlbmNlJztcblxuXHR2YXIgc2Vzc2lvblJlY292ZXJ5TmFtZSA9ICdhYmx5LWNvbm5lY3Rpb24tcmVjb3ZlcnknO1xuXHRmdW5jdGlvbiBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG5cdFx0cmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFNlc3Npb24oc2Vzc2lvblJlY292ZXJ5TmFtZSk7XG5cdH1cblx0ZnVuY3Rpb24gc2V0U2Vzc2lvblJlY292ZXJEYXRhKHZhbHVlKSB7XG5cdFx0cmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNldFNlc3Npb24oc2Vzc2lvblJlY292ZXJ5TmFtZSwgdmFsdWUpO1xuXHR9XG5cdGZ1bmN0aW9uIGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCkge1xuXHRcdHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZW1vdmVTZXNzaW9uKHNlc3Npb25SZWNvdmVyeU5hbWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmV0dGVyVHJhbnNwb3J0VGhhbihhLCBiKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZih0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGEuc2hvcnROYW1lKSA+XG5cdFx0ICAgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYi5zaG9ydE5hbWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gVHJhbnNwb3J0UGFyYW1zKG9wdGlvbnMsIGhvc3QsIG1vZGUsIGNvbm5lY3Rpb25LZXkpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuaG9zdCA9IGhvc3Q7XG5cdFx0dGhpcy5tb2RlID0gbW9kZTtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uS2V5O1xuXHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJztcblxuXHRcdHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLmdldENvbm5lY3RQYXJhbXMgPSBmdW5jdGlvbihhdXRoUGFyYW1zKSB7XG5cdFx0dmFyIHBhcmFtcyA9IGF1dGhQYXJhbXMgPyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNvcHkoYXV0aFBhcmFtcykgOiB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRzd2l0Y2godGhpcy5tb2RlKSB7XG5cdFx0XHRjYXNlICd1cGdyYWRlJzpcblx0XHRcdFx0cGFyYW1zLnVwZ3JhZGUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncmVzdW1lJzpcblx0XHRcdFx0cGFyYW1zLnJlc3VtZSA9IHRoaXMuY29ubmVjdGlvbktleTtcblx0XHRcdFx0aWYodGhpcy50aW1lU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRwYXJhbXMudGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbDtcblx0XHRcdFx0fSBlbHNlIGlmKHRoaXMuY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyZWNvdmVyJzpcblx0XHRcdFx0dmFyIG1hdGNoID0gb3B0aW9ucy5yZWNvdmVyLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdGlmKG1hdGNoKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnJlY292ZXIgPSBtYXRjaFswXTtcblx0XHRcdFx0XHR2YXIgcmVjb3ZlclNlcmlhbCA9IG1hdGNoWzFdO1xuXHRcdFx0XHRcdGlmKGlzTmFOKHJlY292ZXJTZXJpYWwpKSB7XG5cdFx0XHRcdFx0XHRwYXJhbXMudGltZVNlcmlhbCA9IHJlY292ZXJTZXJpYWw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBhcmFtcy5jb25uZWN0aW9uU2VyaWFsID0gcmVjb3ZlclNlcmlhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdH1cblx0XHRpZihvcHRpb25zLmNsaWVudElkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG5cdFx0fVxuXHRcdGlmKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuXHRcdFx0cGFyYW1zLmVjaG8gPSAnZmFsc2UnO1xuXHRcdH1cblx0XHRpZih0aGlzLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG5cdFx0fVxuXHRcdGlmKHRoaXMuc3RyZWFtICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcblx0XHR9XG5cdFx0aWYodGhpcy5oZWFydGJlYXRzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xuXHRcdH1cblx0XHRwYXJhbXMudiA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbjtcblx0XHRwYXJhbXMuYWdlbnQgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50O1xuXHRcdGlmKG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4ocGFyYW1zLCBvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbXM7XG5cdH07XG5cblx0VHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW21vZGU9JyArIHRoaXMubW9kZTtcblx0XHRpZih0aGlzLmhvc3QpIHsgcmVzdWx0ICs9ICgnLGhvc3Q9JyArIHRoaXMuaG9zdCk7IH1cblx0XHRpZih0aGlzLmNvbm5lY3Rpb25LZXkpIHsgcmVzdWx0ICs9ICgnLGNvbm5lY3Rpb25LZXk9JyArIHRoaXMuY29ubmVjdGlvbktleSk7IH1cblx0XHRpZih0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkgeyByZXN1bHQgKz0gKCcsY29ubmVjdGlvblNlcmlhbD0nICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsKTsgfVxuXHRcdGlmKHRoaXMudGltZVNlcmlhbCkgeyByZXN1bHQgKz0gKCcsdGltZVNlcmlhbD0nICsgdGhpcy50aW1lU2VyaWFsKTsgfVxuXHRcdGlmKHRoaXMuZm9ybWF0KSB7IHJlc3VsdCArPSAoJyxmb3JtYXQ9JyArIHRoaXMuZm9ybWF0KTsgfVxuXHRcdHJlc3VsdCArPSAnXSc7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcihyZWFsdGltZSwgb3B0aW9ucykge1xuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dmFyIHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0LyogY29ubmVjdGluZ1RpbWVvdXQ6IGxlYXZlIHByZWZlcmVuY2VDb25uZWN0VGltZW91dCAofjZzKSB0byB0cnkgdGhlXG5cdFx0ICogcHJlZmVyZW5jZSB0cmFuc3BvcnQsIHRoZW4gcmVhbHRpbWVSZXF1ZXN0VGltZW91dCAofjEwcykgdG8gZXN0YWJsaXNoXG5cdFx0ICogdGhlIGJhc2UgdHJhbnNwb3J0IGluIGNhc2UgdGhhdCBmYWlscyAqL1xuXHRcdHZhciBjb25uZWN0aW5nVGltZW91dCA9IHRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCArIHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG5cdFx0dGhpcy5zdGF0ZXMgPSB7XG5cdFx0XHRpbml0aWFsaXplZDogICB7c3RhdGU6ICdpbml0aWFsaXplZCcsICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdGNvbm5lY3Rpbmc6ICAgIHtzdGF0ZTogJ2Nvbm5lY3RpbmcnLCAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IGNvbm5lY3RpbmdUaW1lb3V0LCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdGNvbm5lY3RlZDogICAgIHtzdGF0ZTogJ2Nvbm5lY3RlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogdHJ1ZSwgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0c3luY2hyb25pemluZzoge3N0YXRlOiAnY29ubmVjdGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgZm9yY2VRdWV1ZUV2ZW50czogdHJ1ZSwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRkaXNjb25uZWN0ZWQ6ICB7c3RhdGU6ICdkaXNjb25uZWN0ZWQnLCAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0c3VzcGVuZGVkOiAgICAge3N0YXRlOiAnc3VzcGVuZGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdzdXNwZW5kZWQnfSxcblx0XHRcdGNsb3Npbmc6ICAgICAgIHtzdGF0ZTogJ2Nsb3NpbmcnLCAgICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsIGZhaWxTdGF0ZTogJ2Nsb3NlZCd9LFxuXHRcdFx0Y2xvc2VkOiAgICAgICAge3N0YXRlOiAnY2xvc2VkJywgICAgICAgIHRlcm1pbmFsOiB0cnVlLCAgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnY2xvc2VkJ30sXG5cdFx0XHRmYWlsZWQ6ICAgICAgICB7c3RhdGU6ICdmYWlsZWQnLCAgICAgICAgdGVybWluYWw6IHRydWUsICBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdmYWlsZWQnfVxuXHRcdH07XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLmluaXRpYWxpemVkO1xuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuXG5cdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcyA9IG5ldyBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0oKTtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0dGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG5cblx0XHR0aGlzLnRyYW5zcG9ydHMgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmludGVyc2VjdCgob3B0aW9ucy50cmFuc3BvcnRzIHx8IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVmYXVsdFRyYW5zcG9ydHMpLCBDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzKTtcblx0XHQvKiBiYXNlVHJhbnNwb3J0cyBzZWxlY3RzIHRoZSBsZWZ0bW9zdCB0cmFuc3BvcnQgaW4gdGhlIERlZmF1bHRzLmJhc2VUcmFuc3BvcnRPcmRlciBsaXN0XG5cdFx0KiB0aGF0J3MgYm90aCByZXF1ZXN0ZWQgYW5kIHN1cHBvcnRlZC4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHhocl9wb2xsaW5nO1xuXHRcdCogaWYgeGhyIGlzbid0IHN1cHBvcnRlZCBpdCB3aWxsIGJlIGpzb25wLiBJZiB0aGUgdXNlciBoYXMgZm9yY2VkIGFcblx0XHQqIHRyYW5zcG9ydCwgaXQnbGwganVzdCBiZSB0aGF0IG9uZS4gKi9cblx0XHR0aGlzLmJhc2VUcmFuc3BvcnQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmludGVyc2VjdChfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2VUcmFuc3BvcnRPcmRlciwgdGhpcy50cmFuc3BvcnRzKVswXTtcblx0XHR0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QodGhpcy50cmFuc3BvcnRzLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVwZ3JhZGVUcmFuc3BvcnRzKTtcblx0XHR0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuXG5cdFx0dGhpcy5odHRwSG9zdHMgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3RzKG9wdGlvbnMpO1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBudWxsO1xuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuXHRcdHRoaXMuaG9zdCA9IG51bGw7XG5cdFx0dGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBudWxsO1xuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcblx0XHR0aGlzLm1vc3RSZWNlbnRNc2cgPSBudWxsO1xuXHRcdHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcblx0XHR0aGlzLmNvbm5lY3RDb3VudGVyID0gMDtcblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ3N0YXJ0ZWQnKTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdyZXF1ZXN0ZWQgdHJhbnNwb3J0cyA9IFsnICsgKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlZmF1bHRUcmFuc3BvcnRzKSArICddJyk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYXZhaWxhYmxlIHRyYW5zcG9ydHMgPSBbJyArIHRoaXMudHJhbnNwb3J0cyArICddJyk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnaHR0cCBob3N0cyA9IFsnICsgdGhpcy5odHRwSG9zdHMgKyAnXScpO1xuXG5cdFx0aWYoIXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0XHRcdHZhciBtc2cgPSAnbm8gcmVxdWVzdGVkIHRyYW5zcG9ydHMgYXZhaWxhYmxlJztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblxuXHRcdHZhciBhZGRFdmVudExpc3RlbmVyID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdGlmKGFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdC8qIGludGVyY2VwdCBjbG9zZSBldmVudCBpbiBicm93c2VyIHRvIHBlcnNpc3QgY29ubmVjdGlvbiBpZCBpZiByZXF1ZXN0ZWQgKi9cblx0XHRcdGlmKGhhdmVTZXNzaW9uU3RvcmFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5yZWNvdmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8qIFVzdWFsbHkgY2FuJ3QgdXNlIGJpbmQgYXMgbm90IHN1cHBvcnRlZCBpbiBJRTgsIGJ1dCBJRSBkb2Vzbid0IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UsIHNvLi4uICovXG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZCh0aGlzKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01BSk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdiZWZvcmV1bmxvYWQgZXZlbnQgaGFzIHRyaWdnZXJlZCB0aGUgY29ubmVjdGlvbiB0byBjbG9zZSBhcyBjbG9zZU9uVW5sb2FkIGlzIHRydWUnKTtcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjbG9zaW5nJ30pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0LyogTGlzdGVuIGZvciBvbmxpbmUgYW5kIG9mZmxpbmUgZXZlbnRzICovXG5cdFx0XHRhZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PSBzZWxmLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgc2VsZi5zdGF0ZSA9PSBzZWxmLnN0YXRlcy5zdXNwZW5kZWQpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb25saW5l4oCZIGV2ZW50JywgJ3JlYXR0ZW1wdGluZyBjb25uZWN0aW9uJyk7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRhZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9mZmxpbmXigJkgZXZlbnQnLCAnZGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0Jyk7XG5cdFx0XHRcdFx0Ly8gTm90IHN1ZmZpY2llbnQgdG8ganVzdCBnbyB0byB0aGUgJ2Rpc2Nvbm5lY3RlZCcgc3RhdGUsIHdhbnQgdG9cblx0XHRcdFx0XHQvLyBmb3JjZSBhbGwgdHJhbnNwb3J0cyB0byByZWF0dGVtcHQgdGhlIGNvbm5lY3Rpb24uIFdpbGwgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHQvLyByZXRyeS5cblx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKENvbm5lY3Rpb25NYW5hZ2VyLCBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHQgKiB0cmFuc3BvcnQgbWFuYWdlbWVudFxuXHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHMgPSB7fTtcblxuXHRPYmplY3QoX3dlYnNvY2tldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoQ29ubmVjdGlvbk1hbmFnZXIpO1xuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2gocGxhdGZvcm1fdHJhbnNwb3J0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSwgZnVuY3Rpb24gKGluaXRGbikge1xuXHRcdGluaXRGbihDb25uZWN0aW9uTWFuYWdlcik7XG5cdH0pO1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnRQYXJhbXMgPSBmdW5jdGlvbihob3N0LCBtb2RlKSB7XG5cdFx0dmFyIHBhcmFtcyA9IG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuXHRcdGlmKHRoaXMudGltZVNlcmlhbCkge1xuXHRcdFx0cGFyYW1zLnRpbWVTZXJpYWwgPSB0aGlzLnRpbWVTZXJpYWw7XG5cdFx0fSBlbHNlIGlmKHRoaXMuY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwYXJhbXMuY29ubmVjdGlvblNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcztcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBkZWNpZGVNb2RlKG1vZGVDYikge1xuXHRcdFx0aWYoc2VsZi5jb25uZWN0aW9uS2V5KSB7XG5cdFx0XHRcdG1vZGVDYigncmVzdW1lJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYodHlwZW9mIHNlbGYub3B0aW9ucy5yZWNvdmVyID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRtb2RlQ2IoJ3JlY292ZXInKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVjb3ZlckZuID0gc2VsZi5vcHRpb25zLnJlY292ZXIsXG5cdFx0XHRcdGxhc3RTZXNzaW9uRGF0YSA9IGdldFNlc3Npb25SZWNvdmVyRGF0YSgpO1xuXHRcdFx0aWYobGFzdFNlc3Npb25EYXRhICYmIHR5cGVvZihyZWNvdmVyRm4pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdDYWxsaW5nIGNsaWVudE9wdGlvbnMtcHJvdmlkZWQgcmVjb3ZlciBmdW5jdGlvbiB3aXRoIGxhc3Qgc2Vzc2lvbiBkYXRhJyk7XG5cdFx0XHRcdHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIGZ1bmN0aW9uKHNob3VsZFJlY292ZXIpIHtcblx0XHRcdFx0XHRpZihzaG91bGRSZWNvdmVyKSB7XG5cdFx0XHRcdFx0XHRzZWxmLm9wdGlvbnMucmVjb3ZlciA9IGxhc3RTZXNzaW9uRGF0YS5yZWNvdmVyeUtleTtcblx0XHRcdFx0XHRcdG1vZGVDYigncmVjb3ZlcicpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RlQ2IoJ2NsZWFuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bW9kZUNiKCdjbGVhbicpO1xuXHRcdH1cblxuXHRcdGRlY2lkZU1vZGUoZnVuY3Rpb24obW9kZSkge1xuXHRcdFx0dmFyIHRyYW5zcG9ydFBhcmFtcyA9IHNlbGYuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKG51bGwsIG1vZGUpO1xuXHRcdFx0aWYobW9kZSA9PT0gJ3JlY292ZXInKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcmVjb3ZlcnkgbW9kZSA9IHJlY292ZXI7IHJlY292ZXJ5S2V5ID0gJyArIHNlbGYub3B0aW9ucy5yZWNvdmVyKTtcblx0XHRcdFx0dmFyIG1hdGNoID0gc2VsZi5vcHRpb25zLnJlY292ZXIuc3BsaXQoJzonKTtcblx0XHRcdFx0aWYobWF0Y2ggJiYgbWF0Y2hbMl0pIHtcblx0XHRcdFx0XHRzZWxmLm1zZ1NlcmlhbCA9IG1hdGNoWzJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHBhcmFtcyA9ICcgKyB0cmFuc3BvcnRQYXJhbXMudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgYSBnaXZlbiB0cmFuc3BvcnRcblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuXHQgKiBAcGFyYW0gY2FuZGlkYXRlLCB0aGUgdHJhbnNwb3J0IHRvIHRyeVxuXHQgKiBAcGFyYW0gY2FsbGJhY2tcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50cnlBVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBob3N0ID0gdHJhbnNwb3J0UGFyYW1zLmhvc3Q7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cnlpbmcgJyArIGNhbmRpZGF0ZSk7XG5cdFx0KENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbY2FuZGlkYXRlXSkudHJ5Q29ubmVjdCh0aGlzLCB0aGlzLnJlYWx0aW1lLmF1dGgsIHRyYW5zcG9ydFBhcmFtcywgZnVuY3Rpb24od3JhcHBlZEVyciwgdHJhbnNwb3J0KSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnN0YXRlO1xuXHRcdFx0aWYoc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSBzZWxmLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZmFpbGVkKSB7XG5cdFx0XHRcdGlmKHRyYW5zcG9ydCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbiAnICsgc3RhdGUuc3RhdGUgKyAnIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0XHRcdHRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKHRydWUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHdyYXBwZWRFcnIpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICcgJyArIHdyYXBwZWRFcnIuZXZlbnQgKyAnLCBlcnI6ICcgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKCkpO1xuXG5cdFx0XHRcdC8qIENvbWV0IHRyYW5zcG9ydCBvbmNvbm5lY3QgdG9rZW4gZXJyb3JzIGNhbiBiZSBkZWFsdCB3aXRoIGhlcmUuXG5cdFx0XHRcdCogV2Vic29ja2V0IG9uZXMgb25seSBoYXBwZW4gYWZ0ZXIgdGhlIHRyYW5zcG9ydCBjbGFpbXMgdG8gYmUgdmlhYmxlLFxuXHRcdFx0XHQqIHNvIGFyZSBkZWFsdCB3aXRoIGFzIG5vbi1vbmNvbm5lY3QgdG9rZW4gZXJyb3JzICovXG5cdFx0XHRcdGlmKF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHdyYXBwZWRFcnIuZXJyb3IpICYmICEoc2VsZi5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihzZWxmLmVycm9yUmVhc29uKSkpIHtcblx0XHRcdFx0XHRzZWxmLmVycm9yUmVhc29uID0gd3JhcHBlZEVyci5lcnJvcjtcblx0XHRcdFx0XHQvKiByZS1nZXQgYSB0b2tlbiBhbmQgdHJ5IGFnYWluICovXG5cdFx0XHRcdFx0c2VsZi5yZWFsdGltZS5hdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSBpZih3cmFwcGVkRXJyLmV2ZW50ID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdC8qIEVycm9yIHRoYXQncyBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3J9KTtcblx0XHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0aWYoIV90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcblx0XHRcdFx0XHRcdC8qIEVycm9yIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciB0aGF0IGRvZXMgbm90IGNhbGwgZm9yIHRyeWluZyBhIGZhbGxiYWNrIGhvc3QsIGVnIGEgcmF0ZSBsaW1pdCAqL1xuXHRcdFx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6IHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvcn0pO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIEVycm9yIHdpdGggdGhhdCB0cmFuc3BvcnQgb25seTsgY29udGludWUgdHJ5aW5nIG90aGVyIGZhbGxiYWNrIGhvc3RzICovXG5cdFx0XHRcdFx0XHRjYWxsYmFjayhmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnOyBzZXR0aW5nIHBlbmRpbmcnKTtcblx0XHRcdHNlbGYuc2V0VHJhbnNwb3J0UGVuZGluZyh0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGluZGljYXRlZCB0byBiZSB2aWFibGUsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXJcblx0ICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cblx0ICogQHBhcmFtIGhvc3Rcblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRyYW5zcG9ydFBlbmRpbmcgPSBmdW5jdGlvbih0cmFuc3BvcnQsIHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdHZhciBtb2RlID0gdHJhbnNwb3J0UGFyYW1zLm1vZGU7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldFRyYW5zcG9ydFBlbmRpbmcoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgbW9kZSA9ICcgKyBtb2RlKTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dHJhbnNwb3J0Lm9uY2UoJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKGVycm9yLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pIHtcblx0XHRcdGlmKG1vZGUgPT0gJ3VwZ3JhZGUnICYmIHNlbGYuYWN0aXZlUHJvdG9jb2wpIHtcblx0XHRcdFx0LyogIGlmIHdzIGFuZCB4aHJzIGFyZSBjb25uZWN0aW5nIGluIHBhcmFsbGVsLCBkZWxheSB4aHJzIGFjdGl2YXRpb24gdG8gbGV0IHdzIGdvIGFoZWFkICovXG5cdFx0XHRcdGlmKHRyYW5zcG9ydC5zaG9ydE5hbWUgIT09IG9wdGltYWxUcmFuc3BvcnQgJiYgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbihzZWxmLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCksIG9wdGltYWxUcmFuc3BvcnQpKSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbik7XG5cdFx0XHRcdFx0fSwgc2VsZi5vcHRpb25zLnRpbWVvdXRzLnBhcmFsbGVsVXBncmFkZURlbGF5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbik7XG5cblx0XHRcdFx0LyogYWxsb3cgY29ubmVjdEltcGwgdG8gc3RhcnQgdGhlIHVwZ3JhZGUgcHJvY2VzcyBpZiBuZWVkZWQsIGJ1dCBhbGxvd1xuXHRcdFx0XHQgKiBvdGhlciBldmVudCBoYW5kbGVycywgaW5jbHVkaW5nIGFjdGl2YXRpbmcgdGhlIHRyYW5zcG9ydCwgdG8gcnVuIGZpcnN0ICovXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYobW9kZSA9PT0gJ3JlY292ZXInICYmIHNlbGYub3B0aW9ucy5yZWNvdmVyKSB7XG5cdFx0XHRcdC8qIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZWNvdmVyeSwgd2UgdW5wZXJzaXN0LCBhcyBhIHJlY292ZXJ5IGtleSBjYW5ub3Rcblx0XHRcdFx0KiBiZSB1c2VkIG1vcmUgdGhhbiBvbmNlICovXG5cdFx0XHRcdHNlbGYub3B0aW9ucy5yZWNvdmVyID0gbnVsbDtcblx0XHRcdFx0c2VsZi51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0cmFuc3BvcnQub24oWydkaXNjb25uZWN0ZWQnLCAnY2xvc2VkJywgJ2ZhaWxlZCddLCBmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0c2VsZi5kZWFjdGl2YXRlVHJhbnNwb3J0KHRyYW5zcG9ydCwgdGhpcy5ldmVudCwgZXJyb3IpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5lbWl0KCd0cmFuc3BvcnQucGVuZGluZycsIHRyYW5zcG9ydCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGFuIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCxcblx0ICogdG8gc2NoZWR1bGUgdGhlIGFjdGl2YXRpb24gb2YgdGhhdCB0cmFuc3BvcnQuXG5cdCAqIEBwYXJhbSBlcnJvclxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uSWRcblx0ICogQHBhcmFtIGNvbm5lY3Rpb25EZXRhaWxzXG5cdCAqIEBwYXJhbSBjb25uZWN0ZWRNZXNzYWdlXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uID0gZnVuY3Rpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgdXBncmFkZUNvbm5lY3Rpb25Qb3NpdGlvbikge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGN1cnJlbnRUcmFuc3BvcnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sICYmIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksXG5cdFx0XHRhYmFuZG9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH07XG5cblx0XHRpZih0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuXHRcdFx0LyogVGhpcyBpcyBtb3N0IGxpa2VseSB0byBoYXBwZW4gZm9yIHRoZSBkZWxheWVkIHhocnMsIHdoZW4geGhycyBhbmQgd3MgYXJlIHNjaGVkdWxlZCBpbiBwYXJhbGxlbCovXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuXHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKGN1cnJlbnRUcmFuc3BvcnQgJiYgIWJldHRlclRyYW5zcG9ydFRoYW4odHJhbnNwb3J0LCBjdXJyZW50VHJhbnNwb3J0KSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICcgaXMgbm8gYmV0dGVyIHRoYW4gY3VycmVudCBhY3RpdmUgdHJhbnNwb3J0ICcgKyBjdXJyZW50VHJhbnNwb3J0LnNob3J0TmFtZSArICcgLSBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcblx0XHRcdGFiYW5kb24oKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnU2NoZWR1bGluZyB0cmFuc3BvcnQgdXBncmFkZTsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cblx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uY2VOb3BlbmRpbmcoZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHR2YXIgb2xkUHJvdG9jb2w7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VuYWJsZSB0byBhY3RpdmF0ZSB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBlcnIgPSAnICsgZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighdHJhbnNwb3J0LmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRcdC8qIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgeGhyIHN0cmVhbWluZyB0cmFuc3BvcnQgd2FzIGRpc2Nvbm5lY3RlZCBkdXJpbmcgdGhlIHBhcmFsbGVsVXBncmFkZURlbGF5ICovXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZDsgYWJhbmRvbmluZyB1cGdyYWRlJyk7XG5cdFx0XHRcdGFiYW5kb24oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnRseSBjb25uZWN0ZWQsIHNvIHRlbXBvcmFyaWx5IHBhdXNpbmcgZXZlbnRzIHVudGlsIHRoZSB1cGdyYWRlIGlzIGNvbXBsZXRlJyk7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuXHRcdFx0XHRvbGRQcm90b2NvbCA9IHNlbGYuYWN0aXZlUHJvdG9jb2w7XG5cdFx0XHR9IGVsc2UgaWYoc2VsZi5zdGF0ZSAhPT0gc2VsZi5zdGF0ZXMuY29ubmVjdGluZykge1xuXHRcdFx0XHQvKiBOb3RlOiB1cGdyYWRpbmcgZnJvbSB0aGUgY29ubmVjdGluZyBzdGF0ZSBpcyB2YWxpZCBpZiB0aGUgb2xkIGFjdGl2ZVxuXHRcdFx0XHQqIHRyYW5zcG9ydCB3YXMgZGVhY3RpdmF0ZWQgYWZ0ZXIgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGZpcnN0IGNvbm5lY3RlZDtcblx0XHRcdFx0KiBzZWUgbG9naWMgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICsgc2VsZi5zdGF0ZS5zdGF0ZSArIChzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuXHRcdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogSWYgdGhlIGNvbm5lY3Rpb25JZCBoYXMgY2hhbmdlZCwgdGhlIHVwZ3JhZGUgaGFzbid0IHdvcmtlZC4gQnV0IGFzXG5cdFx0XHQqIGl0J3Mgc3RpbGwgYW4gdXBncmFkZSwgcmVhbHRpbWUgc3RpbGwgZXhwZWN0cyBhIHN5bmMgLSBpdCBqdXN0IG5lZWRzIHRvXG5cdFx0XHQqIGJlIGEgc3luYyB3aXRoIHRoZSBuZXcgY29ubmVjdGlvbiBwb3NpdGlvbi4gKEFuZCBpdFxuXHRcdFx0KiBuZWVkcyB0byBiZSBzZXQgaW4gdGhlIGxpYnJhcnksIHdoaWNoIGlzIGRvbmUgYnkgYWN0aXZhdGVUcmFuc3BvcnQpLiAqL1xuXHRcdFx0dmFyIGNvbm5lY3Rpb25SZXNldCA9IGNvbm5lY3Rpb25JZCAhPT0gc2VsZi5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHN5bmNQb3NpdGlvbiA9IGNvbm5lY3Rpb25SZXNldCA/IHVwZ3JhZGVDb25uZWN0aW9uUG9zaXRpb24gOiBzZWxmO1xuXG5cdFx0XHRpZihjb25uZWN0aW9uUmVzZXQpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VwZ3JhZGUgcmVzdWx0ZWQgaW4gbmV3IGNvbm5lY3Rpb25JZDsgcmVzZXR0aW5nIGxpYnJhcnkgY29ubmVjdGlvbiBwb3NpdGlvbiBmcm9tICcgKyAoc2VsZi50aW1lU2VyaWFsIHx8IHNlbGYuY29ubmVjdGlvblNlcmlhbCkgKyAnIHRvICcgKyAoc3luY1Bvc2l0aW9uLnRpbWVTZXJpYWwgfHwgc3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwpICsgJzsgdXBncmFkZSBlcnJvciB3YXMgJyArIGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1N5bmNpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHNlbGYuc3luYyh0cmFuc3BvcnQsIHN5bmNQb3NpdGlvbiwgZnVuY3Rpb24oc3luY0VyciwgY29ubmVjdGlvbklkLCBwb3N0U3luY1Bvc2l0aW9uKSB7XG5cdFx0XHRcdC8qIElmIHRoZXJlJ3MgYmVlbiBzb21lIHByb2JsZW0gd2l0aCBzeW5jaW5nIChhbmQgdGhlIGNvbm5lY3Rpb24gaGFzbid0XG5cdFx0XHRcdCAqIGNsb3NlZCBvciBzb21ldGhpbmcgaW4gdGhlIG1lYW50aW1lKSwgd2UgaGF2ZSBhIHByb2JsZW0gLS0gd2UgY2FuJ3Rcblx0XHRcdFx0ICoganVzdCBmYWxsIGJhY2sgb24gdGhlIG9sZCB0cmFuc3BvcnQsIGFzIHdlIGRvbid0IGtub3cgd2hldGhlclxuXHRcdFx0XHQgKiByZWFsdGltZSBnb3QgdGhlIHN5bmMgLS0gaWYgaXQgZGlkLCB0aGUgb2xkIHRyYW5zcG9ydCBpcyBubyBsb25nZXJcblx0XHRcdFx0ICogdmFsaWQuIFRvIGJlIHNhZmUsIHdlIGRpc2Nvbm5lY3QgYm90aCBhbmQgc3RhcnQgYWdhaW4gZnJvbSBzY3JhdGNoLiAqL1xuXHRcdFx0XHRpZihzeW5jRXJyKSB7XG5cdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZykge1xuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgYXR0ZW1wdGluZyB0byBzeW5jIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IGVyciA9ICcgKyBzeW5jRXJyKTtcblx0XHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBmaW5pc2hVcGdyYWRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0FjdGl2YXRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRcdFx0XHRzZWxmLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIHBvc3RTeW5jUG9zaXRpb24pO1xuXHRcdFx0XHRcdC8qIFJlc3RvcmUgcHJlLXN5bmMgc3RhdGUuIElmIHN0YXRlIGhhcyBjaGFuZ2VkIGluIHRoZSBtZWFudGltZSxcblx0XHRcdFx0XHQgKiBkb24ndCB0b3VjaCBpdCAtLSBzaW5jZSB0aGUgd2Vic29ja2V0IHRyYW5zcG9ydCB3YWl0cyBhIHRpY2sgYmVmb3JlXG5cdFx0XHRcdFx0ICogZGlzcG9zaW5nIGl0c2VsZiwgaXQncyBwb3NzaWJsZSBmb3IgaXQgdG8gaGF2ZSBoYXBwaWx5IHN5bmNlZFxuXHRcdFx0XHRcdCAqIHdpdGhvdXQgZXJyIHdoaWxlLCB1bmtub3duIHRvIGl0LCB0aGUgY29ubmVjdGlvbiBoYXMgY2xvc2VkIGluIHRoZVxuXHRcdFx0XHRcdCAqIG1lYW50aW1lIGFuZCB0aGUgd3MgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgZGVhdGggKi9cblx0XHRcdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG5cdFx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgc2VuZGluZyBxdWV1ZWQgbWVzc2FnZXMgb24gdXBncmFkZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRcdFx0XHRcdHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBidXQgc3RhdGUgaXMgbm93ICcgKyBzZWxmLnN0YXRlLnN0YXRlICsgJywgc28gbGVhdmluZyB1bmNoYW5nZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvKiBXYWl0IHVudGlsIHN5bmMgaXMgZG9uZSBhbmQgb2xkIHRyYW5zcG9ydCBpcyBpZGxlIGJlZm9yZSBhY3RpdmF0aW5nIG5ldyB0cmFuc3BvcnQuIFRoaXNcblx0XHRcdFx0ICogZ3VhcmFudGVlcyB0aGF0IG1lc3NhZ2VzIGFycml2ZSBhdCByZWFsdGltZSBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IGFyZSBzZW50LlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiBhIG1lc3NhZ2UgdGltZXMgb3V0IG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBzaW5jZSBpdCdzIHN0aWxsIHRoZSBhY3RpdmUgdHJhbnNwb3J0IHRoZVxuXHRcdFx0XHQgKiBtZXNzYWdlIHdpbGwgYmUgcmVxdWV1ZWQuIGRlYWN0aXZhdGVUcmFuc3BvcnQgd2lsbCBzZWUgdGhlIHBlbmRpbmcgdHJhbnNwb3J0IGFuZCBub3RpZnlcblx0XHRcdFx0ICogdGhlIGBjb25uZWN0aW5nYCBzdGF0ZSB3aXRob3V0IHN0YXJ0aW5nIGEgbmV3IGNvbm5lY3Rpb24sIHNvIHRoZSBuZXcgdHJhbnNwb3J0IGNhbiB0YWtlXG5cdFx0XHRcdCAqIG92ZXIgb25jZSBkZWFjdGl2YXRlVHJhbnNwb3J0IGNsZWFycyB0aGUgb2xkIHByb3RvY29sJ3MgcXVldWUuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIElmIHRoZXJlIGlzIG5vIG9sZCBwcm90b2NvbCwgdGhhdCBtZWFudCB0aGF0IHdlIHdlcmVuJ3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSBhdCB0aGVcblx0XHRcdFx0ICogYmVnaW5uaW5nIG9mIHRoZSBzeW5jIC0gbGlrZWx5IHRoZSBiYXNlIHRyYW5zcG9ydCBkaWVkIGp1c3QgYmVmb3JlIHRoZSBzeW5jLiBTbyBjYW4ganVzdFxuXHRcdFx0XHQgKiBmaW5pc2ggdGhlIHVwZ3JhZGUuIElmIHdlJ3JlIGFjdHVhbGx5IGluIGNsb3NpbmcvZmFpbGVkIHJhdGhlciB0aGFuIGNvbm5lY3RpbmcsIHRoYXQnc1xuXHRcdFx0XHQgKiBmaW5lLCBhY3RpdmF0ZXRyYW5zcG9ydCB3aWxsIGRlYWwgd2l0aCB0aGF0LiAqL1xuXHRcdFx0XHRpZihvbGRQcm90b2NvbCkge1xuXHRcdFx0XHQgLyogTW9zdCBvZiB0aGUgdGltZSB0aGlzIHdpbGwgYmUgYWxyZWFkeSB0cnVlOiB0aGUgbmV3LXRyYW5zcG9ydCBzeW5jIHdpbGwgaGF2ZSBnaXZlblxuXHRcdFx0XHQgKiBlbm91Z2ggdGltZSBmb3IgaW4tZmxpZ2h0IG1lc3NhZ2VzIG9uIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdG9sZFByb3RvY29sLm9uY2VJZGxlKGZpbmlzaFVwZ3JhZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbmlzaFVwZ3JhZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcblx0ICogaXQgd2lsbCBub3cgYmUgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgYWN0aXZhdGVkXG5cdCAqIHRoZSB0cmFuc3BvcnQgKGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmcvY2xvc2VkIGl0IHdpbGwgY2hvb3NlIG5vdCB0bykuXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbklkIHRoZSBpZCBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlscyB0aGUgZGV0YWlscyBvZiB0aGUgbmV3IGFjdGl2ZSBjb25uZWN0aW9uXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uUG9zaXRpb24gdGhlIHBvc2l0aW9uIGF0IHRoZSBwb2ludCBhY3RpdmF0aW9uOyBlaXRoZXIge2Nvbm5lY3Rpb25TZXJpYWw6IDxzZXJpYWw+fSBvciB7dGltZVNlcmlhbDogPHNlcmlhbD59XG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblx0XHRpZihlcnJvcikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnZXJyb3IgPSAnICsgZXJyb3IpO1xuXHRcdH1cblx0XHRpZihjb25uZWN0aW9uSWQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25JZCA9ICAnICsgY29ubmVjdGlvbklkKTtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb25EZXRhaWxzID0gICcgKyBKU09OLnN0cmluZ2lmeShjb25uZWN0aW9uRGV0YWlscykpO1xuXHRcdH1cblx0XHRpZihjb25uZWN0aW9uUG9zaXRpb24pIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3NlcmlhbCA9ICAnICsgKGNvbm5lY3Rpb25Qb3NpdGlvbi50aW1lU2VyaWFsIHx8IGNvbm5lY3Rpb25Qb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpO1xuXG5cdFx0LyogaWYgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIG1vdmVkIHRvIHRoZSBjbG9zaW5nL2Nsb3NlZCBzdGF0ZSBiZWZvcmUgdGhpc1xuXHRcdCAqIGNvbm5lY3Rpb24gZXZlbnQsIHRoZW4gd2Ugd29uJ3QgYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgKi9cblx0XHR2YXIgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsXG5cdFx0XHRjb25uZWN0ZWRTdGF0ZSA9IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjdXJyZW50IHN0YXRlID0gJyArIGV4aXN0aW5nU3RhdGUuc3RhdGUpO1xuXHRcdGlmKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZy5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NlZC5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZC5zdGF0ZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYW5kIGFiYW5kb25pbmcnKTtcblx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogcmVtb3ZlIHRoaXMgdHJhbnNwb3J0IGZyb20gcGVuZGluZyB0cmFuc3BvcnRzICovXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXG5cdFx0LyogaWYgdGhlIHRyYW5zcG9ydCBpcyBub3QgY29ubmVjdGVkIChlZyBiZWNhdXNlIGl0IGZhaWxlZCBkdXJpbmcgYVxuXHRcdCAqIHNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiNvbmNlTm9QZW5kaW5nIHdhaXQpIHRoZW4gZG9uJ3QgYWN0aXZhdGUgaXQgKi9cblx0XHRpZighdHJhbnNwb3J0LmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEZWNsaW5pbmcgdG8gYWN0aXZhdGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQgKyAnIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZCcpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIHRoZSBnaXZlbiB0cmFuc3BvcnQgaXMgY29ubmVjdGVkOyB0aGlzIHdpbGwgaW1tZWRpYXRlbHlcblx0XHQgKiB0YWtlIG92ZXIgYXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgKi9cblx0XHR2YXIgZXhpc3RpbmdBY3RpdmVQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2w7XG5cdFx0dGhpcy5hY3RpdmVQcm90b2NvbCA9IG5ldyBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSh0cmFuc3BvcnQpO1xuXHRcdHRoaXMuaG9zdCA9IHRyYW5zcG9ydC5wYXJhbXMuaG9zdDtcblxuXHRcdHZhciBjb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcblx0XHRpZihjb25uZWN0aW9uS2V5ICYmIHRoaXMuY29ubmVjdGlvbktleSAhPSBjb25uZWN0aW9uS2V5KSAge1xuXHRcdFx0dGhpcy5zZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbiwgISFlcnJvcik7XG5cdFx0fVxuXG5cdFx0LyogUmVicm9hZGNhc3QgYW55IG5ldyBjb25uZWN0aW9uRGV0YWlscyBmcm9tIHRoZSBhY3RpdmUgdHJhbnNwb3J0LCB3aGljaFxuXHRcdCAqIGNhbiBjb21lIGF0IGFueSB0aW1lIChlZyBmb2xsb3dpbmcgYSByZWF1dGgpLCBhbmQgZW1pdCBhbiBSVE4yNCBVUERBVEVcblx0XHQgKiBldmVudC4gKExpc3RlbmVyIGFkZGVkIG9uIG5leHRUaWNrIGJlY2F1c2Ugd2UncmUgaW4gYSB0cmFuc3BvcnQub24oJ2Nvbm5lY3RlZCcpXG5cdFx0ICogY2FsbGJhY2sgYXQgdGhlIG1vbWVudDsgaWYgd2UgYWRkIGl0IG5vdyB3ZSdsbCBiZSBhZGRpbmcgaXQgdG8gdGhlIGVuZFxuXHRcdCAqIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgYW5kIGl0J2xsIGJlIGNhbGxlZCBpbW1lZGlhdGVseSkgKi9cblx0XHR0aGlzLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHR0cmFuc3BvcnQub24oJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKGNvbm5lY3RlZEVyciwgX2Nvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdFx0c2VsZi5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3VwZGF0ZScsIG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgY29ubmVjdGVkRXJyKSk7XG5cdFx0XHR9KTtcblx0XHR9KVxuXG5cdFx0LyogSWYgcHJldmlvdXNseSBub3QgY29ubmVjdGVkLCBub3RpZnkgdGhlIHN0YXRlIGNoYW5nZSAoaW5jbHVkaW5nIGFueVxuXHRcdCAqIGVycm9yKS4gKi9cblx0XHRpZihleGlzdGluZ1N0YXRlLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdGlmKGVycm9yKSB7XG5cdFx0XHRcdC8qIGlmIHVwZ3JhZGluZyB3aXRob3V0IGVycm9yLCBsZWF2ZSBhbnkgZXhpc3RpbmcgZXJyb3JSZWFzb24gYWxvbmUgKi9cblx0XHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yO1xuXHRcdFx0XHQvKiBPbmx5IGJvdGhlciBlbWl0dGluZyBhbiB1cGdyYWRlIGlmIHRoZXJlJ3MgYW4gZXJyb3I7IG90aGVyd2lzZSBpdCdzXG5cdFx0XHRcdCAqIGp1c3QgYSB0cmFuc3BvcnQgdXBncmFkZSwgc28gYXV0aCBkZXRhaWxzIHdvbid0IGhhdmUgY2hhbmdlZCAqL1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgZXJyb3IpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjb25uZWN0ZWQnLCBlcnJvcjogZXJyb3J9KTtcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvciB8fCBudWxsO1xuXHRcdH1cblxuXHRcdC8qIFNlbmQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgdXBkYXRlLCBhcyBDaGFubmVscyBob29rcyBpbnRvIHRoaXMgdG9cblx0XHQgKiByZXNlbmQgYXR0YWNoZXMgb24gYSBuZXcgdHJhbnNwb3J0IGlmIG5lY2Vzc2FyeSAqL1xuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LmFjdGl2ZScsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiBHcmFjZWZ1bGx5IHRlcm1pbmF0ZSBleGlzdGluZyBwcm90b2NvbCAqL1xuXHRcdGlmKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wpIHtcblx0XHRcdGlmKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgPiAwKSB7XG5cdFx0XHRcdC8qIFdlIGNvdWxkIGp1c3QgcmVxdWV1ZSBwZW5kaW5nIG1lc3NhZ2VzIG9uIHRoZSBuZXcgdHJhbnNwb3J0LCBidXRcblx0XHRcdFx0ICogYWN0dWFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOiB0cmFuc3BvcnRzIHNob3VsZCBvbmx5IHRha2Ugb3ZlclxuXHRcdFx0XHQgKiBmcm9tIG90aGVyIGFjdGl2ZSB0cmFuc3BvcnRzIHdoZW4gdXBncmFkaW5nLCBhbmQgdXBncmFkaW5nIHdhaXRzIGZvclxuXHRcdFx0XHQgKiB0aGUgb2xkIHRyYW5zcG9ydCB0byBiZSBpZGxlLiBTbyBsb2cgYW4gZXJyb3IuICovXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ1ByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbCAoZm9yIHRyYW5zcG9ydCAnICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQuc2hvcnROYW1lICsgJywgbmV3IG9uZSBpcyAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICcpIGZpbmlzaGluZyB3aXRoICcgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgJyBtZXNzYWdlcyBzdGlsbCBwZW5kaW5nJyk7XG5cdFx0XHR9XG5cdFx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IHdhcyBhbHNvIHRoZSB0cmFuc3BvcnQgZm9yIHRoZSBwcmV2aW91cyBhY3RpdmUgcHJvdG9jb2w7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJzsgc3RhY2sgPSAnICsgbmV3IEVycm9yKCkuc3RhY2s7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcblx0XHRcdFx0X3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAndHJhbnNwb3J0LXByZXZpb3VzbHktYWN0aXZlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGlzdGluZ0FjdGl2ZVByb3RvY29sLmZpbmlzaCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIFRlcm1pbmF0ZSBhbnkgb3RoZXIgcGVuZGluZyB0cmFuc3BvcnQocyksIGFuZFxuXHRcdCAqIGFib3J0IGFueSBub3QteWV0LXBlbmRpbmcgdHJhbnNwb3J0IGF0dGVtcHRzICovXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbihwZW5kaW5nVHJhbnNwb3J0KSB7XG5cdFx0XHRpZihwZW5kaW5nVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcGVuZGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJzsgc3RhY2sgPSAnICsgbmV3IEVycm9yKCkuc3RhY2s7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcblx0XHRcdFx0X3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAndHJhbnNwb3J0LWFjdGl2YXRpbmctcGVuZGluZycpO1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHNlbGYucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbihwcm9wb3NlZFRyYW5zcG9ydCkge1xuXHRcdFx0aWYocHJvcG9zZWRUcmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCBpcyBzdGlsbCBtYXJrZWQgYXMgYSBwcm9wb3NlZCB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJzsgc3RhY2sgPSAnICsgbmV3IEVycm9yKCkuc3RhY2s7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcblx0XHRcdFx0X3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAndHJhbnNwb3J0LWFjdGl2YXRpbmctcHJvcG9zZWQnKTtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZShzZWxmLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb3Bvc2VkVHJhbnNwb3J0LmRpc3Bvc2UoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBubyBsb25nZXIgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFRoaXMgY2FuIG9jY3VyXG5cdCAqIGluIGFueSB0cmFuc3BvcnQgY29ubmVjdGlvbiBzdGF0ZS5cblx0ICogQHBhcmFtIHRyYW5zcG9ydFxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlYWN0aXZhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQsIHN0YXRlLCBlcnJvcikge1xuXHRcdHZhciBjdXJyZW50UHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sLFxuXHRcdFx0d2FzQWN0aXZlID0gY3VycmVudFByb3RvY29sICYmIGN1cnJlbnRQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSA9PT0gdHJhbnNwb3J0LFxuXHRcdFx0d2FzUGVuZGluZyA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSxcblx0XHRcdHdhc1Byb3Bvc2VkID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KSxcblx0XHRcdG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSB0aGlzLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKTtcblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzdGF0ZSA9ICcgKyBzdGF0ZSArICh3YXNBY3RpdmUgPyAnOyB3YXMgYWN0aXZlJyA6IHdhc1BlbmRpbmcgPyAnOyB3YXMgcGVuZGluZycgOiB3YXNQcm9wb3NlZCA/ICc7IHdhcyBwcm9wb3NlZCcgOiAnJykgKyAobm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA/ICcnIDogJzsgYW5vdGhlciB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uJykpO1xuXHRcdGlmKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3JlYXNvbiA9ICAnICsgZXJyb3IubWVzc2FnZSk7XG5cblx0XHRpZih3YXNBY3RpdmUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnR2V0dGluZywgY2xlYXJpbmcsIGFuZCByZXF1ZXVpbmcgJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcblx0XHRcdHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcblx0XHRcdC8qIENsZWFyIGFueSBtZXNzYWdlcyB3ZSByZXF1ZXVlIHRvIGFsbG93IHRoZSBwcm90b2NvbCB0byBiZWNvbWUgaWRsZS5cblx0XHRcdCAqIEluIGNhc2Ugb2YgYW4gdXBncmFkZSwgdGhpcyB3aWxsIHRyaWdnZXIgYW4gaW1tZWRpYXRlIGFjdGl2YXRpb24gb2Zcblx0XHRcdCAqIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCwgc28gZGVsYXkgYSB0aWNrIHNvIHRoaXMgdHJhbnNwb3J0IGNhbiBmaW5pc2hcblx0XHRcdCAqIGRlYWN0aXZhdGluZyAqL1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VycmVudFByb3RvY29sLmNsZWFyUGVuZGluZ01lc3NhZ2VzKCk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSB0aGlzLmhvc3QgPSBudWxsO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuY2hhbm5lbFJlc3VtZUNoZWNrVGltZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LmluYWN0aXZlJywgdHJhbnNwb3J0KTtcblxuXHRcdC8qIHRoaXMgdHJhbnNwb3J0IHN0YXRlIGNoYW5nZSBpcyBhIHN0YXRlIGNoYW5nZSBmb3IgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIGlmXG5cdFx0ICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHNcblx0XHQgKiAgIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbiwganVzdCB3YWl0aW5nIGZvciB0aGVcblx0XHQgKiAgIGFjdGl2ZSB0cmFuc3BvcnQgdG8gZmluaXNoIHdoYXQgaXRzIGRvaW5nOyBvclxuXHRcdCAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZSBlcnJvciB3YXMgZmF0YWwgKHNvXG5cdFx0ICogICB1bmhlYWxhYmxlIGJ5IGFub3RoZXIgdHJhbnNwb3J0KTsgb3Jcblx0XHQgKiAtIHRoZXJlIGlzIG5vIGFjdGl2ZSB0cmFuc3BvcnQsIGFuZCB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZ1xuXHRcdCAqICAgcGVuZGluZyB0cmFuc3BvcnQgKHNvIHdlIHdlcmUgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUpXG5cdFx0ICovXG5cdFx0aWYoKHdhc0FjdGl2ZSAmJiBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKSB8fFxuXHRcdFx0KHdhc0FjdGl2ZSAmJiAoc3RhdGUgPT09ICdmYWlsZWQnKSB8fCAoc3RhdGUgPT09ICdjbG9zZWQnKSkgfHxcblx0XHRcdChjdXJyZW50UHJvdG9jb2wgPT09IG51bGwgJiYgd2FzUGVuZGluZyAmJiB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkpIHtcblxuXHRcdFx0LyogSWYgd2UncmUgZGlzY29ubmVjdGVkIHdpdGggYSA1eHggd2UgbmVlZCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcblx0XHRcdCAqIChSVE4xNGQpLCBidXQgKGEpIGR1ZSB0byBob3cgdGhlIHVwZ3JhZGUgc2VxdWVuY2Ugd29ya3MsIHRoZVxuXHRcdFx0ICogaG9zdC90cmFuc3BvcnQgc2VsZWN0aW9uIHNlcXVlbmNlIG9ubHkgY2FyZXMgYWJvdXQgZ2V0dGluZyB0b1xuXHRcdFx0ICogYHByZWNvbm5lY3RgIChlZyBlc3RhYmxpc2hpbmcgYSB3ZWJzb2NrZXQpIGdldHRpbmcgYSBgZGlzY29ubmVjdGVkYFxuXHRcdFx0ICogcHJvdG9jb2wgbWVzc2FnZSBhZnRlcndhcmRzIGlzIHRvbyBsYXRlOyBhbmQgKGIpIGhvc3QgcmV0cnkgb25seVxuXHRcdFx0ICogYXBwbGllcyB0byBjb25uZWN0QmFzZSB1bmxlc3MgdGhlIHN0b3JlZCBwcmVmZXJlbmNlIHRyYW5zcG9ydCBkb2Vzbid0XG5cdFx0XHQgKiB3b3JrLiBXZSBzb2x2ZSB0aGlzIGJ5IHVucGVyc2lzdGluZyB0aGUgdHJhbnNwb3J0IHByZWZlcmVuY2UgYW5kXG5cdFx0XHQgKiBzZXR0aW5nIGFuIGluc3RhbmNlIHZhcmlhYmxlIHRvIGZvcmNlIGZhbGxiYWNrIGhvc3RzIHRvIGJlIHVzZWQgKGlmXG5cdFx0XHQgKiBhbnkpIGhlcmUuIEJpdCBvZiBhIGtsdWRnZSwgYnV0IG5vIHJlYWwgYmV0dGVyIGFsdGVybmF0aXZlcyB3aXRob3V0XG5cdFx0XHQgKiByZXdyaXRpbmcgdGhlIGVudGlyZSB0aGluZyAqL1xuXHRcdFx0aWYoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmIGVycm9yICYmIGVycm9yLnN0YXR1c0NvZGUgPiA1MDAgJiYgdGhpcy5odHRwSG9zdHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblx0XHRcdFx0dGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XG5cdFx0XHRcdC8qIGFuZCB0cnkgdG8gY29ubmVjdCBhZ2FpbiB0byB0cnkgYSBmYWxsYmFjayBob3N0IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHVzdWFsIDE1cyBkaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQgKi9cblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IHN0YXRlLCBlcnJvcjogZXJyb3IsIHJldHJ5SW1tZWRpYXRlbHk6IHRydWV9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBUT0RPIHJlbW92ZSBiZWxvdyBsaW5lIG9uY2UgcmVhbHRpbWUgc2VuZHMgdG9rZW4gZXJyb3JzIGFzIERJU0NPTk5FQ1RFRHMgKi9cblx0XHRcdHZhciBuZXdDb25uZWN0aW9uU3RhdGUgPSAoc3RhdGUgPT09ICdmYWlsZWQnICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKGVycm9yKSkgPyAnZGlzY29ubmVjdGVkJyA6IHN0YXRlO1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IG5ld0Nvbm5lY3Rpb25TdGF0ZSwgZXJyb3I6IGVycm9yfSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYod2FzQWN0aXZlICYmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpICYmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSkge1xuXHRcdFx0LyogSWYgd2Ugd2VyZSBhY3RpdmUgYnV0IHRoZXJlIGlzIGFub3RoZXIgdHJhbnNwb3J0IHNjaGVkdWxlZCBmb3Jcblx0XHRcdCogYWN0aXZhdGlvbiwgZ28gaW50byB0byB0aGUgY29ubmVjdGluZyBzdGF0ZSB1bnRpbCB0aGF0IHRyYW5zcG9ydFxuXHRcdFx0KiBhY3RpdmF0ZXMgYW5kIHNldHMgdXMgYmFjayB0byBjb25uZWN0ZWQuIChtYW51YWxseSBzdGFydGluZyB0aGVcblx0XHRcdCogdHJhbnNpdGlvbiB0aW1lcnMgaW4gY2FzZSB0aGF0IG5ldmVyIGhhcHBlbnMpLiAoSWYgd2Ugd2VyZSBpbiB0aGVcblx0XHRcdCogc3luY2hyb25pemluZyBzdGF0ZSwgdGhlbiB0aGF0J3MgZmluZSwgdGhlIG9sZCB0cmFuc3BvcnQganVzdCBnb3QgaXRzXG5cdFx0XHQqIGRpc2Nvbm5lY3RlZCBiZWZvcmUgdGhlIG5ldyBvbmUgZ290IHRoZSBzeW5jIC0tIGlnbm9yZSBpdCBhbmQga2VlcFxuXHRcdFx0KiB3YWl0aW5nIGZvciB0aGUgc3luYy4gSWYgaXQgZmFpbHMgd2UgaGF2ZSBhIHNlcGFyYXRlIHN5bmMgdGltZXIgdGhhdFxuXHRcdFx0KiB3aWxsIGV4cGlyZSkuICovXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3dhc0FjdGl2ZSBidXQgYW5vdGhlciB0cmFuc3BvcnQgaXMgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIHNvIGdvaW5nIGludG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgaXQgYWN0aXZhdGVzJyk7XG5cdFx0XHR0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG5cdFx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJywgZXJyb3I6IGVycm9yfSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEhlbHBlciB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyB3aGljaCBhcmUgcGVuZGluZyxcblx0KiBoYXZlIGJlZW4gY29ubmVjdGVkLCBhbmQgYXJlIGp1c3Qgd2FpdGluZyBmb3Igb25jZU5vUGVuZGluZyB0byBmaXJlIGJlZm9yZVxuXHQqIGJlaW5nIGFjdGl2YXRlZCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHkodGhpcy5wZW5kaW5nVHJhbnNwb3J0cykgfHxcblx0XHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMuZXZlcnkoZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRcdHJldHVybiAhdHJhbnNwb3J0LmlzQ29ubmVjdGVkO1xuXHRcdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGFjdGl2YXRpbmcgYSBuZXcgdHJhbnNwb3J0LCB0byBlbnN1cmUgbWVzc2FnZSBkZWxpdmVyeVxuXHQgKiBvbiB0aGUgbmV3IHRyYW5zcG9ydCBzeW5jaHJvbmlzZXMgd2l0aCB0aGUgbWVzc2FnZXMgYWxyZWFkeSByZWNlaXZlZFxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbih0cmFuc3BvcnQsIHJlcXVlc3RlZFN5bmNQb3NpdGlvbiwgY2FsbGJhY2spIHtcblx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dHJhbnNwb3J0Lm9mZignc3luYycpO1xuXHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1RpbWVvdXQgd2FpdGluZyBmb3Igc3luYyByZXNwb25zZScsIDUwMDAwLCA1MDApKTtcblx0XHR9LCB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG5cblx0XHQvKiBzZW5kIHN5bmMgcmVxdWVzdCAqL1xuXHRcdHZhciBzeW5jTWVzc2FnZSA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbjogYWN0aW9ucy5TWU5DLFxuXHRcdFx0Y29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5XG5cdFx0fSk7XG5cblx0XHRpZihyZXF1ZXN0ZWRTeW5jUG9zaXRpb24udGltZVNlcmlhbCkge1xuXHRcdFx0c3luY01lc3NhZ2UudGltZVNlcmlhbCA9IHJlcXVlc3RlZFN5bmNQb3NpdGlvbi50aW1lU2VyaWFsO1xuXHRcdH0gZWxzZSBpZihyZXF1ZXN0ZWRTeW5jUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzeW5jTWVzc2FnZS5jb25uZWN0aW9uU2VyaWFsID0gcmVxdWVzdGVkU3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0fVxuXHRcdHRyYW5zcG9ydC5zZW5kKHN5bmNNZXNzYWdlKTtcblxuXHRcdHRyYW5zcG9ydC5vbmNlKCdzeW5jJywgZnVuY3Rpb24oY29ubmVjdGlvbklkLCBzeW5jUG9zaXRpb24pIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIGNvbm5lY3Rpb25JZCwgc3luY1Bvc2l0aW9uKTtcblx0XHR9KTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbiwgaGFzQ29ubmVjdGlvbkVycm9yKSB7XG5cdFx0LyogaWYgY29ubmVjdGlvbktleSBjaGFuZ2VzIGJ1dCBjb25uZWN0aW9uSWQgc3RheXMgdGhlIHNhbWUsIHRoZW4ganVzdCBhXG5cdFx0ICogdHJhbnNwb3J0IGNoYW5nZSBvbiB0aGUgc2FtZSBjb25uZWN0aW9uLiBJZiBjb25uZWN0aW9uSWQgY2hhbmdlcywgd2UncmVcblx0XHQgKiBvbiBhIG5ldyBjb25uZWN0aW9uLCB3aXRoIGltcGxpY2F0aW9ucyBmb3IgbXNnU2VyaWFsIGFuZCBjaGFubmVsIHN0YXRlLFxuXHRcdCAqIGFuZCByZXNldHRpbmcgdGhlIGNvbm5lY3Rpb25TZXJpYWwgcG9zaXRpb24gKi9cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0LyogSWYgbm8gcHJldmlvdXMgY29ubmVjdGlvbklkLCBkb24ndCByZXNldCB0aGUgbXNnU2VyaWFsIGFzIGl0IG1heSBoYXZlXG5cdFx0ICogYmVlbiBzZXQgYnkgcmVjb3ZlciBkYXRhICh1bmxlc3MgdGhlIHJlY292ZXIgZmFpbGVkKSAqL1xuXHRcdHZhciBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uaWQsXG5cdFx0XHRjb25uSWRDaGFuZ2VkID0gcHJldkNvbm5JZCAmJiAocHJldkNvbm5JZCAhPT0gY29ubmVjdGlvbklkKSxcblx0XHRcdHJlY292ZXJGYWlsdXJlID0gIXByZXZDb25uSWQgJiYgaGFzQ29ubmVjdGlvbkVycm9yO1xuXHRcdGlmKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpICB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ1Jlc2V0dGluZyBtc2dTZXJpYWwnKTtcblx0XHRcdHRoaXMubXNnU2VyaWFsID0gMDtcblx0XHR9XG5cdFx0LyogYnV0IGRvIG5lZWQgdG8gcmVhdHRhY2ggY2hhbm5lbHMsIGZvciBjaGFubmVscyB0aGF0IHdlcmUgcHJldmlvdXNseSBpblxuXHRcdCAqIHRoZSBhdHRhY2hlZCBzdGF0ZSBldmVuIHRob3VnaCB0aGUgY29ubmVjdGlvbiBtb2RlIHdhcyAnY2xlYW4nIGR1ZSB0byBhXG5cdFx0ICogZnJlc2huZXNzIGNoZWNrIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzM5NCAqL1xuXHRcdGlmKHRoaXMuY29ubmVjdGlvbklkICE9PSBjb25uZWN0aW9uSWQpICB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ05ldyBjb25uZWN0aW9uSWQ7IHJlYXR0YWNoaW5nIGFueSBhdHRhY2hlZCBjaGFubmVscycpO1xuXHRcdFx0LyogV2FpdCB0aWxsIG5leHQgdGljayBiZWZvcmUgcmVhdHRhY2hpbmcgY2hhbm5lbHMsIHNvIHRoYXQgY29ubmVjdGlvblxuXHRcdFx0ICogc3RhdGUgd2lsbCBiZSB1cGRhdGVkIGFuZCBzbyB0aGF0IGl0IHdpbGwgYmUgYXBwbGllZCBhZnRlclxuXHRcdFx0ICogQ2hhbm5lbHMjb25UcmFuc3BvcnRVcGRhdGUsIGVsc2UgY2hhbm5lbHMgd2lsbCBub3QgaGF2ZSBhbiBBVFRBQ0hFRFxuXHRcdFx0ICogc2VudCB0d2ljZSAob25jZSBmcm9tIHRoaXMgYW5kIG9uY2UgZnJvbSB0aGF0KS4gKi9cblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYucmVhbHRpbWUuY2hhbm5lbHMucmVhdHRhY2goKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuY2hlY2tDaGFubmVsc09uUmVzdW1lKSB7XG5cdFx0XHQvKiBGb3IgYXR0YWNoZWQgY2hhbm5lbHMsIHNldCB0aGUgYXR0YWNoZWQgbXNnIGluZGljYXRvciB2YXJpYWJsZSB0byBmYWxzZSxcblx0XHRcdCAqIHdhaXQgMzBzLCBhbmQgY2hlY2sgd2UgZ290IGFuIGF0dGFjaGVkIGZvciBlYWNoIG9uZS5cblx0XHRcdCAqIDMwcyB3YXMgY2hvc2VuIHRvIGJlIDVzIGxvbmdlciB0aGFuIHRoZSB0cmFuc3BvcnQgaWRsZSB0aW1lb3V0IGV4cGlyZVxuXHRcdFx0ICogdGltZSwgaW4gYW4gYXR0ZW1wdCB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMgZHVlIHRvIGEgdHJhbnNwb3J0XG5cdFx0XHQgKiBzaWxlbnRseSBmYWlsaW5nIGltbWVkaWF0ZWx5IGFmdGVyIGEgcmVzdW1lICovXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvbigpJywgJ1NhbWUgY29ubmVjdGlvbklkOyBjaGVja0NoYW5uZWxzT25SZXN1bWUgaXMgZW5hYmxlZCcpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuY2hhbm5lbFJlc3VtZUNoZWNrVGltZXIpO1xuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5yZXNldEF0dGFjaGVkTXNnSW5kaWNhdG9ycygpO1xuXHRcdFx0dGhpcy5jaGFubmVsUmVzdW1lQ2hlY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYucmVhbHRpbWUuY2hhbm5lbHMuY2hlY2tBdHRhY2hlZE1zZ0luZGljYXRvcnMoY29ubmVjdGlvbklkKTtcblx0XHRcdH0sIDMwMDAwKTtcblx0XHR9XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmlkID0gdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG5cdFx0dmFyIGZvcmNlUmVzZXRNZXNzYWdlU2VyaWFsID0gY29ubklkQ2hhbmdlZCB8fCAhcHJldkNvbm5JZDtcblx0XHR0aGlzLnNldENvbm5lY3Rpb25TZXJpYWwoY29ubmVjdGlvblBvc2l0aW9uLCBmb3JjZVJlc2V0TWVzc2FnZVNlcmlhbCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGVhckNvbm5lY3Rpb25TZXJpYWwoKTtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0dGhpcy51bnBlcnNpc3RDb25uZWN0aW9uKCk7XG5cdH07XG5cblx0LyogZm9yY2U6IHNldCB0aGUgY29ubmVjdGlvblNlcmlhbCBldmVuIGlmIGl0J3MgbGVzcyB0aGFuIHRoZSBjdXJyZW50XG5cdCAqIGNvbm5lY3Rpb25TZXJpYWwuIFVzZWQgZm9yIG5ldyBjb25uZWN0aW9ucy5cblx0ICogUmV0dXJucyB0cnVlIGlmZiB0aGUgbWVzc2FnZSB3YXMgcmVqZWN0ZWQgYXMgYSBkdXBsaWNhdGUuICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uU2VyaWFsID0gZnVuY3Rpb24oY29ubmVjdGlvblBvc2l0aW9uLCBmb3JjZSkge1xuXHRcdHZhciB0aW1lU2VyaWFsID0gY29ubmVjdGlvblBvc2l0aW9uLnRpbWVTZXJpYWwsXG5cdFx0XHRjb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblBvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb25TZXJpYWwoKScsICdVcGRhdGluZyBjb25uZWN0aW9uIHNlcmlhbDsgc2VyaWFsID0gJyArIGNvbm5lY3Rpb25TZXJpYWwgKyAnOyB0aW1lU2VyaWFsID0gJyArIHRpbWVTZXJpYWwgKyAnOyBmb3JjZSA9ICcgKyBmb3JjZSArICc7IHByZXZpb3VzID0gJyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCk7XG5cdFx0aWYodGltZVNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0aW1lU2VyaWFsIDw9IHRoaXMudGltZVNlcmlhbCAmJiAhZm9yY2UpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb25TZXJpYWwoKScsICdyZWNlaXZlZCBtZXNzYWdlIHdpdGggdGltZVNlcmlhbCAnICsgdGltZVNlcmlhbCArICcsIGJ1dCBjdXJyZW50IHRpbWVTZXJpYWwgaXMgJyArIHRoaXMudGltZVNlcmlhbCArICc7IGFzc3VtaW5nIG1lc3NhZ2UgaXMgYSBkdXBsaWNhdGUgYW5kIGRpc2NhcmRpbmcgaXQnKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24udGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbCA9IHRpbWVTZXJpYWw7XG5cdFx0XHR0aGlzLnNldFJlY292ZXJ5S2V5KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYoY29ubmVjdGlvblNlcmlhbCA8PSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uU2VyaWFsKCknLCAncmVjZWl2ZWQgbWVzc2FnZSB3aXRoIGNvbm5lY3Rpb25TZXJpYWwgJyArIGNvbm5lY3Rpb25TZXJpYWwgKyAnLCBidXQgY3VycmVudCBjb25uZWN0aW9uU2VyaWFsIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgKyAnOyBhc3N1bWluZyBtZXNzYWdlIGlzIGEgZHVwbGljYXRlIGFuZCBkaXNjYXJkaW5nIGl0Jyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IGNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0XHR0aGlzLnNldFJlY292ZXJ5S2V5KCk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb25TZXJpYWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xlYXJSZWNvdmVyeUtleSgpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRSZWNvdmVyeUtleSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5yZWNvdmVyeUtleSA9IHRoaXMuY29ubmVjdGlvbktleSArICc6JyArICh0aGlzLnRpbWVTZXJpYWwgfHwgdGhpcy5jb25uZWN0aW9uU2VyaWFsKSArICc6JyArIHRoaXMubXNnU2VyaWFsO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclJlY292ZXJ5S2V5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5ID0gbnVsbDtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MgPSBmdW5jdGlvbigpIHtcblx0XHRpZighdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHNpbmNlTGFzdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcblx0XHRpZihzaW5jZUxhc3QgPiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCArIHRoaXMubWF4SWRsZUludGVydmFsKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKScsICdMYXN0IGtub3duIGFjdGl2aXR5IGZyb20gcmVhbHRpbWUgd2FzICcgKyBzaW5jZUxhc3QgKyAnbXMgYWdvOyBkaXNjYXJkaW5nIGNvbm5lY3Rpb24gc3RhdGUnKTtcblx0XHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG5cdFx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuXHRcdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5xdWV1ZUV2ZW50cyA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG5cdCAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0XHRpZihoYXZlU2Vzc2lvblN0b3JhZ2UpIHtcblx0XHRcdHZhciByZWNvdmVyeUtleSA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5yZWNvdmVyeUtleTtcblx0XHRcdGlmKHJlY292ZXJ5S2V5KSB7XG5cdFx0XHRcdHNldFNlc3Npb25SZWNvdmVyRGF0YSh7XG5cdFx0XHRcdFx0cmVjb3ZlcnlLZXk6IHJlY292ZXJ5S2V5LFxuXHRcdFx0XHRcdGRpc2Nvbm5lY3RlZEF0OiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpLFxuXHRcdFx0XHRcdGxvY2F0aW9uOiBnbG9iYWwubG9jYXRpb24sXG5cdFx0XHRcdFx0Y2xpZW50SWQ6IHRoaXMucmVhbHRpbWUuYXV0aC5jbGllbnRJZFxuXHRcdFx0XHR9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcblx0ICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKTtcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIHN0YXRlIG1hbmFnZW1lbnRcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcnJvclJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdW3RoaXMuc3RhdGUuc3RhdGVdO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZW5hY3RTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0dmFyIGxvZ0xldmVsID0gc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gJ2ZhaWxlZCcgPyBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IgOiBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUFKT1I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKGxvZ0xldmVsLCAnQ29ubmVjdGlvbiBzdGF0ZScsIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAoc3RhdGVDaGFuZ2UucmVhc29uID8gKCc7IHJlYXNvbjogJyArIHN0YXRlQ2hhbmdlLnJlYXNvbikgOiAnJykpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5lbmFjdFN0YXRlQ2hhbmdlJywgJ3NldHRpbmcgbmV3IHN0YXRlOiAnICsgc3RhdGVDaGFuZ2UuY3VycmVudCArICc7IHJlYXNvbiA9ICcgKyAoc3RhdGVDaGFuZ2UucmVhc29uICYmIHN0YXRlQ2hhbmdlLnJlYXNvbi5tZXNzYWdlKSk7XG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xuXHRcdGlmKHN0YXRlQ2hhbmdlLnJlYXNvbikge1xuXHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcblx0XHR9XG5cdFx0aWYobmV3U3RhdGUudGVybWluYWwgfHwgbmV3U3RhdGUuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHQvKiBzdXNwZW5kZWQgaXMgbm9udGVybWluYWwsIGJ1dCBvbmNlIGluIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHJlYWx0aW1lXG5cdFx0XHQgKiB3aWxsIGhhdmUgZGlzY2FyZGVkIG91ciBjb25uZWN0aW9uIHN0YXRlLCBzbyBmdXRoZXIgY29ubmVjdGlvblxuXHRcdFx0ICogYXR0ZW1wdHMgc2hvdWxkIHN0YXJ0IGZyb20gc2NyYXRjaCAqL1xuXHRcdFx0dGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCdjb25uZWN0aW9uc3RhdGUnLCBzdGF0ZUNoYW5nZSk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogQ29ubmVjdGlvbk1hbmFnZXIgY29ubmVjdGlvbiBsaWZlY3ljbGVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24odHJhbnNpdGlvblN0YXRlKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAndHJhbnNpdGlvblN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlKTtcblxuXHRcdGlmKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICdjbGVhcmluZyBhbHJlYWR5LXJ1bm5pbmcgdGltZXInKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMudHJhbnNpdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGlmKHNlbGYudHJhbnNpdGlvblRpbWVyKSB7XG5cdFx0XHRcdHNlbGYudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUgKyAnIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlKTtcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6IHRyYW5zaXRpb25TdGF0ZS5mYWlsU3RhdGV9KTtcblx0XHRcdH1cblx0XHR9LCB0cmFuc2l0aW9uU3RhdGUucmV0cnlEZWxheSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKScsICcnKTtcblx0XHRpZih0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0U3VzcGVuZFRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHRoaXMuc3VzcGVuZFRpbWVyKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGlmKHNlbGYuc3VzcGVuZFRpbWVyKSB7XG5cdFx0XHRcdHNlbGYuc3VzcGVuZFRpbWVyID0gbnVsbDtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZCcsICdyZXF1ZXN0aW5nIG5ldyBzdGF0ZTogc3VzcGVuZGVkJyk7XG5cdFx0XHRcdHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ3N1c3BlbmRlZCc7XG5cdFx0XHRcdHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcucXVldWVFdmVudHMgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdzdXNwZW5kZWQnfSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jaGVja1N1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0aWYoc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHN0YXRlICE9PSAnc3VzcGVuZGVkJyAmJiBzdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKVxuXHRcdFx0dGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsU3VzcGVuZFRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnZGlzY29ubmVjdGVkJztcblx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gdHJ1ZTtcblx0XHRpZih0aGlzLnN1c3BlbmRUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuc3VzcGVuZFRpbWVyKTtcblx0XHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UmV0cnlUaW1lciA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdyZXRyeWluZycpO1xuXHRcdFx0c2VsZi5yZXRyeVRpbWVyID0gbnVsbDtcblx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0fSwgaW50ZXJ2YWwpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcblx0XHRcdHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uKGluZGljYXRlZCkge1xuXHRcdHZhciBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogV2UgcmV0cnkgaW1tZWRpYXRlbHkgaWY6XG5cdFx0ICogLSBzb21ldGhpbmcgZGlzY29ubmVjdHMgdXMgd2hpbGUgd2UncmUgY29ubmVjdGVkLCBvclxuXHRcdCAqIC0gYSB2aWFibGUgKGJ1dCBub3QgeWV0IGFjdGl2ZSkgdHJhbnNwb3J0IGZhaWxzIGR1ZSB0byBhIHRva2VuIGVycm9yIChzb1xuXHRcdCAqICAgdGhpcy5lcnJvclJlYXNvbiB3aWxsIGJlIHNldCwgYW5kIHN0YXJ0Q29ubmVjdCB3aWxsIGRvIGEgZm9yY2VkXG5cdFx0ICogICBhdXRob3JpemUpLiBJZiB0aGlzLmVycm9yUmVhc29uIGlzIGFscmVhZHkgc2V0ICh0byBhIHRva2VuIGVycm9yKSxcblx0XHQgKiAgIHRoZW4gdGhlcmUgaGFzIGJlZW4gYXQgbGVhc3Qgb25lIHByZXZpb3VzIGF0dGVtcHQgdG8gY29ubmVjdCB0aGF0IGFsc29cblx0XHQgKiAgIGZhaWxlZCBmb3IgYSB0b2tlbiBlcnJvciwgc28gYnkgUlROMTRiIHdlIGdvIHRvIERJU0NPTk5FQ1RFRCBhbmQgd2FpdFxuXHRcdCAqICAgYmVmb3JlIHRyeWluZyBhZ2FpbiAqL1xuXHRcdHZhciByZXRyeUltbWVkaWF0ZWx5ID0gKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJlxuXHRcdFx0KHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAgICAgfHxcblx0XHRcdCB0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nIHx8XG5cdFx0XHQgaW5kaWNhdGVkLnJldHJ5SW1tZWRpYXRlbHkgICAgICAgICAgICAgICB8fFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJlxuXHRcdFx0XHRcdGluZGljYXRlZC5lcnJvciAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihpbmRpY2F0ZWQuZXJyb3IpICYmXG5cdFx0XHRcdFx0ISh0aGlzLmVycm9yUmVhc29uICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSkpKTtcblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ25ldyBzdGF0ZTogJyArIHN0YXRlICsgKHJldHJ5SW1tZWRpYXRlbHkgPyAnOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHknIDogJycpKTtcblx0XHQvKiBkbyBub3RoaW5nIGlmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIGluZGljYXRlZCBzdGF0ZSAqL1xuXHRcdGlmKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvKiBraWxsIHRpbWVycyAocG9zc2libHkgZXhjZXB0aW5nIHN1c3BlbmQgdGltZXIgZGVwZW5kaW5nIG9uIHRoZSBub3RpZmllZFxuXHRcdCogc3RhdGUpLCBhcyB0aGVzZSBhcmUgc3VwZXJzZWRlZCBieSB0aGlzIG5vdGlmaWNhdGlvbiAqL1xuXHRcdHRoaXMuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCk7XG5cdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG5cdFx0dGhpcy5jaGVja1N1c3BlbmRUaW1lcihpbmRpY2F0ZWQuc3RhdGUpO1xuXG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSB1bmFibGUgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlICovXG5cdFx0aWYodGhpcy5zdGF0ZS50ZXJtaW5hbClcblx0XHRcdHJldHVybjtcblxuXHRcdC8qIHByb2Nlc3MgbmV3IHN0YXRlICovXG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbaW5kaWNhdGVkLnN0YXRlXSxcblx0XHRcdGNoYW5nZSA9IG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBuZXdTdGF0ZS5yZXRyeURlbGF5LCAoaW5kaWNhdGVkLmVycm9yIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bbmV3U3RhdGUuc3RhdGVdKSk7XG5cblx0XHRpZihyZXRyeUltbWVkaWF0ZWx5KSB7XG5cdFx0XHR2YXIgYXV0b1JlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5kaXNjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRzZWxmLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCk7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHZhciBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiAoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICsgMSk7XG5cdFx0XHRpZihzaW5jZUxhc3QgJiYgKHNpbmNlTGFzdCA8IDEwMDApKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0xhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgJyArIHNpbmNlTGFzdCArICdtcyBhZ28sIHdhaXRpbmcgYW5vdGhlciAnICsgKDEwMDAgLSBzaW5jZUxhc3QpICsgJ21zIGJlZm9yZSB0cnlpbmcgYWdhaW4nKTtcblx0XHRcdFx0c2V0VGltZW91dChhdXRvUmVjb25uZWN0LCAxMDAwIC0gc2luY2VMYXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soYXV0b1JlY29ubmVjdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdHRoaXMuc3RhcnRSZXRyeVRpbWVyKG5ld1N0YXRlLnJldHJ5RGVsYXkpO1xuXHRcdH1cblxuXHRcdCAvKiBJZiBnb2luZyBpbnRvIGRpc2Nvbm5lY3Qvc3VzcGVuZGVkIChhbmQgbm90IHJldHJ5aW5nIGltbWVkaWF0ZWx5KSwgb3IgYVxuXHRcdFx0KiB0ZXJtaW5hbCBzdGF0ZSwgZW5zdXJlIHRoZXJlIGFyZSBubyBvcnBoYW5lZCB0cmFuc3BvcnRzIGhhbmdpbmcgYXJvdW5kLiAqL1xuXHRcdGlmKChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgIXJldHJ5SW1tZWRpYXRlbHkpIHx8XG5cdFx0XHQgKHN0YXRlID09PSAnc3VzcGVuZGVkJykgfHxcblx0XHRcdCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xuXHRcdFx0XHQgLyogV2FpdCB0aWxsIHRoZSBuZXh0IHRpY2sgc28gdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlIGlzIGVuYWN0ZWQsXG5cdFx0XHRcdCAqIHNvIGFib3J0aW5nIHRyYW5zcG9ydHMgZG9lc24ndCB0cmlnZ2VyIHJlZHVuZGFudCBzdGF0ZSBjaGFuZ2VzICovXG5cdFx0XHRcdCBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCBzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdCB9KTtcblx0XHQgfVxuXG5cdFx0aWYoc3RhdGUgPT0gJ2Nvbm5lY3RlZCcgJiYgIXRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0Jyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbCcpO1xuXHRcdH1cblxuXHRcdC8qIGltcGxlbWVudCB0aGUgY2hhbmdlIGFuZCBub3RpZnkgKi9cblx0XHR0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcblx0XHRpZih0aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcblx0XHRcdHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG5cdFx0fSBlbHNlIGlmKCF0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24oc3RhdGUsIGNoYW5nZS5yZWFzb24pO1xuXHRcdFx0dGhpcy5mYWlsUXVldWVkTWVzc2FnZXMoY2hhbmdlLnJlYXNvbik7IC8vIFJUTjdjXG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG5cdFx0dmFyIHN0YXRlID0gcmVxdWVzdC5zdGF0ZSwgc2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpJywgJ3JlcXVlc3RlZCBzdGF0ZTogJyArIHN0YXRlICsgJzsgY3VycmVudCBzdGF0ZTogJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xuXHRcdGlmKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG5cdFx0XHRyZXR1cm47IC8qIHNpbGVudGx5IGRvIG5vdGhpbmcgKi9cblxuXHRcdC8qIGtpbGwgcnVubmluZyB0aW1lcnMsIGFzIHRoaXMgcmVxdWVzdCBzdXBlcnNlZGVzIHRoZW0gKi9cblx0XHR0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuXHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuXHRcdC8qIGZvciBzdXNwZW5kIHRpbWVyIGNoZWNrIHJhdGhlciB0aGFuIGNhbmNlbCAtLSBlZyByZXF1ZXN0aW5nIGEgY29ubmVjdGluZ1xuXHRcdCogc3RhdGUgc2hvdWxkIG5vdCByZXNldCB0aGUgc3VzcGVuZCB0aW1lciAqL1xuXHRcdHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpO1xuXG5cdFx0aWYoc3RhdGUgPT0gJ2Nvbm5lY3RpbmcnICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gJ2Nvbm5lY3RlZCcpIHJldHVybjtcblx0XHRpZihzdGF0ZSA9PSAnY2xvc2luZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY2xvc2VkJykgcmV0dXJuO1xuXG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZXNbc3RhdGVdLFxuXHRcdFx0Y2hhbmdlID0gbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0odGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIG51bGwsIChyZXF1ZXN0LmVycm9yIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bbmV3U3RhdGUuc3RhdGVdKSk7XG5cblx0XHR0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0aW5nJykge1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHsgc2VsZi5zdGFydENvbm5lY3QoKTsgfSk7XG5cdFx0fVxuXHRcdGlmKHN0YXRlID09ICdjbG9zaW5nJykge1xuXHRcdFx0dGhpcy5jbG9zZUltcGwoKTtcblx0XHR9XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRDb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYXV0aCA9IHRoaXMucmVhbHRpbWUuYXV0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0LyogVGhlIHBvaW50IG9mIHRoZSBjb25uZWN0Q291bnRlciBtZWNoYW5pc20gaXMgdG8gZW5zdXJlIHRoYXQgdGhlXG5cdFx0ICogY29ubmVjdGlvbiBwcm9jZWR1cmUgY2FuIGJlIGNhbmNlbGxlZC4gV2Ugd2FudCBkaXNjb25uZWN0QWxsVHJhbnNwb3J0c1xuXHRcdCAqIHRvIGJlIGFibGUgdG8gc3RvcCBhbnkgaW4tcHJvZ3Jlc3MgY29ubmVjdGlvbiwgZXZlbiBiZWZvcmUgaXQgZ2V0cyB0b1xuXHRcdCAqIHRoZSBzdGFnZSBvZiBoYXZpbmcgYSBwZW5kaW5nIChvciBldmVuIGEgcHJvcG9zZWQpIHRyYW5zcG9ydCB0aGF0IGl0IGNhblxuXHRcdCAqIGRpc3Bvc2UoKSBvZi4gU28gd2UgY2hlY2sgdGhhdCBpdCdzIHN0aWxsIGN1cnJlbnQgYWZ0ZXIgYW55IGFzeW5jIHN0YWdlLFxuXHRcdCAqIHVwIHVudGlsIHRoZSBzdGFnZSB0aGF0IGlzIHN5bmNocm9ub3VzIHdpdGggaW5zdGFudGlhdGluZyBhIHRyYW5zcG9ydCAqL1xuXHRcdHZhciBjb25uZWN0Q291bnQgPSArK3RoaXMuY29ubmVjdENvdW50ZXI7XG5cblx0XHR2YXIgY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpO1xuXHRcdFx0c2VsZi5nZXRUcmFuc3BvcnRQYXJhbXMoZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0XHRcdGlmKGNvbm5lY3RDb3VudCAhPT0gc2VsZi5jb25uZWN0Q291bnRlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnc3RhcnRpbmcgY29ubmVjdGlvbicpO1xuXHRcdHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcblx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xuXG5cdFx0aWYoYXV0aC5tZXRob2QgPT09ICdiYXNpYycpIHtcblx0XHRcdGNvbm5lY3QoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGF1dGhDYiA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0c2VsZi5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbm5lY3QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmKHRoaXMuZXJyb3JSZWFzb24gJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpIHtcblx0XHRcdFx0LyogRm9yY2UgYSByZWZldGNoIG9mIGEgbmV3IHRva2VuICovXG5cdFx0XHRcdGF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgYXV0aENiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBhdXRoQ2IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlcmUgYXJlIHRocmVlIHN0YWdlcyBpbiBjb25uZWN0aW5nOlxuXHQgKiAtIHByZWZlcmVuY2U6IGlmIHRoZXJlIGlzIGEgY2FjaGVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlLCB3ZSB0cnkgdG8gY29ubmVjdFxuXHQgKiAgIG9uIHRoYXQuIElmIHRoYXQgZmFpbHMgb3IgdGltZXMgb3V0IHdlIGFib3J0IHRoZSBhdHRlbXB0LCByZW1vdmUgdGhlXG5cdCAqICAgcHJlZmVyZW5jZSBhbmQgZmFsbCBiYWNrIHRvIGJhc2UuIElmIGl0IHN1Y2NlZWRzLCB3ZSB0cnkgdXBncmFkaW5nIGl0IGlmXG5cdCAqICAgbmVlZGVkICh3aWxsIG9ubHkgYmUgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHByZWZlcmVuY2UgaXMgeGhycyBhbmQgdGhlXG5cdCAqICAgYnJvd3NlciBzdXBwb3J0cyB3cykuXG5cdCAqIC0gYmFzZTogd2UgdHJ5IHRvIGNvbm5lY3Qgd2l0aCB0aGUgYmVzdCB0cmFuc3BvcnQgdGhhdCB3ZSB0aGluayB3aWxsXG5cdCAqICAgbmV2ZXIgZmFpbCBmb3IgdGhpcyBicm93c2VyICh1c3VhbGx5IHRoaXMgaXMgeGhyX3BvbGxpbmc7IGZvciB2ZXJ5IG9sZFxuXHQgKiAgIGJyb3dzZXJzIHdpbGwgYmUganNvbnAsIGZvciBub2RlIHdpbGwgYmUgY29tZXQpLiBJZiBpdCBkb2Vzbid0IHdvcmssIHdlXG5cdCAqICAgdHJ5IGZhbGxiYWNrIGhvc3RzLlxuXHQgKiAtIHVwZ3JhZGU6IGdpdmVuIGEgY29ubmVjdGVkIHRyYW5zcG9ydCwgd2Ugc2VlIGlmIHRoZXJlIGFyZSBhbnkgYmV0dGVyXG5cdCAqICAgb25lcywgYW5kIGlmIHNvLCB0cnkgdG8gdXBncmFkZSB0byB0aGVtLlxuXHQgKlxuXHQgKiBjb25uZWN0SW1wbCB3b3JrcyBvdXQgd2hhdCBzdGFnZSB5b3UncmUgYXQgKHdoaWNoIGlzIHB1cmVseSBhIGZ1bmN0aW9uIG9mXG5cdCAqIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgYW5kIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBzdG9yZWQgcHJlZmVyZW5jZXMpLFxuXHQgKiBhbmQgZGlzcGF0Y2hlcyBhY2NvcmRpbmdseS4gQWZ0ZXIgYSB0cmFuc3BvcnQgaGFzIGJlZW4gc2V0IHBlbmRpbmcsXG5cdCAqIHRyeUFUcmFuc3BvcnQgY2FsbHMgY29ubmVjdEltcGwgdG8gc2VlIGlmIHRoZXJlJ3MgYW5vdGhlciBzdGFnZSB0byBiZSBkb25lLlxuXHQgKiAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEltcGwgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuc3RhdGU7XG5cblx0XHRpZihzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5zdGF0ZSAmJiBzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG5cdFx0XHQvKiBPbmx5IGtlZXAgdHJ5aW5nIGFzIGxvbmcgYXMgaW4gdGhlICdjb25uZWN0aW5nJyBzdGF0ZSAob3IgJ2Nvbm5lY3RlZCdcblx0XHRcdCAqIGZvciB1cGdyYWRpbmcpLiBBbnkgb3BlcmF0aW9uIGNhbiBwdXQgdXMgaW50byAnZGlzY29ubmVjdGVkJyB0byBjYW5jZWxcblx0XHRcdCAqIGNvbm5lY3Rpb24gYXR0ZW1wdHMgYW5kIHdhaXQgYmVmb3JlIHJldHJ5aW5nLCBvciAnZmFpbGVkJyB0byBmYWlsLiAqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCknLCAnTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QgKG9yIGNvbm5lY3RlZCB0byB1cGdyYWRlKSwgYnV0IHdhcyAnICsgc3RhdGUpO1xuXHRcdH0gZWxzZSBpZih0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RJbXBsKCknLCAnVHJhbnNwb3J0cyAnICsgdGhpcy5wZW5kaW5nVHJhbnNwb3J0c1swXS50b1N0cmluZygpICsgJyBjdXJyZW50bHkgcGVuZGluZzsgdGFraW5nIG5vIGFjdGlvbicpO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcblx0XHRcdHRoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPiAxICYmIHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpKSB7XG5cdFx0XHR0aGlzLmNvbm5lY3RQcmVmZXJlbmNlKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY29ubmVjdEJhc2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuXHRcdH1cblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdHZhciBwcmVmZXJlbmNlID0gdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCksXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IGZhbHNlO1xuXG5cdFx0aWYoIV91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4odGhpcy50cmFuc3BvcnRzLCBwcmVmZXJlbmNlKSkge1xuXHRcdFx0dGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHR0aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fVxuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnVHJ5aW5nIHRvIGNvbm5lY3Qgd2l0aCBzdG9yZWQgdHJhbnNwb3J0IHByZWZlcmVuY2UgJyArIHByZWZlcmVuY2UpO1xuXG5cdFx0dmFyIHByZWZlcmVuY2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG5cdFx0XHRpZighKHNlbGYuc3RhdGUuc3RhdGUgPT09IHNlbGYuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnU2hvcnRjaXJjdWl0IGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoICcgKyBwcmVmZXJlbmNlICsgJyBmYWlsZWQ7IGNsZWFyaW5nIHByZWZlcmVuY2UgYW5kIHRyeWluZyBmcm9tIHNjcmF0Y2gnKTtcblx0XHRcdFx0LyogQWJvcnQgYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMuIChUaGlzIGFsc28gZGlzY29ubmVjdHMgdGhlIGFjdGl2ZVxuXHRcdFx0XHQgKiBwcm90b2NvbCwgYnV0IG5vbmUgZXhpc3RzIGlmIHdlJ3JlIG5vdCBpbiB0aGUgY29ubmVjdGVkIHN0YXRlKSAqL1xuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdC8qIEJlIHF1aXRlIGFncmVzc2l2ZSBhYm91dCBjbGVhcmluZyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgaWYgZXZlciBpdCBkb2Vzbid0IHdvcmsgKi9cblx0XHRcdFx0c2VsZi51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnByZWZlcmVuY2VDb25uZWN0VGltZW91dCk7XG5cblx0XHQvKiBGb3IgY29ubmVjdFByZWZlcmVuY2UsIGp1c3QgdXNlIHRoZSBtYWluIGhvc3QuIElmIGhvc3QgZmFsbGJhY2sgaXMgbmVlZGVkLCBkbyBpdCBpbiBjb25uZWN0QmFzZS5cblx0XHQgKiBUaGUgd3N0cmFuc3BvcnQgaXQgd2lsbCBzdWJzdGl0dXRlIHRoZSBodHRwaG9zdCBmb3IgYW4gYXBwcm9wcmlhdGUgd3Nob3N0ICovXG5cdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBzZWxmLmh0dHBIb3N0c1swXTtcblx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBwcmVmZXJlbmNlLCBmdW5jdGlvbihmYXRhbCwgdHJhbnNwb3J0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQocHJlZmVyZW5jZVRpbWVvdXQpO1xuXHRcdFx0aWYocHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkICYmIHRyYW5zcG9ydCkge1xuXHRcdFx0XHQvKiBWaWFibGUsIGJ1dCB0b28gbGF0ZSAtIGNvbm5lY3RJbXBsKCkgd2lsbCBhbHJlYWR5IGJlIHRyeWluZ1xuXHRcdFx0XHQqIGNvbm5lY3RCYXNlLCBhbmQgd2Ugd2VyZW4ndCBpbiB1cGdyYWRlIG1vZGUuIEp1c3QgcmVtb3ZlIHRoZVxuXHRcdFx0XHQqIG9uY29ubmVjdGVkIGxpc3RlbmVyIGFuZCBnZXQgcmlkIG9mIGl0ICovXG5cdFx0XHRcdHRyYW5zcG9ydC5vZmYoKTtcblx0XHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fSBlbHNlIGlmKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XG5cdFx0XHRcdC8qIFByZWZlcmVuY2UgZmFpbGVkIGluIGEgdHJhbnNwb3J0LXNwZWNpZmljIHdheS4gVHJ5IG1vcmUgKi9cblx0XHRcdFx0c2VsZi51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdC8qIElmIHN1Y2VlZGVkLCBvciBmYWlsZWQgZmF0YWxseSwgbm90aGluZyB0byBkbyAqL1xuXHRcdH0pO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFRyeSB0byBlc3RhYmxpc2ggYSB0cmFuc3BvcnQgb24gdGhlIGJhc2UgdHJhbnNwb3J0ICh0aGUgYmVzdCB0cmFuc3BvcnRcblx0ICogc3VjaCB0aGF0IGlmIGl0IGRvZXNuJ3Qgd29yaywgbm90aGluZyB3aWxsIHdvcmspIGFzIGRldGVybWluZWQgdGhyb3VnaFxuXHQgKiBzdGF0aWMgZmVhdHVyZSBkZXRlY3Rpb24sIGNoZWNraW5nIGZvciBuZXR3b3JrIGNvbm5lY3Rpdml0eSBhbmQgdHJ5aW5nXG5cdCAqIGZhbGxiYWNrIGhvc3RzIGlmIGFwcGxpY2FibGUuXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0QmFzZSA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0Z2l2ZVVwID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiBzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVycn0pO1xuXHRcdFx0fSxcblx0XHRcdGNhbmRpZGF0ZUhvc3RzID0gdGhpcy5odHRwSG9zdHMuc2xpY2UoKSxcblx0XHRcdGhvc3RBdHRlbXB0Q2IgPSBmdW5jdGlvbihmYXRhbCwgdHJhbnNwb3J0KSB7XG5cdFx0XHRcdGlmKGNvbm5lY3RDb3VudCAhPT0gc2VsZi5jb25uZWN0Q291bnRlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuXHRcdFx0XHRcdHRyeUZhbGxiYWNrSG9zdHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggYmFzZSB0cmFuc3BvcnQgJyArIHRoaXMuYmFzZVRyYW5zcG9ydCk7XG5cblx0XHQvKiBmaXJzdCB0cnkgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwcmlvcml0eSBob3N0IHdpdGggaHR0cCB0cmFuc3BvcnQgKi9cblx0XHR2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG5cdFx0aWYoIWhvc3QpIHtcblx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKG5vIGF2YWlsYWJsZSBob3N0KScsIDgwMDAzLCA0MDQpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBob3N0O1xuXG5cdFx0LyogdGhpcyBpcyB3aGF0IHdlJ2xsIGJlIGRvaW5nIGlmIHRoZSBhdHRlbXB0IGZvciB0aGUgbWFpbiBob3N0IGZhaWxzICovXG5cdFx0ZnVuY3Rpb24gdHJ5RmFsbGJhY2tIb3N0cygpIHtcblx0XHRcdC8qIGlmIHRoZXJlIGFyZW4ndCBhbnkgZmFsbGJhY2sgaG9zdHMsIGZhaWwgKi9cblx0XHRcdGlmKCFjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcblx0XHRcdFx0Z2l2ZVVwKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gY29ubmVjdCAoYW5kIG5vIG1vcmUgZmFsbGJhY2sgaG9zdHMgdG8gdHJ5KScsIDgwMDAzLCA0MDQpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogYmVmb3JlIHRyeWluZyBhbnkgZmFsbGJhY2sgKG9yIGFueSByZW1haW5pbmcgZmFsbGJhY2spIHdlIGRlY2lkZSBpZlxuXHRcdFx0ICogdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGFibHkgaG9zdCwgb3IgdGhlcmUgaXMgYSBnZW5lcmFsIGNvbm5lY3Rpdml0eVxuXHRcdFx0ICogcHJvYmxlbSAqL1xuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVja0Nvbm5lY3Rpdml0eShmdW5jdGlvbihlcnIsIGNvbm5lY3Rpdml0eSkge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Lyogd2Uga25vdyBlcnIgd29uJ3QgaGFwcGVuIGJ1dCBoYW5kbGUgaXQgaGVyZSBhbnl3YXkgKi9cblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Z2l2ZVVwKGVycik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFjb25uZWN0aXZpdHkpIHtcblx0XHRcdFx0XHQvKiB0aGUgaW50ZXJuZXQgaXNuJ3QgcmVhY2hhYmxlLCBzbyBkb24ndCB0cnkgdGhlIGZhbGxiYWNrIGhvc3RzICovXG5cdFx0XHRcdFx0Z2l2ZVVwKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gY29ubmVjdCAobmV0d29yayB1bnJlYWNoYWJsZSknLCA4MDAwMywgNDA0KSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIHRoZSBuZXR3b3JrIGlzIHRoZXJlLCBzbyB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBtYWluIGhvc3QsIG9yXG5cdFx0XHRcdCAqIGl0cyBkbnMuIFRyeSB0aGUgZmFsbGJhY2sgaG9zdHMuIFdlIGNvdWxkIHRyeSB0aGVtIHNpbXVsdGFuZW91c2x5IGJ1dFxuXHRcdFx0XHQgKiB0aGF0IHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGEgaHVnZSBzcGlrZSBpbiBsb2FkIG9uIHRoZSBsb2FkIGJhbGFuY2VyICovXG5cdFx0XHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJQb3BSYW5kb21FbGVtZW50KGNhbmRpZGF0ZUhvc3RzKTtcblx0XHRcdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgc2VsZi5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG5cdFx0XHR0cnlGYWxsYmFja0hvc3RzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdGhpcy5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRVcGdyYWRlUG9zc2liaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qIHJldHVybnMgdGhlIHN1YnNldCBvZiB1cGdyYWRlVHJhbnNwb3J0cyB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcblx0XHQgKiB0cmFuc3BvcnQgaW4gdXBncmFkZVRyYW5zcG9ydHMgKGlmIGl0J3MgaW4gdGhlcmUgLSBpZiBub3QsIGN1cnJlbnRQb3NpdGlvblxuXHRcdCAqIHdpbGwgYmUgLTEsIHNvIHJldHVybiB1cGdyYWRlVHJhbnNwb3J0cy5zbGljZSgwKSA9PSB1cGdyYWRlVHJhbnNwb3J0cyAqL1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5zaG9ydE5hbWU7XG5cdFx0dmFyIGN1cnJlbnRQb3NpdGlvbiA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZih0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLCBjdXJyZW50KTtcblx0XHRyZXR1cm4gdGhpcy51cGdyYWRlVHJhbnNwb3J0cy5zbGljZShjdXJyZW50UG9zaXRpb24gKyAxKTtcblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGdyYWRlSWZOZWVkZWQgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgdXBncmFkZVBvc3NpYmlsaXRpZXMgPSB0aGlzLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCksXG5cdFx0XHRzZWxmID0gdGhpcztcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudXBncmFkZUlmTmVlZGVkKCknLCAndXBncmFkZSBwb3NzaWJpbGl0aWVzOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KHVwZ3JhZGVQb3NzaWJpbGl0aWVzKSk7XG5cblx0XHRpZighdXBncmFkZVBvc3NpYmlsaXRpZXMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKHVwZ3JhZGVQb3NzaWJpbGl0aWVzLCBmdW5jdGlvbih1cGdyYWRlVHJhbnNwb3J0KSB7XG5cdFx0XHQvKiBOb3RlOiB0aGUgdHJhbnNwb3J0IG1heSBtdXRhdGUgdGhlIHBhcmFtcywgc28gZ2l2ZSBlYWNoIHRyYW5zcG9ydCBhIGZyZXNoIG9uZSAqL1xuXHRcdFx0dmFyIHVwZ3JhZGVUcmFuc3BvcnRQYXJhbXMgPSBzZWxmLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyh0cmFuc3BvcnRQYXJhbXMuaG9zdCwgJ3VwZ3JhZGUnKTtcblx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh1cGdyYWRlVHJhbnNwb3J0UGFyYW1zLCB1cGdyYWRlVHJhbnNwb3J0LCBub29wKTtcblx0XHR9KTtcblx0fTtcblxuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZUltcGwgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnY2xvc2luZyBjb25uZWN0aW9uJyk7XG5cdFx0dGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcblx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNsb3NpbmcpO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcblx0XHRcdGlmKHRyYW5zcG9ydCkgdHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0fSk7XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcblx0XHRcdGlmKHRyYW5zcG9ydCkgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcblx0XHR9KTtcblxuXHRcdGlmKHRoaXMuYWN0aXZlUHJvdG9jb2wpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdDbG9zaW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcblx0XHR9XG5cblx0XHQvKiBJZiB0aGVyZSB3YXMgYW4gYWN0aXZlIHRyYW5zcG9ydCwgdGhpcyB3aWxsIHByb2JhYmx5IGJlXG5cdFx0ICogcHJlZW1wdGVkIGJ5IHRoZSBub3RpZnlTdGF0ZSBjYWxsIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cblx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2Nsb3NlZCd9KTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydCcpO1xuXHRcdFx0XHQvKiBJZiB0aGVyZSBhcmUgYW55IHByb3Bvc2VkL3BlbmRpbmcgdHJhbnNwb3J0cyAoZWcgYW4gdXBncmFkZSB0aGF0XG5cdFx0XHRcdCAqIGlzbid0IHlldCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24pIHRoYXQgaGFzbid0IHlldCBzdGFydGVkIHN5bmNpbmcsXG5cdFx0XHRcdCAqIGp1c3QgdG8gZ2V0IHJpZCBvZiB0aGVtICYgcmVzdGFydCB0aGUgdXBncmFkZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRvXG5cdFx0XHRcdCAqIGF2b2lkIGEgcmFjZSBjb25kaXRpb24uIChJZiBpdCBoYXMgc3RhcnRlZCBzeW5jaW5nLCB0aGUgQVVUSCB3aWxsIGJlXG5cdFx0XHRcdCAqIHF1ZXVlZCB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZSwgc28gZXZlcnl0aGluZydzIGZpbmUpICovXG5cdFx0XHRcdGlmKCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCB8fCB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5sZW5ndGgpICYmXG5cdFx0XHRcdFx0c2VsZi5zdGF0ZSAhPT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZykge1xuXHRcdFx0XHRcdHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoLyogZXhjZXB0QWN0aXZlOiAqL3RydWUpO1xuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnBhcmFtcztcblx0XHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi51cGdyYWRlSWZOZWVkZWQodHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIERvIGFueSB0cmFuc3BvcnQtc3BlY2lmaWMgbmV3LXRva2VuIGFjdGlvbiAqL1xuXHRcdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcblxuXHRcdFx0XHR2YXIgYXV0aE1zZyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRcdFx0XHRhY3Rpb246IGFjdGlvbnMuQVVUSCxcblx0XHRcdFx0XHRhdXRoOiB7XG5cdFx0XHRcdFx0XHRhY2Nlc3NUb2tlbjogdG9rZW5EZXRhaWxzLnRva2VuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5zZW5kKGF1dGhNc2cpO1xuXG5cdFx0XHRcdC8qIFRoZSBhbnN3ZXIgd2lsbCBjb21lIGJhY2sgYXMgZWl0aGVyIGEgY29ubmVjdGlvbmRldGFpbHMgZXZlbnRcblx0XHRcdFx0ICogKHJlYWx0aW1lIHNlbmRzIGEgQ09OTkVDVEVEIHRvIGFza25vd2xlZGdlIHRoZSByZWF1dGgpIG9yIGFcblx0XHRcdFx0ICogc3RhdGVjaGFuZ2UgdG8gZmFpbGVkICovXG5cdFx0XHRcdHZhciBzdWNjZXNzTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZihmYWlsdXJlTGlzdGVuZXIpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBmYWlsdXJlTGlzdGVuZXIgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0XHRcdGlmKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRcdFx0XHRzZWxmLm9mZihzdWNjZXNzTGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0c2VsZi5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBzZWxmLmdldFN0YXRlRXJyb3IoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLm9uY2UoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgc3VjY2Vzc0xpc3RlbmVyKTtcblx0XHRcdFx0dGhpcy5vbignY29ubmVjdGlvbnN0YXRlJywgZmFpbHVyZUxpc3RlbmVyKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2Nvbm5lY3RpbmcnOlxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJyxcblx0XHRcdFx0XHQnQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHMnKTtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQvKiBmYWxsdGhyb3VnaCB0byBhZGQgc3RhdGVjaGFuZ2UgbGlzdGVuZXIgKi9cblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsXG5cdFx0XHRcdFx0J0Nvbm5lY3Rpb24gc3RhdGUgaXMgJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAnOyB3YWl0aW5nIHVudGlsIGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkJyk7XG5cdFx0XHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0c3dpdGNoKHN0YXRlQ2hhbmdlLmN1cnJlbnQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XG5cdFx0XHRcdFx0XHRcdHNlbGYub2ZmKGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnY2xvc2VkJzpcblx0XHRcdFx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdFx0XHRcdHNlbGYub2ZmKGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IHNlbGYuZ2V0U3RhdGVFcnJvcigpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQvKiBpZ25vcmUgdGlsbCB3ZSBnZXQgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQgKi9cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzZWxmLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBsaXN0ZW5lcik7XG5cdFx0XHRcdGlmKHRoaXMuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuXHRcdFx0XHRcdC8qIGNhbiBoYXBwZW4gaWYgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgYnV0IG5vIHRyYW5zcG9ydCB3YXMgcGVuZGluZ1xuXHRcdFx0XHRcdCAqIHlldCwgc28gZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgZGlkIG5vdCB0cmlnZ2VyIGEgZGlzY29ubmVjdGVkIHN0YXRlICovXG5cdFx0XHRcdFx0c2VsZi5zdGFydENvbm5lY3QoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cyA9IGZ1bmN0aW9uKGV4Y2VwdEFjdGl2ZSkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHMnICsgKGV4Y2VwdEFjdGl2ZSA/ICcgZXhjZXB0IHRoZSBhY3RpdmUgdHJhbnNwb3J0JyA6ICcnKSk7XG5cblx0XHQvKiBUaGlzIHdpbGwgcHJldmVudCBhbnkgY29ubmVjdGlvbiBwcm9jZWR1cmUgaW4gYW4gYXN5bmMgcGFydCBvZiBvbmUgb2YgaXRzIGVhcmx5IHN0YWdlcyBmcm9tIGNvbnRpbnVpbmcgKi9cblx0XHR0aGlzLmNvbm5lY3RDb3VudGVyKys7XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcblx0XHRcdGlmKHRyYW5zcG9ydCkgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcblx0XHR9KTtcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuXG5cdFx0aWYodGhpcy5hY3RpdmVQcm90b2NvbCAmJiAhZXhjZXB0QWN0aXZlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuXHRcdH1cblx0XHQvKiBObyBuZWVkIHRvIG5vdGlmeSBzdGF0ZSBkaXNjb25uZWN0ZWQ7IGRpc2Nvbm5lY3RpbmcgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcblx0XHQgKiB3aWxsIGhhdmUgdGhhdCBlZmZlY3QgKi9cblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqXG5cdCAqIGV2ZW50IHF1ZXVlaW5nXG5cdCAqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2csIHF1ZXVlRXZlbnQsIGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cblx0XHRpZihzdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgJ3NlbmRpbmcgZXZlbnQnKTtcblx0XHRcdHRoaXMuc2VuZEltcGwobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHNob3VsZFF1ZXVlID0gKHF1ZXVlRXZlbnQgJiYgc3RhdGUucXVldWVFdmVudHMpIHx8IHN0YXRlLmZvcmNlUXVldWVFdmVudHM7XG5cdFx0aWYoIXNob3VsZFF1ZXVlKSB7XG5cdFx0XHR2YXIgZXJyID0gJ3JlamVjdGluZyBldmVudCwgcXVldWVFdmVudCB3YXMgJyArIHF1ZXVlRXZlbnQgKyAnLCBzdGF0ZSB3YXMgJyArIHN0YXRlLnN0YXRlO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsIGVycik7XG5cdFx0XHRjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKGVyciwgOTAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zaG91bGRMb2coX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPKSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdxdWV1ZWluZyBtc2c7ICcgKyBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5naWZ5KG1zZykpO1xuXHRcdH1cblx0XHR0aGlzLnF1ZXVlKG1zZywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kSW1wbCA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlKSB7XG5cdFx0dmFyIG1zZyA9IHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2U7XG5cdFx0LyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIHRoaXMsIHJlc2VuZCB3aXRoIHRoZSBzYW1lIG1zZ1NlcmlhbCxcblx0XHQgKiBzbyBBYmx5IGNhbiBkZWR1cCBpZiB0aGUgcHJldmlvdXMgc2VuZCBzdWNjZWVkZWQgKi9cblx0XHRpZihwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuXHRcdFx0bXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG5cdFx0XHR0aGlzLnNldFJlY292ZXJ5S2V5KCk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRJbXBsKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaW4gdHJhbnNwb3J0LnNlbmQoKTogJyArIGUuc3RhY2spO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBidW5kbGVXaXRoKGRlc3QsIHNyYywgbWF4U2l6ZSkge1xuXHRcdHZhciBhY3Rpb247XG5cdFx0aWYoZGVzdC5jaGFubmVsICE9PSBzcmMuY2hhbm5lbCkge1xuXHRcdFx0LyogUlRMNmQzICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKChhY3Rpb24gPSBkZXN0LmFjdGlvbikgIT09IGFjdGlvbnMuUFJFU0VOQ0UgJiYgYWN0aW9uICE9PSBhY3Rpb25zLk1FU1NBR0UpIHtcblx0XHRcdC8qIFJUTDZkIC0gY2FuIG9ubHkgYnVuZGxlIG1lc3NhZ2VzIG9yIHByZXNlbmNlICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKGFjdGlvbiAhPT0gc3JjLmFjdGlvbikge1xuXHRcdFx0LyogUlRMNmQ0ICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBraW5kID0gKGFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSkgPyAncHJlc2VuY2UnIDogJ21lc3NhZ2VzJyxcblx0XHRcdHByb3Bvc2VkID0gZGVzdFtraW5kXS5jb25jYXQoc3JjW2tpbmRdKSxcblx0XHRcdHNpemUgPSBfdHlwZXNfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRNZXNzYWdlc1NpemUocHJvcG9zZWQpO1xuXHRcdGlmKHNpemUgPiBtYXhTaXplKSB7XG5cdFx0XHQvKiBSVEw2ZDEgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYoIV91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWxsU2FtZShwcm9wb3NlZCwgJ2NsaWVudElkJykpIHtcblx0XHRcdC8qIFJUTDZkMiAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZighX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJFdmVyeShwcm9wb3NlZCwgZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRyZXR1cm4gIW1zZy5pZDtcblx0XHR9KSkge1xuXHRcdFx0LyogUlRMNmQ3ICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8qIHdlJ3JlIGdvb2QgdG8gZ28hICovXG5cdFx0ZGVzdFtraW5kXSA9IHByb3Bvc2VkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uKG1zZywgY2FsbGJhY2spIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKScsICdxdWV1ZWluZyBldmVudCcpO1xuXHRcdHZhciBsYXN0UXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5sYXN0KCk7XG5cdFx0dmFyIG1heFNpemUgPSB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG5cdFx0LyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIGEgbWVzc2FnZSwgZG9uJ3QgbWVyZ2UgbW9yZSBtZXNzYWdlc1xuXHRcdCAqIGludG8gaXQsIGFzIGlmIHRoZSBwcmV2aW91cyBzZW5kIGFjdHVhbGx5IHN1Y2NlZWRlZCBhbmQgcmVhbHRpbWUgaWdub3Jlc1xuXHRcdCAqIHRoZSBkdXAsIHRoZXknbGwgYmUgbG9zdCAqL1xuXHRcdGlmKGxhc3RRdWV1ZWQgJiYgIWxhc3RRdWV1ZWQuc2VuZEF0dGVtcHRlZCAmJiBidW5kbGVXaXRoKGxhc3RRdWV1ZWQubWVzc2FnZSwgbXNnLCBtYXhTaXplKSkge1xuXHRcdFx0aWYoIWxhc3RRdWV1ZWQubWVyZ2VkKSB7XG5cdFx0XHRcdGxhc3RRdWV1ZWQuY2FsbGJhY2sgPSBPYmplY3QoX3V0aWxfbXVsdGljYXN0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKFtsYXN0UXVldWVkLmNhbGxiYWNrXSk7XG5cdFx0XHRcdGxhc3RRdWV1ZWQubWVyZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGxhc3RRdWV1ZWQuY2FsbGJhY2sucHVzaChjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucXVldWVkTWVzc2FnZXMucHVzaChuZXcgUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRRdWV1ZWRNZXNzYWdlcygpJywgJ3NlbmRpbmcgJyArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArICcgcXVldWVkIG1lc3NhZ2VzJyk7XG5cdFx0dmFyIHBlbmRpbmdNZXNzYWdlO1xuXHRcdHdoaWxlKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKVxuXHRcdFx0dGhpcy5zZW5kSW1wbChwZW5kaW5nTWVzc2FnZSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnF1ZXVlUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24ocGVuZGluZ01lc3NhZ2VzKSB7XG5cdFx0aWYocGVuZGluZ01lc3NhZ2VzICYmIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGgpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpJywgJ3F1ZXVlaW5nICcgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLnByZXBlbmQocGVuZGluZ01lc3NhZ2VzKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmZhaWxRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uKGVycikge1xuXHRcdHZhciBudW1RdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCk7XG5cdFx0aWYobnVtUXVldWVkID4gMCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmZhaWxRdWV1ZWRNZXNzYWdlcygpJywgJ2ZhaWxpbmcgJyArIG51bVF1ZXVlZCArICcgcXVldWVkIG1lc3NhZ2VzLCBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCB0cmFuc3BvcnQpIHtcblx0XHR2YXIgb25BY3RpdmVUcmFuc3BvcnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sICYmIHRyYW5zcG9ydCA9PT0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSxcblx0XHRcdG9uVXBncmFkZVRyYW5zcG9ydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4odGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSAmJiB0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcsXG5cdFx0XHRub3RDb250cm9sTXNnID0gbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fCBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRTtcblxuXHRcdC8qIEFzIHRoZSBsaWIgbm93IGhhcyBhIHBlcmlvZCB3aGVyZSB0aGUgdXBncmFkZSB0cmFuc3BvcnQgaXMgc3luY2VkIGJ1dFxuXHRcdCAqIGJlZm9yZSBpdCdzIGJlY29tZSBhY3RpdmUgKHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBvbGQgb25lIHRvIGJlY29tZVxuXHRcdCAqIGlkbGUpLCBtZXNzYWdlIGNhbiB2YWxpZGx5IGFycml2ZSBvbiBpdCBldmVuIHRob3VnaCBpdCBpc24ndCBhY3RpdmUgKi9cblx0XHRpZihvbkFjdGl2ZVRyYW5zcG9ydCB8fCBvblVwZ3JhZGVUcmFuc3BvcnQpIHtcblx0XHRcdGlmKG5vdENvbnRyb2xNc2cpIHtcblx0XHRcdFx0dmFyIHN1cHByZXNzZWQgPSB0aGlzLnNldENvbm5lY3Rpb25TZXJpYWwobWVzc2FnZSk7XG5cdFx0XHRcdGlmKHN1cHByZXNzZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRHVwbGljYXRlKG1lc3NhZ2UsIHRoaXMubW9zdFJlY2VudE1zZykpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG1lc3NhZ2Ugd2l0aCBkaWZmZXJlbnQgY29ubmVjdGlvblNlcmlhbCwgYnV0IHNhbWUgbWVzc2FnZSBpZCBhcyBhIHByZXZpb3VzOyBkaXNjYXJkaW5nOyBpZCA9ICcgKyBtZXNzYWdlLmlkKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5tb3N0UmVjZW50TXNnID0gbWVzc2FnZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gTWVzc2FnZSBjYW1lIGluIG9uIGEgZGVmdW5jdCB0cmFuc3BvcnQuIEFsbG93IG9ubHkgYWNrcywgbmFja3MsICYgZXJyb3JzIGZvciBvdXRzdGFuZGluZ1xuXHRcdFx0Ly8gbWVzc2FnZXMsICBubyBuZXcgbWVzc2FnZXMgKGFzIHN5bmMgaGFzIGJlZW4gc2VudCBvbiBuZXcgdHJhbnNwb3J0IHNvIG5ldyBtZXNzYWdlcyB3aWxsXG5cdFx0XHQvLyBiZSByZXNlbnQgdGhlcmUsIG9yIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIHNvIGRvbid0IHdhbnQgbmV3IG1lc3NhZ2VzKVxuXHRcdFx0aWYoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKFthY3Rpb25zLkFDSywgYWN0aW9ucy5OQUNLLCBhY3Rpb25zLkVSUk9SXSwgbWVzc2FnZS5hY3Rpb24pID4gLTEpIHtcblx0XHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBtZXNzYWdlICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSArICdvbiBkZWZ1bmN0IHRyYW5zcG9ydDsgZGlzY2FyZGluZycpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcblx0XHQvKiBpZiB0cmFuc3BvcnQgaXMgc3BlY2lmaWVkLCB0cnkgdGhhdCAqL1xuXHRcdGlmKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnBpbmcoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcblxuXHRcdFx0dmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dHJhbnNwb3J0Lm9mZignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVGltZW91dCB3YWl0aW5nIGZvciBoZWFydGJlYXQgcmVzcG9uc2UnLCA1MDAwMCwgNTAwKSk7XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcGluZ1N0YXJ0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSxcblx0XHRcdFx0aWQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWFwUmFuZFN0cigpO1xuXG5cdFx0XHR2YXIgb25IZWFydGJlYXQgPSBmdW5jdGlvbiAocmVzcG9uc2VJZCkge1xuXHRcdFx0XHRpZihyZXNwb25zZUlkID09PSBpZCkge1xuXHRcdFx0XHRcdHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0XHRcdHZhciByZXNwb25zZVRpbWUgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gcGluZ1N0YXJ0O1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlVGltZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHZhciB0aW1lciA9IHNldFRpbWVvdXQob25UaW1lb3V0LCB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG5cblx0XHRcdHRyYW5zcG9ydC5vbignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xuXHRcdFx0dHJhbnNwb3J0LnBpbmcoaWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIGRvbid0IGF0dGVtcHQgKi9cblx0XHRpZih0aGlzLnN0YXRlLnN0YXRlICE9PSAnY29ubmVjdGVkJykge1xuXHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBwaW5nIHNlcnZpY2U7IG5vdCBjb25uZWN0ZWQnLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Lyogbm8gdHJhbnNwb3J0IHdhcyBzcGVjaWZpZWQsIHNvIHVzZSB0aGUgY3VycmVudCAoY29ubmVjdGVkKSBvbmVcblx0XHQgKiBidXQgZW5zdXJlIHRoYXQgd2UgcmV0cnkgaWYgdGhlIHRyYW5zcG9ydCBpcyBzdXBlcnNlZGVkIGJlZm9yZSB3ZSBjb21wbGV0ZSAqL1xuXHRcdHZhciBjb21wbGV0ZWQgPSBmYWxzZSwgc2VsZiA9IHRoaXM7XG5cblx0XHR2YXIgb25QaW5nQ29tcGxldGUgPSBmdW5jdGlvbihlcnIsIHJlc3BvbnNlVGltZSkge1xuXHRcdFx0c2VsZi5vZmYoJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG5cdFx0XHRpZighY29tcGxldGVkKSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgcmVzcG9uc2VUaW1lKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIG9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighY29tcGxldGVkKSB7XG5cdFx0XHRcdC8qIGVuc3VyZSB0aGF0IG5vIGNhbGxiYWNrIGhhcHBlbnMgZm9yIHRoZSBjdXJyZW50bHkgb3V0c3RhbmRpbmcgb3BlcmF0aW9uICovXG5cdFx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdC8qIHJlcGVhdCBidXQgcGlja2luZyB1cCB0aGUgbmV3IHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYucGluZyhudWxsLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuXHRcdHRoaXMucGluZyh0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblBpbmdDb21wbGV0ZSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmZhaWwoZXJyb3IpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCAoaGF2ZVdlYlN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXQodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRpZihfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXBncmFkZVRyYW5zcG9ydHMsIHRyYW5zcG9ydC5zaG9ydE5hbWUpKSB7XG5cdFx0XHR0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSB0cmFuc3BvcnQuc2hvcnROYW1lO1xuXHRcdFx0aWYoaGF2ZVdlYlN0b3JhZ2UpIHtcblx0XHRcdFx0cGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zZXQodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUsIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XG5cdFx0aWYoaGF2ZVdlYlN0b3JhZ2UpIHtcblx0XHRcdHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVtb3ZlKHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKTtcblx0XHR9XG5cdH07XG5cblx0LyogVGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGR1cmluZyBjb25uZWN0aW9uIGF0dGVtcHRzLCBzbyBpbXBsZW1lbnRzIFJTQTRjMSxcblx0ICogUlNBNGMyLCBhbmQgUlNBNGQuIEluIHBhcnRpY3VsYXIgaXQgaXMgbm90IGludm9rZWQgZm9yXG5cdCAqIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsIHJlYXV0aHMsIHNvIFJTQTRjMyBkb2VzIG5vdCBhcHBseSAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0T25FcnJvckZyb21BdXRob3JpemUgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRpZihlcnIuY29kZSA9PT0gNDAxNzEpIHtcblx0XHRcdC8qIE5vIHdheSB0byByZWF1dGggKi9cblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IGVycn0pO1xuXHRcdH0gZWxzZSBpZihlcnIuc3RhdHVzQ29kZSA9PT0gNDAzKSB7XG5cdFx0XHR2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvbic7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoKScsIG1zZyk7XG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDE5LCA0MDMsIGVycil9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG1zZyA9ICdDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXF1ZXN0IGZhaWxlZCc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUnLCBtc2cpO1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAxOSwgNDAxLCBlcnIpfSk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlID0gZnVuY3Rpb24oY29ubmVjdGlvbkRldGFpbHMsIHRyYW5zcG9ydCkge1xuXHRcdGlmKCFjb25uZWN0aW9uRGV0YWlscykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG5cdFx0aWYoY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemUpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplO1xuXHRcdH1cblx0XHR2YXIgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcblx0XHRpZihjbGllbnRJZCkge1xuXHRcdFx0dmFyIGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKCknLCBlcnIubWVzc2FnZSk7XG5cdFx0XHRcdC8qIEVycm9ycyBzZXR0aW5nIHRoZSBjbGllbnRJZCBhcmUgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0dHJhbnNwb3J0LmZhaWwoZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuXHRcdGlmKGNvbm5lY3Rpb25TdGF0ZVR0bCkge1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XG5cdFx0fVxuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbmRldGFpbHMnLCBjb25uZWN0aW9uRGV0YWlscyk7XG5cdH07XG5cblx0cmV0dXJuIENvbm5lY3Rpb25NYW5hZ2VyO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25uZWN0aW9uTWFuYWdlcik7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cblxudmFyIE1lc3NhZ2VRdWV1ZSA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gTWVzc2FnZVF1ZXVlKCkge1xuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IFtdO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoTWVzc2FnZVF1ZXVlLCBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzW3RoaXMubWVzc2FnZXMubGVuZ3RoIC0gMV07XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3B5QWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcy5wdXNoLmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdHRoaXMubWVzc2FnZXMudW5zaGlmdC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZU1lc3NhZ2VzID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcblx0XHRlcnIgPSBlcnIgfHwgbnVsbDtcblx0XHR2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuXHRcdHZhciBmaXJzdCA9IG1lc3NhZ2VzWzBdO1xuXHRcdGlmKGZpcnN0KSB7XG5cdFx0XHR2YXIgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcblx0XHRcdHZhciBlbmRTZXJpYWwgPSBzZXJpYWwgKyBjb3VudDsgLyogdGhlIHNlcmlhbCBvZiB0aGUgZmlyc3QgbWVzc2FnZSB0aGF0IGlzICpub3QqIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2FsbCAqL1xuXHRcdFx0aWYoZW5kU2VyaWFsID4gc3RhcnRTZXJpYWwpIHtcblx0XHRcdFx0dmFyIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgKGVuZFNlcmlhbCAtIHN0YXJ0U2VyaWFsKSk7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb21wbGV0ZU1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29tcGxldGVNZXNzYWdlc1tpXS5jYWxsYmFjayhlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihtZXNzYWdlcy5sZW5ndGggPT0gMClcblx0XHRcdFx0dGhpcy5lbWl0KCdpZGxlJyk7XG5cdFx0fVxuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVBbGxNZXNzYWdlcyA9IGZ1bmN0aW9uKGVycikge1xuXHRcdHRoaXMuY29tcGxldGVNZXNzYWdlcygwLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBOdW1iZXIuTUFYX1ZBTFVFLCBlcnIpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNsZWFyKCknLCAnY2xlYXJpbmcgJyArIHRoaXMubWVzc2FnZXMubGVuZ3RoICsgJyBtZXNzYWdlcycpO1xuXHRcdHRoaXMubWVzc2FnZXMgPSBbXTtcblx0XHR0aGlzLmVtaXQoJ2lkbGUnKTtcblx0fTtcblxuXHRyZXR1cm4gTWVzc2FnZVF1ZXVlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChNZXNzYWdlUXVldWUpO1xuXG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBYSFJSZXF1ZXN0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciBpZENvdW50ZXIgPSAwO1xuXHR2YXIgcGVuZGluZ1JlcXVlc3RzID0ge307XG5cblx0dmFyIFJFUV9TRU5EID0gMCxcblx0XHRSRVFfUkVDViA9IDEsXG5cdFx0UkVRX1JFQ1ZfUE9MTCA9IDIsXG5cdFx0UkVRX1JFQ1ZfU1RSRUFNID0gMztcblxuXHRmdW5jdGlvbiBjbGVhclBlbmRpbmdSZXF1ZXN0cygpIHtcblx0XHRmb3IodmFyIGlkIGluIHBlbmRpbmdSZXF1ZXN0cylcblx0XHRcdHBlbmRpbmdSZXF1ZXN0c1tpZF0uZGlzcG9zZSgpO1xuXHR9XG5cblx0dmFyIGlzSUUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuWERvbWFpblJlcXVlc3Q7XG5cblx0ZnVuY3Rpb24gaWVWZXJzaW9uKCkge1xuXHRcdHZhciBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9TdHJpbmcoKS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pO1xuXHRcdHJldHVybiBtYXRjaCAmJiBOdW1iZXIobWF0Y2hbMV0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gbmVlZEpzb25FbnZlbG9wZSgpIHtcblx0XHQvKiBJRSAxMCB4aHIgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjMyMDMzOSAqL1xuXHRcdHZhciB2ZXJzaW9uO1xuXHRcdHJldHVybiBpc0lFICYmICh2ZXJzaW9uID0gaWVWZXJzaW9uKCkpICYmIHZlcnNpb24gPT09IDEwO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SGVhZGVyKHhociwgaGVhZGVyKSB7XG5cdFx0cmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlciAmJiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcblx0fVxuXG5cdC8qIFNhZmFyaSBteXN0ZXJpb3VzbHkgcmV0dXJucyAnSWRlbnRpdHknIGZvciB0cmFuc2Zlci1lbmNvZGluZyB3aGVuIGluIGZhY3Rcblx0ICogaXQgaXMgJ2NodW5rZWQnLiBTbyBpbnN0ZWFkLCBkZWNpZGUgdGhhdCBpdCBpcyBjaHVua2VkIHdoZW5cblx0ICogdHJhbnNmZXItZW5jb2RpbmcgaXMgcHJlc2VudCBvciBjb250ZW50LWxlbmd0aCBpcyBhYnNlbnQuICAoJ29yJyBiZWNhdXNlXG5cdCAqIHdoZW4gdXNpbmcgaHR0cDIgc3RyZWFtaW5nLCB0aGVyZSdzIG5vIHRyYW5zZmVyLWVuY29kaW5nIGhlYWRlciwgYnV0IGNhblxuXHQgKiBzdGlsbCBkZWR1Y2Ugc3RyZWFtaW5nIGZyb20gbGFjayBvZiBjb250ZW50LWxlbmd0aCkgKi9cblx0ZnVuY3Rpb24gaXNFbmNvZGluZ0NodW5rZWQoeGhyKSB7XG5cdFx0cmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlclxuXHRcdFx0JiYgKHhoci5nZXRSZXNwb25zZUhlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnKVxuXHRcdFx0fHwgIXhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XG5cdFx0dmFyIGhlYWRlclBhaXJzID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRyaW0oeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKS5zcGxpdCgnXFxyXFxuJyksXG5cdFx0XHRoZWFkZXJzID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJQYWlycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHBhcnRzID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyck1hcChoZWFkZXJQYWlyc1tpXS5zcGxpdCgnOicpLCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udHJpbSk7XG5cdFx0XHRoZWFkZXJzW3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdHJldHVybiBoZWFkZXJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdHBhcmFtcy5ybmQgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlYXBSYW5kU3RyKCk7XG5cdFx0aWYobmVlZEpzb25FbnZlbG9wZSgpICYmICFwYXJhbXMuZW52ZWxvcGUpXG5cdFx0XHRwYXJhbXMuZW52ZWxvcGUgPSAnanNvbic7XG5cdFx0dGhpcy51cmkgPSB1cmkgKyBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcblx0XHR0aGlzLm1ldGhvZCA9IG1ldGhvZCA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogKF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGJvZHkpID8gJ0dFVCcgOiAnUE9TVCcpO1xuXHRcdHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcblx0XHR0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG5cdFx0dGhpcy50aW1lZE91dCA9IGZhbHNlO1xuXHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG5cdFx0cGVuZGluZ1JlcXVlc3RzW3RoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpXSA9IHRoaXM7XG5cdH1cblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFhIUlJlcXVlc3QsIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdHZhciBjcmVhdGVSZXF1ZXN0ID0gWEhSUmVxdWVzdC5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG5cdFx0LyogWEhSIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcblx0XHQgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuXHRcdCAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG5cdFx0dGltZW91dHMgPSB0aW1lb3V0cyB8fCBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVElNRU9VVFM7XG5cdFx0cmV0dXJuIG5ldyBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdGlmKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuXHRcdFx0aWYoIWVyciAmJiBib2R5KSB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdH07XG5cblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lb3V0ID0gKHRoaXMucmVxdWVzdE1vZGUgPT0gUkVRX1NFTkQpID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0LFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHR0aW1lciA9IHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcblx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHR9LCB0aW1lb3V0KSxcblx0XHRcdGJvZHkgPSB0aGlzLmJvZHksXG5cdFx0XHRtZXRob2QgPSB0aGlzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnMgPSB0aGlzLmhlYWRlcnMsXG5cdFx0XHR4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0YWNjZXB0ID0gaGVhZGVyc1snYWNjZXB0J10sXG5cdFx0XHRyZXNwb25zZVR5cGUgPSAndGV4dCc7XG5cblx0XHRpZighYWNjZXB0KSB7XG5cdFx0XHRoZWFkZXJzWydhY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcblx0XHR9IGVsc2UgaWYoYWNjZXB0LmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycpID09PSAwKSB7XG5cdFx0XHRyZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRcdH1cblxuXHRcdGlmKGJvZHkpIHtcblx0XHRcdHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8IChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0XHRpZihjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSAmJiB0eXBlb2YoYm9keSkgIT0gJ3N0cmluZycpXG5cdFx0XHRcdGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcblx0XHR9XG5cblx0XHR4aHIub3BlbihtZXRob2QsIHRoaXMudXJpLCB0cnVlKTtcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuXG5cdFx0aWYgKCdhdXRob3JpemF0aW9uJyBpbiBoZWFkZXJzKSB7XG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmb3IodmFyIGggaW4gaGVhZGVycylcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuXG5cdFx0dmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQsIG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpIHtcblx0XHRcdHZhciBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlICsgJyAoZXZlbnQgdHlwZTogJyArIGVycm9yRXZlbnQudHlwZSArICcpJyArIChzZWxmLnhoci5zdGF0dXNUZXh0ID8gJywgY3VycmVudCBzdGF0dXNUZXh0IGlzICcgKyBzZWxmLnhoci5zdGF0dXNUZXh0IDogJycpO1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdSZXF1ZXN0Lm9uJyArIGVycm9yRXZlbnQudHlwZSArICcoKScsIGVycm9yTWVzc2FnZSk7XG5cdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXShlcnJvck1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpKTtcblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuXHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdYSFIgZXJyb3Igb2NjdXJyZWQnLCBudWxsLCA0MDApO1xuXHRcdH1cblx0XHR4aHIub25hYm9ydCA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHRcdGlmKHNlbGYudGltZWRPdXQpIHtcblx0XHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZycsIG51bGwsIDQwOCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgY2FuY2VsbGVkJywgbnVsbCwgNDAwKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KTtcblx0XHR9O1xuXG5cdFx0dmFyIHN0cmVhbWluZyxcblx0XHRcdHN0YXR1c0NvZGUsXG5cdFx0XHRyZXNwb25zZUJvZHksXG5cdFx0XHRjb250ZW50VHlwZSxcblx0XHRcdHN1Y2Nlc3NSZXNwb25zZSxcblx0XHRcdHN0cmVhbVBvcyA9IDAsXG5cdFx0XHR1bnBhY2tlZCA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gb25SZXNwb25zZSgpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHRzdWNjZXNzUmVzcG9uc2UgPSAoc3RhdHVzQ29kZSA8IDQwMCk7XG5cdFx0XHRpZihzdGF0dXNDb2RlID09IDIwNCkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzdHJlYW1pbmcgPSAoc2VsZi5yZXF1ZXN0TW9kZSA9PSBSRVFfUkVDVl9TVFJFQU0gJiYgc3VjY2Vzc1Jlc3BvbnNlICYmIGlzRW5jb2RpbmdDaHVua2VkKHhocikpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uRW5kKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgJ2NvbnRlbnQtdHlwZScpLFxuXHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5LFxuXHRcdFx0XHRcdC8qIEJlIGxpYmVyYWwgaW4gd2hhdCB3ZSBhY2NlcHQ7IGJ1Z2d5IGF1dGggc2VydmVycyBtYXkgcmVzcG9uZFxuXHRcdFx0XHRcdCAqIHdpdGhvdXQgdGhlIGNvcnJlY3QgY29udGVudHR5cGUsIGJ1dCBhc3N1bWUgdGhleSdyZSBzdGlsbFxuXHRcdFx0XHRcdCAqIHJlc3BvbmRpbmcgd2l0aCBqc29uICovXG5cdFx0XHRcdFx0anNvbiA9IGNvbnRlbnRUeXBlID8gKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+PSAwKSA6ICh4aHIucmVzcG9uc2VUeXBlID09ICd0ZXh0Jyk7XG5cblx0XHRcdFx0aWYoanNvbikge1xuXHRcdFx0XHRcdC8qIElmIHdlIHJlcXVlc3RlZCBtc2dwYWNrIGJ1dCBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGgganNvbiwgdGhlbiBzaW5jZVxuXHRcdFx0XHRcdCAqIHdlIHNldCB0aGUgcmVzcG9uc2VUeXBlIGV4cGVjdGluZyBtc2dwYWNrLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZVxuXHRcdFx0XHRcdCAqIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcganNvbiAqL1xuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9ICh4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSA/IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOERlY29kZSh4aHIucmVzcG9uc2UpIDogU3RyaW5nKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHRcdGlmKHJlc3BvbnNlQm9keS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9IEpTT04ucGFyc2UocmVzcG9uc2VCb2R5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dW5wYWNrZWQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9IHhoci5yZXNwb25zZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHJlc3BvbnNlQm9keS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0LyogdW53cmFwIEpTT04gZW52ZWxvcGUgKi9cblx0XHRcdFx0XHRzdGF0dXNDb2RlID0gcmVzcG9uc2VCb2R5LnN0YXR1c0NvZGU7XG5cdFx0XHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xuXHRcdFx0XHRcdGhlYWRlcnMgPSByZXNwb25zZUJvZHkuaGVhZGVycztcblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHkucmVzcG9uc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVycyA9IGdldEhlYWRlcnNBc09iamVjdCh4aHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBJZiByZXNwb25zZSBpcyBhbiBhcnJheSwgaXQncyBhbiBhcnJheSBvZiBwcm90b2NvbCBtZXNzYWdlcyAtLSBldmVuIGlmXG5cdFx0XHQgKiBpcyBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cblx0XHRcdCAqIGNvbnNpZGVyIHRoZSByZXF1ZXN0IHRvIGhhdmUgc3VjY2VlZGVkLCBqdXN0IHBhc3MgaXQgb24gdG9cblx0XHRcdCAqIG9uUHJvdG9jb2xNZXNzYWdlIHRvIGRlY2lkZSB3aGF0IHRvIGRvICovXG5cdFx0XHRpZihzdWNjZXNzUmVzcG9uc2UgfHwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkocmVzcG9uc2VCb2R5KSkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBlcnIgPSByZXNwb25zZUJvZHkuZXJyb3IgJiYgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuXHRcdFx0aWYoIWVycikge1xuXHRcdFx0XHRlcnIgPSBuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICsgc3RhdHVzQ29kZSArICcgYm9keSB3YXM6ICcgKyBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChyZXNwb25zZUJvZHkpLCBudWxsLCBzdGF0dXNDb2RlKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuY29tcGxldGUoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblByb2dyZXNzKCkge1xuXHRcdFx0cmVzcG9uc2VCb2R5ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdHZhciBib2R5RW5kID0gcmVzcG9uc2VCb2R5Lmxlbmd0aCAtIDEsIGlkeCwgY2h1bms7XG5cdFx0XHR3aGlsZSgoc3RyZWFtUG9zIDwgYm9keUVuZCkgJiYgKGlkeCA9IHJlc3BvbnNlQm9keS5pbmRleE9mKCdcXG4nLCBzdHJlYW1Qb3MpKSA+IC0xKSB7XG5cdFx0XHRcdGNodW5rID0gcmVzcG9uc2VCb2R5LnNsaWNlKHN0cmVhbVBvcywgaWR4KTtcblx0XHRcdFx0c3RyZWFtUG9zID0gaWR4ICsgMTtcblx0XHRcdFx0b25DaHVuayhjaHVuayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25DaHVuayhjaHVuaykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TdHJlYW1FbmQoKSB7XG5cdFx0XHRvblByb2dyZXNzKCk7XG5cdFx0XHRzZWxmLnN0cmVhbUNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcblx0XHRcdGlmKHJlYWR5U3RhdGUgPCAzKSByZXR1cm47XG5cdFx0XHRpZih4aHIuc3RhdHVzICE9PSAwKSB7XG5cdFx0XHRcdGlmKHN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuXHRcdFx0XHRcdC8qIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwICovXG5cdFx0XHRcdFx0aWYoc3RhdHVzQ29kZSA9PT0gMTIyMykgc3RhdHVzQ29kZSA9IDIwNDtcblx0XHRcdFx0XHRvblJlc3BvbnNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocmVhZHlTdGF0ZSA9PSAzICYmIHN0cmVhbWluZykge1xuXHRcdFx0XHRcdG9uUHJvZ3Jlc3MoKTtcblx0XHRcdFx0fSBlbHNlIGlmKHJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0XHRcdGlmKHN0cmVhbWluZylcblx0XHRcdFx0XHRcdG9uU3RyZWFtRW5kKCk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0b25FbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0eGhyLnNlbmQoYm9keSk7XG5cdH07XG5cblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB4aHIgPSB0aGlzLnhocjtcblx0XHRpZih4aHIpIHtcblx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IG5vb3A7XG5cdFx0XHR0aGlzLnhociA9IG51bGw7XG5cdFx0XHR2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuXHRcdFx0aWYodGltZXIpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0dGhpcy50aW1lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZighdGhpcy5yZXF1ZXN0Q29tcGxldGUpXG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdH1cblx0XHRkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3RoaXMuaWRdO1xuXHR9O1xuXG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ueGhyU3VwcG9ydGVkKSB7XG5cdFx0aWYodHlwZW9mIF91dGlsX2RvbWV2ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFkZFVubG9hZExpc3RlbmVyKGNsZWFyUGVuZGluZ1JlcXVlc3RzKTtcblx0XHR9XG5cdFx0aWYodHlwZW9mKHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciByZXEgPSBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBSRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XG5cdFx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcblx0XHRcdFx0cmVxLmV4ZWMoKTtcblx0XHRcdFx0cmV0dXJuIHJlcTtcblx0XHRcdH07XG5cblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciB1cFVybCA9IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcm5ldFVwVXJsO1xuXHRcdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgdXBVcmwpO1xuXHRcdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0VXJpKG51bGwsIHVwVXJsLCBudWxsLCBudWxsLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlVGV4dCkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQgPSAoIWVyciAmJiByZXNwb25zZVRleHQucmVwbGFjZSgvXFxuLywgJycpID09ICd5ZXMnKTtcblx0XHRcdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhYSFJSZXF1ZXN0KUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gWEhSUmVxdWVzdDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoWEhSUmVxdWVzdCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMCksIF9fd2VicGFja19yZXF1aXJlX18oNDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNyksIF9fd2VicGFja19yZXF1aXJlX18oMzYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCksIF9fd2VicGFja19yZXF1aXJlX18oMzEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0OCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogSE1BQyBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXHQgICAgICAgICAgICBpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xuXHQgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG5cdCAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcblx0ICAgICAgICAgICAgdmFyIGlubmVySGFzaCA9IGhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhtYWM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcblx0ICAgICAqL1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIHZhciBibG9jaztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3I7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09IG1vZGVDcmVhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLmluaXQodGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPSBtb2RlQ3JlYXRvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZEFycmF5O1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkhleDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGY4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG5cbnZhciBQcm90b2NvbCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGFjdGlvbnMgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uO1xuXG5cdGZ1bmN0aW9uIFByb3RvY29sKHRyYW5zcG9ydCkge1xuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XG5cdFx0dGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRyYW5zcG9ydC5vbignYWNrJywgZnVuY3Rpb24oc2VyaWFsLCBjb3VudCkgeyBzZWxmLm9uQWNrKHNlcmlhbCwgY291bnQpOyB9KTtcblx0XHR0cmFuc3BvcnQub24oJ25hY2snLCBmdW5jdGlvbihzZXJpYWwsIGNvdW50LCBlcnIpIHsgc2VsZi5vbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKTsgfSk7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhQcm90b2NvbCwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbkFjayA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUHJvdG9jb2wub25BY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuXHRcdHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLm9uTmFjayA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQsIGVycikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdQcm90b2NvbC5vbk5hY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQgKyAnOyBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0aWYoIWVycikge1xuXHRcdFx0ZXJyID0gbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgY2hhbm5lbCBub3QgcmVzcG9uZGluZycsIDUwMDAxLCA1MDApO1xuXHRcdH1cblx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycik7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLm9uY2VJZGxlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHR2YXIgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XG5cdFx0aWYobWVzc2FnZVF1ZXVlLmNvdW50KCkgPT09IDApIHtcblx0XHRcdGxpc3RlbmVyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdG1lc3NhZ2VRdWV1ZS5vbmNlKCdpZGxlJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGVuZGluZ01lc3NhZ2UpIHtcblx0XHRpZihwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCkge1xuXHRcdFx0dGhpcy5tZXNzYWdlUXVldWUucHVzaChwZW5kaW5nTWVzc2FnZSk7XG5cdFx0fVxuXHRcdGlmIChfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zaG91bGRMb2coX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPKSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1Byb3RvY29sLnNlbmQoKScsICdzZW5kaW5nIG1zZzsgJyArIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdpZnkocGVuZGluZ01lc3NhZ2UubWVzc2FnZSkpO1xuXHRcdH1cblx0XHRwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcblx0XHR0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5nZXRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc3BvcnQ7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmdldFBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmNsZWFyUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG5cdH07XG5cblx0UHJvdG9jb2wucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydDtcblx0XHR0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xuXHRcdFx0dHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBQZW5kaW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHRoaXMubWVyZ2VkID0gZmFsc2U7XG5cdFx0dmFyIGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xuXHRcdHRoaXMuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuYWNrUmVxdWlyZWQgPSAoYWN0aW9uID09IGFjdGlvbnMuTUVTU0FHRSB8fCBhY3Rpb24gPT0gYWN0aW9ucy5QUkVTRU5DRSk7XG5cdH1cblx0UHJvdG9jb2wuUGVuZGluZ01lc3NhZ2UgPSBQZW5kaW5nTWVzc2FnZTtcblxuXHRyZXR1cm4gUHJvdG9jb2w7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb3RvY29sKTtcblxuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBEb21FdmVudCA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gRG9tRXZlbnQoKSB7fVxuXG5cdERvbUV2ZW50LmFkZExpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZih0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hdHRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpIHsgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOyB9KTtcblx0XHR9XG5cdH07XG5cblx0RG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmRldGFjaEV2ZW50KCdvbicrZXZlbnQsIGZ1bmN0aW9uKCkgeyBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7IH0pO1xuXHRcdH1cblx0fTtcblxuXHREb21FdmVudC5hZGRNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGxpc3RlbmVyKSB7XG5cdFx0RG9tRXZlbnQuYWRkTGlzdGVuZXIodGFyZ2V0LCAnbWVzc2FnZScsIGxpc3RlbmVyKTtcblx0fTtcblxuXHREb21FdmVudC5yZW1vdmVNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGxpc3RlbmVyKSB7XG5cdFx0RG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCAnbWVzc2FnZScsIGxpc3RlbmVyKTtcblx0fTtcblxuXHREb21FdmVudC5hZGRVbmxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0RG9tRXZlbnQuYWRkTGlzdGVuZXIoZ2xvYmFsLCAndW5sb2FkJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdHJldHVybiBEb21FdmVudDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRG9tRXZlbnQpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3Nixcblx0ICAgICAgICAgICAgICAgIDB4YzNkMmUxZjBcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGUgKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKSAtIDB4NzBlNDQzMjQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMzYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuSG1hY1NIQTI1NjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBKU09OUFRyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0LyogQ2FuJ3QganVzdCB1c2Ugd2luZG93LkFibHksIGFzIHRoYXQgd29uJ3QgZXhpc3QgaWYgdXNpbmcgdGhlIGNvbW1vbmpzIHZlcnNpb24uICovXG5cdHZhciBfID0gZ2xvYmFsLl9hYmx5anNfanNvbnAgPSB7fTtcblxuXHQvKiBleHByZXNzIHN0cmlwcyBvdXQgcGFyYW50aGVzZXMgZnJvbSB0aGUgY2FsbGJhY2shXG5cdCAqIEtsdWRnZSB0byBzdGlsbCBhbG93IGl0cyByZXNwb25zZXMgdG8gd29yaywgd2hpbGUgbm90IGtlZXBpbmcgdGhlXG5cdCAqIGZ1bmN0aW9uIGZvcm0gZm9yIG5vcm1hbCB1c2UgYW5kIG5vdCBjbHV0dGVyaW5nIHdpbmRvdy5BYmx5XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9leHByZXNzanMvZXhwcmVzcy9ibG9iLzViNGQ0YjRhYjEzMjQ3NDM1MzRmYmNkNDcwOWY0ZTc1YmI0YjRlOWQvbGliL3Jlc3BvbnNlLmpzI0wzMDVcblx0ICovXG5cdF8uXyA9IGZ1bmN0aW9uKGlkKSB7IHJldHVybiBfWydfJyArIGlkXSB8fCBub29wOyB9O1xuXHR2YXIgaWRDb3VudGVyID0gMTtcblx0dmFyIGhlYWQgPSBudWxsO1xuXHR2YXIgc2hvcnROYW1lID0gJ2pzb25wJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gSlNPTlBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcblx0XHRfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhKU09OUFRyYW5zcG9ydCwgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hbGxvd0NvbWV0O1xuXHR9O1xuXHRpZihKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gSlNPTlBUcmFuc3BvcnQ7XG5cdH1cblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5qc29ucFN1cHBvcnRlZCkge1xuXHRcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHR9XG5cblx0LyogY29ubmVjdGl2aXR5IGNoZWNrOyBzaW5jZSB0aGlzIGhhcyBhIGhhcmQtY29kZWQgY2FsbGJhY2sgaWQsXG5cdCAqIHdlIGp1c3QgbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMgKGJ1dCB0aGVcblx0ICogY29ubmVjdGlvbm1hbmFnZXIgc2hvdWxkIGVuc3VyZSB0aGlzIGRvZXNuJ3QgaGFwcGVuIGFueXdheSAqL1xuXHR2YXIgY2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG5cdGdsb2JhbC5KU09OUFRyYW5zcG9ydCA9IEpTT05QVHJhbnNwb3J0XG5cblx0SlNPTlBUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IG5ldyBKU09OUFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdKU09OUFRyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnSlNPTlBUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG5cdH07XG5cblx0dmFyIGNyZWF0ZVJlcXVlc3QgPSBKU09OUFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdC8qIEpTT05QIHJlcXVlc3RzIGFyZSB1c2VkIGVpdGhlciB3aXRoIHRoZSBjb250ZXh0IGJlaW5nIGEgcmVhbHRpbWVcblx0XHQgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxuXHRcdCAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG5cdFx0dGltZW91dHMgPSAodGhpcyAmJiB0aGlzLnRpbWVvdXRzKSB8fCB0aW1lb3V0cyB8fCBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVElNRU9VVFM7XG5cdFx0cmV0dXJuIG5ldyBSZXF1ZXN0KHVuZGVmaW5lZCwgdXJpLCBoZWFkZXJzLCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gUmVxdWVzdChpZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG5cdFx0X2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdGlmKGlkID09PSB1bmRlZmluZWQpIGlkID0gaWRDb3VudGVyKys7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMudXJpID0gdXJpO1xuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdHRoaXMucGFyYW1zLnJuZCA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcblx0XHRpZihoZWFkZXJzKSB7XG5cdFx0XHQvKiBKU09OUCBkb2Vzbid0IGFsbG93IGhlYWRlcnMuIENoZXJyeS1waWNrIGEgY291cGxlIHRvIHR1cm4gaW50byBxcyBwYXJhbXMgKi9cblx0XHRcdGlmKGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ10pIHRoaXMucGFyYW1zLnYgPSBoZWFkZXJzWydYLUFibHktVmVyc2lvbiddO1xuXHRcdFx0aWYoaGVhZGVyc1snQWJseS1BZ2VudCddKSB0aGlzLnBhcmFtcy5hZ2VudCA9IGhlYWRlcnNbJ0FibHktQWdlbnQnXTtcblx0XHR9XG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcblx0XHR0aGlzLm1ldGhvZCA9IG1ldGhvZDtcblx0XHR0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuXHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gZmFsc2U7XG5cdH1cblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFJlcXVlc3QsIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSB0aGlzLmlkLFxuXHRcdFx0Ym9keSA9IHRoaXMuYm9keSxcblx0XHRcdG1ldGhvZCA9IHRoaXMubWV0aG9kLFxuXHRcdFx0dXJpID0gdGhpcy51cmksXG5cdFx0XHRwYXJhbXMgPSB0aGlzLnBhcmFtcyxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0cGFyYW1zLmNhbGxiYWNrID0gJ19hYmx5anNfanNvbnAuXygnICsgaWQgKyAnKSc7XG5cblx0XHRwYXJhbXMuZW52ZWxvcGUgPSAnanNvbnAnO1xuXHRcdGlmKGJvZHkpIHtcblx0XHRcdHBhcmFtcy5ib2R5ID0gYm9keTtcblx0XHR9XG5cdFx0aWYobWV0aG9kICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcblx0XHRcdHBhcmFtcy5tZXRob2QgPSBtZXRob2Q7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0dmFyIHNyYyA9IHVyaSArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG5cdFx0c2NyaXB0LnNyYyA9IHNyYztcblx0XHRpZihzY3JpcHQuc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdICE9PSBzcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0pIHtcblx0XHRcdC8qIFRoZSBzcmMgaGFzIGJlZW4gdHJ1bmNhdGVkLiBDYW4ndCBhYm9ydCwgYnV0IGNhbiBhdCBsZWFzdCBlbWl0IGFuXG5cdFx0XHQgKiBlcnJvciBzbyB0aGUgdXNlciBrbm93cyB3aGF0J3MgZ29uZSB3cm9uZy4gKENhbid0IGNvbXBhcmUgc3RyaW5nc1xuXHRcdFx0ICogZGlyZWN0bHkgYXMgc3JjIG1heSBoYXZlIGEgcG9ydCwgc2NyaXB0LnNyYyB3b24ndCkgKi9cblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnSlNPTlAgUmVxdWVzdC5leGVjKCknLCAnV2FybmluZzogdGhlIGJyb3dzZXIgYXBwZWFycyB0byBoYXZlIHRydW5jYXRlZCB0aGUgc2NyaXB0IFVSSS4gVGhpcyB3aWxsIGxpa2VseSByZXN1bHQgaW4gdGhlIHJlcXVlc3QgZmFpbGluZyBkdWUgdG8gYW4gdW5wYXJzZWFibGUgYm9keSBwYXJhbScpO1xuXHRcdH1cblx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXHRcdHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuXHRcdHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnSlNPTlAgc2NyaXB0IGVycm9yIChldmVudDogJyArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KGVycikgKyAnKScsIG51bGwsIDQwMCkpO1xuXHRcdH07XG5cblx0XHRfWydfJyArIGlkXSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRcdGlmKG1lc3NhZ2Uuc3RhdHVzQ29kZSkge1xuXHRcdFx0XHQvKiBIYW5kbGUgYXMgZW52ZWxvcGVkIGpzb25wLCBhcyBhbGwganNvbnAgdHJhbnNwb3J0IHVzZXMgc2hvdWxkIGJlICovXG5cdFx0XHRcdHZhciByZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2U7XG5cdFx0XHRcdGlmKG1lc3NhZ2Uuc3RhdHVzQ29kZSA9PSAyMDQpIHtcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZighcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnSW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2U6IG5vIGVudmVsb3BlIGRldGVjdGVkJywgbnVsbCwgNTAwKSk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZXNzYWdlLnN0YXR1c0NvZGUgPCA0MDAgfHwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkocmVzcG9uc2UpKSB7XG5cdFx0XHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuXHRcdFx0XHRcdCAqIGl0IGNvbnRhaW5zIGFuIGVycm9yIGFjdGlvbiAoaGVuY2UgdGhlIG5vbnN1Y2Nlc3Mgc3RhdHVzY29kZSksIHdlIGNhblxuXHRcdFx0XHRcdCAqIGNvbnNpZGVyIHRoZSByZXF1ZXN0IHRvIGhhdmUgc3VjY2VlZGVkLCBqdXN0IHBhc3MgaXQgb24gdG9cblx0XHRcdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgcmVzcG9uc2UsIG1lc3NhZ2UuaGVhZGVycywgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZXJyID0gcmVzcG9uc2UuZXJyb3IgfHwgbmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcicsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBIYW5kbGUgYXMgbm9uLWVudmVsb3BlZCAtLSBhcyB3aWxsIGJlIGVnIGZyb20gYSBjdXN0b21lcidzIGF1dGhVcmwgc2VydmVyICovXG5cdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgbWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciB0aW1lb3V0ID0gKHRoaXMucmVxdWVzdE1vZGUgPT0gX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUkVRX1NFTkQpID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0O1xuXHRcdHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxmLmFib3J0KCk7IH0sIHRpbWVvdXQpO1xuXHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcblx0fTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgc3RhdHVzQ29kZSkge1xuXHRcdGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuXHRcdGlmKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuXHRcdFx0dmFyIGNvbnRlbnRUeXBlO1xuXHRcdFx0aWYoYm9keSkge1xuXHRcdFx0XHRjb250ZW50VHlwZSA9ICh0eXBlb2YoYm9keSkgPT0gJ3N0cmluZycpID8gJ3RleHQvcGxhaW4nIDogJ2FwcGxpY2F0aW9uL2pzb24nO1xuXHRcdFx0XHRoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGNvbnRlbnRUeXBlO1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2RhdGEnLCBib2R5KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgLyogdW5wYWNrZWQ6ICovIHRydWUsIHN0YXR1c0NvZGUpO1xuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdH07XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lciA9IHRoaXMudGltZXI7XG5cdFx0aWYodGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHR0aGlzLnRpbWVyID0gbnVsbDtcblx0XHR9XG5cdFx0dmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuXHRcdGlmKHNjcmlwdC5wYXJlbnROb2RlKSBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdGRlbGV0ZSBfW3RoaXMuaWRdO1xuXHRcdHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcblx0fTtcblxuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmpzb25wU3VwcG9ydGVkICYmICFwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uUmVxdWVzdCkge1xuXHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciByZXEgPSBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XG5cdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXE7XG5cdFx0fTtcblxuXHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgdXBVcmwgPSBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBJbnRlcm5ldFVwVXJsO1xuXG5cdFx0XHRpZihjaGVja3NJblByb2dyZXNzKSB7XG5cdFx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MucHVzaChjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MgPSBbY2FsbGJhY2tdO1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoSlNPTlApSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyB1cFVybCk7XG5cblx0XHRcdHZhciByZXEgPSBuZXcgUmVxdWVzdCgnaXNUaGVJbnRlcm5ldFVwJywgdXBVcmwsIG51bGwsIG51bGwsIG51bGwsIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJFUV9TRU5ELCBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVElNRU9VVFMpO1xuXHRcdFx0cmVxLm9uY2UoJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gIWVyciAmJiByZXNwb25zZTtcblx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoSlNPTlApSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjaGVja3NJblByb2dyZXNzLmxlbmd0aDsgaSsrKSBjaGVja3NJblByb2dyZXNzW2ldKG51bGwsIHJlc3VsdCk7XG5cdFx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuXHRcdFx0fSk7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIEpTT05QVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChKU09OUFRyYW5zcG9ydCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cblxuXG52YXIgV2ViU29ja2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIpIHtcblx0dmFyIFdlYlNvY2tldCA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uV2ViU29ja2V0O1xuXHR2YXIgc2hvcnROYW1lID0gJ3dlYl9zb2NrZXQnO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHRcdC8qIElmIGlzIGEgYnJvd3NlciwgY2FuJ3QgZGV0ZWN0IHBpbmdzLCBzbyByZXF1ZXN0IHByb3RvY29sIGhlYXJ0YmVhdHMgKi9cblx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXNlUHJvdG9jb2xIZWFydGJlYXRzO1xuXHRcdF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMud3NIb3N0ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0KHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuaG9zdCwgdHJ1ZSk7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhV2ViU29ja2V0O1xuXHR9O1xuXG5cdGlmKFdlYlNvY2tldFRyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKVxuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IG5ldyBXZWJTb2NrZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3dzb3BlbicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlV2ViU29ja2V0ID0gZnVuY3Rpb24odXJpLCBjb25uZWN0UGFyYW1zKSB7XG5cdFx0dGhpcy51cmkgPSB1cmkgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcylcblx0XHRyZXR1cm4gbmV3IFdlYlNvY2tldCh0aGlzLnVyaSk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnV2ViU29ja2V0VHJhbnNwb3J0OyB1cmk9JyArIHRoaXMudXJpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3N0YXJ0aW5nJyk7XG5cdFx0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXHRcdHZhciB3c1NjaGVtZSA9IG9wdGlvbnMudGxzID8gJ3dzczovLycgOiAnd3M6Ly8nO1xuXHRcdHZhciB3c1VyaSA9IHdzU2NoZW1lICsgdGhpcy53c0hvc3QgKyAnOicgKyBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFBvcnQob3B0aW9ucykgKyAnLyc7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAndXJpOiAnICsgd3NVcmkpO1xuXHRcdHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuXHRcdFx0aWYoc2VsZi5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJhbVN0ciA9ICcnOyBmb3IodmFyIHBhcmFtIGluIGF1dGhQYXJhbXMpIHBhcmFtU3RyICs9ICcgJyArIHBhcmFtICsgJzogJyArIGF1dGhQYXJhbXNbcGFyYW1dICsgJzsnO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnYXV0aFBhcmFtczonICsgcGFyYW1TdHIgKyAnIGVycjogJyArIGVycik7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBjb25uZWN0UGFyYW1zID0gcGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgd3NDb25uZWN0aW9uID0gc2VsZi53c0Nvbm5lY3Rpb24gPSBzZWxmLmNyZWF0ZVdlYlNvY2tldCh3c1VyaSwgY29ubmVjdFBhcmFtcyk7XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iaW5hcnlUeXBlO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24oKSB7IHNlbGYub25Xc09wZW4oKTsgfTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9uY2xvc2UgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NDbG9zZShldik7IH07XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NEYXRhKGV2LmRhdGEpOyB9O1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uKGV2KSB7IHNlbGYub25Xc0Vycm9yKGV2KTsgfTtcblx0XHRcdFx0aWYod3NDb25uZWN0aW9uLm9uKSB7XG5cdFx0XHRcdFx0Lyogbm9kZTsgYnJvd3NlcnMgY3VycmVudGx5IGRvbid0IGhhdmUgYSBnZW5lcmFsIGV2ZW50ZW1pdHRlciBhbmQgY2FuJ3QgZGV0ZWN0XG5cdFx0XHRcdFx0ICogcGluZ3MuIEFsc28sIG5vIG5lZWQgdG8gcmVwbHkgd2l0aCBhIHBvbmcgZXhwbGljaXRseSwgd3MgbGliIGhhbmRsZXMgdGhhdCAqL1xuXHRcdFx0XHRcdHdzQ29ubmVjdGlvbi5vbigncGluZycsIGZ1bmN0aW9uKCkgeyBzZWxmLm9uQWN0aXZpdHkoKTsgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBjcmVhdGluZyB3ZWJzb2NrZXQ6IGVyciA9ICcgKyAoZS5zdGFjayB8fCBlLm1lc3NhZ2UpKTtcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG5cdFx0aWYoIXdzQ29ubmVjdGlvbikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5zZW5kKCknLCAnTm8gc29ja2V0IGNvbm5lY3Rpb24nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHdzQ29ubmVjdGlvbi5zZW5kKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zZXJpYWxpemUobWVzc2FnZSwgdGhpcy5wYXJhbXMuZm9ybWF0KSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dmFyIG1zZyA9ICdFeGNlcHRpb24gZnJvbSB3cyBjb25uZWN0aW9uIHdoZW4gdHJ5aW5nIHRvIHNlbmQ6ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlKTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgbXNnKTtcblx0XHRcdC8qIERvbid0IHRyeSB0byByZXF1ZXN0IGEgZGlzY29ubmVjdCwgdGhhdCdsbCBqdXN0IGludm9sdmUgc2VuZGluZyBkYXRhXG5cdFx0XHQgKiBkb3duIHRoZSB3ZWJzb2NrZXQgYWdhaW4uIEp1c3QgZmluaXNoIHRoZSB0cmFuc3BvcnQuICovXG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDUwMDAwLCA1MDApKTtcblx0XHR9XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnZGF0YSByZWNlaXZlZDsgbGVuZ3RoID0gJyArIGRhdGEubGVuZ3RoICsgJzsgdHlwZSA9ICcgKyB0eXBlb2YoZGF0YSkpO1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZXNlcmlhbGl6ZShkYXRhLCB0aGlzLmZvcm1hdCkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogJyArIGUuc3RhY2spO1xuXHRcdH1cblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NPcGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzT3BlbigpJywgJ29wZW5lZCBXZWJTb2NrZXQnKTtcblx0XHR0aGlzLmVtaXQoJ3dzb3BlbicpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0Nsb3NlID0gZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgd2FzQ2xlYW4sIGNvZGUsIHJlYXNvbjtcblx0XHRpZih0eXBlb2YoZXYpID09ICdvYmplY3QnKSB7XG5cdFx0XHQvKiBXM0Mgc3BlYy1jb21wYXRpYmxlICovXG5cdFx0XHR3YXNDbGVhbiA9IGV2Lndhc0NsZWFuO1xuXHRcdFx0Y29kZSA9IGV2LmNvZGU7XG5cdFx0fSBlbHNlIC8qaWYodHlwZW9mKGV2KSA9PSAnbnVtYmVyJykqLyB7XG5cdFx0XHQvKiB3cyBpbiBub2RlICovXG5cdFx0XHRjb2RlID0gZXY7XG5cdFx0XHR3YXNDbGVhbiA9IChjb2RlID09IDEwMDApO1xuXHRcdH1cblx0XHRkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG5cdFx0aWYod2FzQ2xlYW4pIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCAnQ2xlYW5seSBjbG9zZWQgV2ViU29ja2V0Jyk7XG5cdFx0XHR2YXIgZXJyID0gbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnV2Vic29ja2V0IGNsb3NlZCcsIDgwMDAzLCA0MDApO1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnVW5jbGVhbiBkaXNjb25uZWN0aW9uIG9mIFdlYlNvY2tldCA7IGNvZGUgPSAnICsgY29kZSxcblx0XHRcdFx0ZXJyID0gbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDAzLCA0MDApO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsIG1zZyk7XG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbkVycm9yKCknLCAnRXJyb3IgZnJvbSBXZWJTb2NrZXQ6ICcgKyBlcnIubWVzc2FnZSk7XG5cdFx0LyogV2FpdCBhIHRpY2sgYmVmb3JlIGFib3J0aW5nOiBpZiB0aGUgd2Vic29ja2V0IHdhcyBjb25uZWN0ZWQsIHRoaXMgZXZlbnRcblx0XHQgKiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9uY2xvc2UgZXZlbnQgd2l0aCBhIGNsb3NlIGNvZGUuIEFsbG93XG5cdFx0ICogdGhhdCB0byBjbG9zZSBpdCAoc28gd2Ugc2VlIHRoZSBjbG9zZSBjb2RlKSByYXRoZXIgdGhhbiBhbnRpY2lwYXRpbmcgaXQgKi9cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG5cdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKHdzQ29ubmVjdGlvbikge1xuXHRcdFx0LyogSWdub3JlIGFueSBtZXNzYWdlcyB0aGF0IGNvbWUgdGhyb3VnaCBhZnRlciBkaXNwb3NlKCkgaXMgY2FsbGVkIGJ1dCBiZWZvcmVcblx0XHRcdCAqIHdlYnNvY2tldCBpcyBhY3R1YWxseSBjbG9zZWQuIChtb3N0bHkgd291bGQgYmUgaGFybWxlc3MsIGJ1dCBpZiBpdCdzIGFcblx0XHRcdCAqIENPTk5FQ1RFRCwgaXQnbGwgcmUtdGljayBpc0Nvbm5lY3RlZCBhbmQgY2F1c2UgYWxsIHNvcnRzIG9mIGhhdm9jKSAqL1xuXHRcdFx0d3NDb25uZWN0aW9uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHRkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG5cdFx0XHQvKiBkZWZlciB1bnRpbCB0aGUgbmV4dCBldmVudCBsb29wIGN5Y2xlIGJlZm9yZSBjbG9zaW5nIHRoZSBzb2NrZXQsXG5cdFx0XHQgKiBnaXZpbmcgc29tZSBpbXBsZW1lbnRhdGlvbnMgdGhlIG9wcG9ydHVuaXR5IHRvIHNlbmQgYW55IG91dHN0YW5kaW5nIGNsb3NlIG1lc3NhZ2UgKi9cblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJ2Nsb3Npbmcgd2Vic29ja2V0Jyk7XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5jbG9zZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFdlYlNvY2tldFRyYW5zcG9ydCk7XG5cblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC9qc29ucHRyYW5zcG9ydC5qc1xudmFyIGpzb25wdHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2NvbWV0dHJhbnNwb3J0LmpzXG52YXIgY29tZXR0cmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC94aHJyZXF1ZXN0LmpzXG52YXIgeGhycmVxdWVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC94aHJwb2xsaW5ndHJhbnNwb3J0LmpzXG5cblxuXG5cblxuXG52YXIgeGhycG9sbGluZ3RyYW5zcG9ydF9YSFJQb2xsaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIpIHtcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfcG9sbGluZyc7XG5cblx0ZnVuY3Rpb24gWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0cGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuXHRcdGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoWEhSUG9sbGluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS54aHJTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5hbGxvd0NvbWV0O1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IG5ldyBYSFJQb2xsaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdYSFJQb2xsaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ1hIUlBvbGxpbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG5cdH07XG5cblx0WEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xuXHRcdHJldHVybiB4aHJyZXF1ZXN0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcblx0fTtcblxuXHRpZih0eXBlb2YoY29ubmVjdGlvbk1hbmFnZXIpICE9PSAndW5kZWZpbmVkJyAmJiBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuXHR9XG5cblx0cmV0dXJuIFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJwb2xsaW5ndHJhbnNwb3J0ID0gKHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnN0cmVhbWluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cblxudmFyIHhocnN0cmVhbWluZ3RyYW5zcG9ydF9YSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgc2hvcnROYW1lID0gJ3hocl9zdHJlYW1pbmcnO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoWEhSU3RyZWFtaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc3RyZWFtaW5nU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsb3dDb21ldDtcblx0fTtcblxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRyYW5zcG9ydCA9IG5ldyBYSFJTdHJlYW1pbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1hIUlN0cmVhbWluZ1RyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ1hIUlN0cmVhbWluZ1RyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcblx0fTtcblxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcblx0XHRyZXR1cm4geGhycmVxdWVzdFtcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cyk7XG5cdH07XG5cblx0aWYodHlwZW9mKGNvbm5lY3Rpb25NYW5hZ2VyKSAhPT0gJ3VuZGVmaW5lZCcgJiYgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cdH1cblxuXHRyZXR1cm4gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0ID0gKHhocnN0cmVhbWluZ3RyYW5zcG9ydF9YSFJTdHJlYW1pbmdUcmFuc3BvcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC9pbmRleC5qc1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsaWJfdHJhbnNwb3J0ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoW1xuICBqc29ucHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgeGhycG9sbGluZ3RyYW5zcG9ydCxcbiAgeGhyc3RyZWFtaW5ndHJhbnNwb3J0XG5dKTtcblxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxuX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgcHJvY2VzcykgeyhmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSkpXG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnBhcnNlKHV0ZjE2U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IExFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICBDX2VuYy5VdGYxNkxFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuICgod29yZCA8PCA4KSAmIDB4ZmYwMGZmMDApIHwgKCh3b3JkID4+PiA4KSAmIDB4MDBmZjAwZmYpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGYxNjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMzEpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXg7XG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcblxuXHQgICAgdmFyIEhleEZvcm1hdHRlciA9IENfZm9ybWF0LkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0OSksIF9fd2VicGFja19yZXF1aXJlX18oMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIExvb2t1cCB0YWJsZXNcblx0ICAgIHZhciBTQk9YID0gW107XG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuXHQgICAgICAgIHZhciBkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2FsayBHRigyXjgpXG5cdCAgICAgICAgdmFyIHggPSAwO1xuXHQgICAgICAgIHZhciB4aSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG5cdCAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2Mztcblx0ICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcblx0ICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG5cdCAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXHQgICAgICAgICAgICBpZiAoIXgpIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuXHQgICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXHQgICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdDtcblxuXHQgICAgICAgICAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgVCA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcblxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLmpzICsgMSBtb2R1bGVzXG52YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvYXV0aC5qcyArIDEgbW9kdWxlc1xudmFyIGF1dGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2RldmljZWRldGFpbHMuanNcblxuXG52YXIgZGV2aWNlZGV0YWlsc19EZXZpY2VEZXRhaWxzID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIERldmljZURldGFpbHMoKSB7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRldmljZVNlY3JldCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnBsYXRmb3JtID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZm9ybUZhY3RvciA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kZXZpY2VJZGVudGl0eVRva2VuID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucHVzaCA9IHtcblx0XHRcdHJlY2lwaWVudDogdW5kZWZpbmVkLFxuXHRcdFx0c3RhdGU6IHVuZGVmaW5lZCxcblx0XHRcdGVycm9yOiB1bmRlZmluZWRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHREZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aWQ6IHRoaXMuaWQsXG5cdFx0XHRkZXZpY2VTZWNyZXQ6IHRoaXMuZGV2aWNlU2VjcmV0LFxuXHRcdFx0cGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG5cdFx0XHRmb3JtRmFjdG9yOiB0aGlzLmZvcm1GYWN0b3IsXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuXHRcdFx0ZGV2aWNlSWRlbnRpdHlUb2tlbjogdGhpcy5kZXZpY2VJZGVudGl0eVRva2VuLFxuXHRcdFx0cHVzaDoge1xuXHRcdFx0XHRyZWNpcGllbnQ6IHRoaXMucHVzaC5yZWNpcGllbnQsXG5cdFx0XHRcdHN0YXRlOiB0aGlzLnB1c2guc3RhdGUsXG5cdFx0XHRcdGVycm9yOiB0aGlzLnB1c2guZXJyb3Jcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdERldmljZURldGFpbHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbRGV2aWNlRGV0YWlscyc7XG5cdFx0aWYodGhpcy5pZClcblx0XHRcdHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcblx0XHRpZih0aGlzLnBsYXRmb3JtKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHBsYXRmb3JtPScgKyB0aGlzLnBsYXRmb3JtO1xuXHRcdGlmKHRoaXMuZm9ybUZhY3Rvcilcblx0XHRcdHJlc3VsdCArPSAnOyBmb3JtRmFjdG9yPScgKyB0aGlzLmZvcm1GYWN0b3I7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLm1ldGFkYXRhKVxuXHRcdFx0cmVzdWx0ICs9ICc7IG1ldGFkYXRhPScgKyB0aGlzLm1ldGFkYXRhO1xuXHRcdGlmKHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbilcblx0XHRcdHJlc3VsdCArPSAnOyBkZXZpY2VJZGVudGl0eVRva2VuPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuXHRcdGlmKHRoaXMucHVzaC5yZWNpcGllbnQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5yZWNpcGllbnQ9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5yZWNpcGllbnQpO1xuXHRcdGlmKHRoaXMucHVzaC5zdGF0ZSlcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLnN0YXRlPScgKyB0aGlzLnB1c2guc3RhdGU7XG5cdFx0aWYodGhpcy5wdXNoLmVycm9yKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2guZXJyb3I9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5lcnJvcik7XG5cdFx0aWYodGhpcy5wdXNoLm1ldGFkYXRhKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2gubWV0YWRhdGE9JyArIHRoaXMucHVzaC5tZXRhZGF0YTtcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0RGV2aWNlRGV0YWlscy50b1JlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShib2R5KSkge1xuXHRcdFx0cmV0dXJuIERldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKGJvZHkpO1xuXHRcdH1cblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YWx1ZXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXModmFsdWVzLmVycm9yKTsgXG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKG5ldyBEZXZpY2VEZXRhaWxzKCksIHZhbHVlcyk7XG5cdH07XG5cblx0RGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJldHVybiBEZXZpY2VEZXRhaWxzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGV2aWNlZGV0YWlscyA9IChkZXZpY2VkZXRhaWxzX0RldmljZURldGFpbHMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9odHRwLmpzXG52YXIgaHR0cCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXG52YXIgYnVmZmVydXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3Jlc291cmNlLmpzXG5cblxuXG5cblxuXG5cbnZhciByZXNvdXJjZV9SZXNvdXJjZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gUmVzb3VyY2UoKSB7fVxuXG5cdGZ1bmN0aW9uIHdpdGhBdXRoRGV0YWlscyhyZXN0LCBoZWFkZXJzLCBwYXJhbXMsIGVyckNhbGxiYWNrLCBvcENhbGxiYWNrKSB7XG5cdFx0aWYgKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNBdXRoSGVhZGVycykge1xuXHRcdFx0cmVzdC5hdXRoLmdldEF1dGhIZWFkZXJzKGZ1bmN0aW9uKGVyciwgYXV0aEhlYWRlcnMpIHtcblx0XHRcdFx0aWYoZXJyKVxuXHRcdFx0XHRcdGVyckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRvcENhbGxiYWNrKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGF1dGhIZWFkZXJzLCBoZWFkZXJzKSwgcGFyYW1zKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN0LmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdFx0aWYoZXJyKVxuXHRcdFx0XHRcdGVyckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRvcENhbGxiYWNrKGhlYWRlcnMsIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGF1dGhQYXJhbXMsIHBhcmFtcykpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdW5lbnZlbG9wZShjYWxsYmFjaywgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB1bnBhY2tlZCwgb3V0ZXJTdGF0dXNDb2RlKSB7XG5cdFx0XHRpZihlcnIgJiYgIWJvZHkpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighdW5wYWNrZWQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoYm9keS5zdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0LyogRW52ZWxvcGUgYWxyZWFkeSB1bndyYXBwZWQgYnkgdGhlIHRyYW5zcG9ydCAqL1xuXHRcdFx0XHRjYWxsYmFjayhlcnIsIGJvZHksIG91dGVySGVhZGVycywgdHJ1ZSwgb3V0ZXJTdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgd3JhcHBlZFN0YXR1c0NvZGUgPSBib2R5LnN0YXR1c0NvZGUsXG5cdFx0XHRcdHJlc3BvbnNlID0gYm9keS5yZXNwb25zZSxcblx0XHRcdFx0d3JhcHBlZEhlYWRlcnMgPSBib2R5LmhlYWRlcnM7XG5cblx0XHRcdGlmKHdyYXBwZWRTdGF0dXNDb2RlIDwgMjAwIHx8IHdyYXBwZWRTdGF0dXNDb2RlID49IDMwMCkge1xuXHRcdFx0XHQvKiBoYW5kbGUgd3JhcHBlZCBlcnJvcnMgKi9cblx0XHRcdFx0dmFyIHdyYXBwZWRFcnIgPSAocmVzcG9uc2UgJiYgcmVzcG9uc2UuZXJyb3IpIHx8IGVycjtcblx0XHRcdFx0aWYoIXdyYXBwZWRFcnIpIHtcblx0XHRcdFx0XHR3cmFwcGVkRXJyID0gbmV3IEVycm9yKFwiRXJyb3IgaW4gdW5lbnZlbG9waW5nIFwiICsgYm9keSk7XG5cdFx0XHRcdFx0d3JhcHBlZEVyci5zdGF0dXNDb2RlID0gd3JhcHBlZFN0YXR1c0NvZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sod3JhcHBlZEVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2soZXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyYW1TdHJpbmcocGFyYW1zKSB7XG5cdFx0dmFyIHBhcmFtUGFpcnMgPSBbXTtcblx0XHRpZiAocGFyYW1zKSB7XG5cdFx0XHRmb3IgKHZhciBuZWVkbGUgaW4gcGFyYW1zKSB7XG5cdFx0XHRcdHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyAnPScgKyBwYXJhbXNbbmVlZGxlXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbVBhaXJzLmpvaW4oJyYnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykge1xuXHRcdHJldHVybiBwYXRoICsgKHBhcmFtcyA/ICc/JyA6ICcnKSArIHBhcmFtU3RyaW5nKHBhcmFtcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2dSZXNwb25zZUhhbmRsZXIoY2FsbGJhY2ssIG1ldGhvZCwgcGF0aCwgcGFyYW1zKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdSZWNlaXZlZCBFcnJvcjsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBFcnJvcjogJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLFxuXHRcdFx0XHRcdCdSZWNlaXZlZDsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBIZWFkZXJzOiAnICsgcGFyYW1TdHJpbmcoaGVhZGVycykgKyAnOyBTdGF0dXNDb2RlOiAnICsgc3RhdHVzQ29kZSArICc7IEJvZHk6ICcgKyAoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNCdWZmZXIoYm9keSkgPyBib2R5LnRvU3RyaW5nKCkgOiBib2R5KSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7IH1cblx0XHR9XG5cdH1cblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhvdXRCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRSZXNvdXJjZVttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuXHRcdFx0UmVzb3VyY2VbJ2RvJ10obWV0aG9kLCByZXN0LCBwYXRoLCBudWxsLCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9KTtcblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRSZXNvdXJjZVttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgYm9keSwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuXHRcdFx0UmVzb3VyY2VbJ2RvJ10obWV0aG9kLCByZXN0LCBwYXRoLCBib2R5LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9KTtcblxuXHRSZXNvdXJjZVsnZG8nXSA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgcGF0aCwgYm9keSwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuXHRcdGlmIChsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2hvdWxkTG9nKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRjYWxsYmFjayA9IGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBvcmlncGFyYW1zKTtcblx0XHR9XG5cblx0XHRpZihlbnZlbG9wZSkge1xuXHRcdFx0Y2FsbGJhY2sgPSAoY2FsbGJhY2sgJiYgdW5lbnZlbG9wZShjYWxsYmFjaywgZW52ZWxvcGUpKTtcblx0XHRcdChvcmlncGFyYW1zID0gKG9yaWdwYXJhbXMgfHwge30pKVsnZW52ZWxvcGUnXSA9IGVudmVsb3BlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzLCBwYXJhbXMpIHtcblx0XHRcdGlmIChsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2hvdWxkTG9nKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZzsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYXJncyA9IFtyZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRpZihlcnIgJiYgYXV0aFtcImFcIiAvKiBkZWZhdWx0ICovXS5pc1Rva2VuRXJyKGVycikpIHtcblx0XHRcdFx0XHQvKiB0b2tlbiBoYXMgZXhwaXJlZCwgc28gZ2V0IGEgbmV3IG9uZSAqL1xuXHRcdFx0XHRcdHJlc3QuYXV0aC5hdXRob3JpemUobnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LyogcmV0cnkgLi4uICovXG5cdFx0XHRcdFx0XHR3aXRoQXV0aERldGFpbHMocmVzdCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGNhbGxiYWNrLCBkb1JlcXVlc3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuXHRcdFx0fV07XG5cdFx0XHRpZiAoIWJvZHkpIHtcblx0XHRcdFx0YXJncy5zcGxpY2UoMywgMSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2hvdWxkTG9nKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8pKSB7XG5cdFx0XHRcdHZhciBkZWNvZGVkQm9keSA9IGJvZHk7XG5cdFx0XHRcdGlmICgoaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgJycpLmluZGV4T2YoJ21zZ3BhY2snKSA+IDApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZGVjb2RlZEJvZHkgPSBtc2dwYWNrLmRlY29kZShib2R5KTtcblx0XHRcdFx0XHR9IGNhdGNoIChkZWNvZGVFcnIpIHtcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGRlY29kZUVycikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgQm9keTogJyArIGRlY29kZWRCb2R5KTtcblx0XHRcdH1cblx0XHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL11bbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cblx0XHR3aXRoQXV0aERldGFpbHMocmVzdCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGNhbGxiYWNrLCBkb1JlcXVlc3QpO1xuXHR9O1xuXG5cdHJldHVybiBSZXNvdXJjZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9yZXNvdXJjZSA9IChyZXNvdXJjZV9SZXNvdXJjZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcGFnaW5hdGVkcmVzb3VyY2UuanNcblxuXG5cblxuXG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfUGFnaW5hdGVkUmVzb3VyY2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcblx0XHR2YXIgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcblx0XHRyZXR1cm4gdXJsTWF0Y2ggJiYgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucGFyc2VRdWVyeVN0cmluZyh1cmxNYXRjaFsyXSk7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpIHtcblx0XHRpZih0eXBlb2YobGlua0hlYWRlcikgPT0gJ3N0cmluZycpXG5cdFx0XHRsaW5rSGVhZGVyID0gbGlua0hlYWRlci5zcGxpdCgnLCcpO1xuXG5cdFx0dmFyIHJlbFBhcmFtcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsaW5rSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbGlua01hdGNoID0gbGlua0hlYWRlcltpXS5tYXRjaCgvXlxccyo8KC4rKT47XFxzKnJlbD1cIihcXHcrKVwiJC8pO1xuXHRcdFx0aWYobGlua01hdGNoKSB7XG5cdFx0XHRcdHZhciBwYXJhbXMgPSBnZXRSZWxQYXJhbXMobGlua01hdGNoWzFdKTtcblx0XHRcdFx0aWYocGFyYW1zKVxuXHRcdFx0XHRcdHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVsUGFyYW1zO1xuXHR9XG5cblx0ZnVuY3Rpb24gUGFnaW5hdGVkUmVzb3VyY2UocmVzdCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR0aGlzLmVudmVsb3BlID0gZW52ZWxvcGU7XG5cdFx0dGhpcy5ib2R5SGFuZGxlciA9IGJvZHlIYW5kbGVyO1xuXHRcdHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xuXHR9XG5cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0UGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRjbGllbnRfcmVzb3VyY2VbbWV0aG9kXShzZWxmLnJlc3QsIHNlbGYucGF0aCwgc2VsZi5oZWFkZXJzLCBwYXJhbXMsIHNlbGYuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdFx0c2VsZi5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pXG5cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0UGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRjbGllbnRfcmVzb3VyY2VbbWV0aG9kXShzZWxmLnJlc3QsIHNlbGYucGF0aCwgYm9keSwgc2VsZi5oZWFkZXJzLCBwYXJhbXMsIHNlbGYuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgcmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRzZWxmLmhhbmRsZVBhZ2UoZXJyLCByZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblxuXHRmdW5jdGlvbiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdXNlSFBSKSB7XG5cdFx0LyogSWYgdXNpbmcgaHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBlcnJvcnMgZnJvbSBBYmx5IGFyZSByZXR1cm5lZCBhcyBwYXJ0IG9mXG5cdFx0ICogdGhlIEhQUiwgb25seSBkbyBjYWxsYmFjayhlcnIpIGZvciBuZXR3b3JrIGVycm9ycyBldGMuIHdoaWNoIGRvbid0XG5cdFx0ICogcmV0dXJuIGEgYm9keSBhbmQvb3IgaGF2ZSBubyBhYmx5LW9yaWdpbmF0ZWQgZXJyb3IgY29kZSAobm9uLW51bWVyaWNcblx0XHQgKiBlcnJvciBjb2RlcyBvcmlnaW5hdGUgZnJvbSBub2RlKSAqL1xuXHRcdHJldHVybiAhKHVzZUhQUiAmJiAoYm9keSB8fCB0eXBlb2YgZXJyLmNvZGUgPT09ICdudW1iZXInKSk7XG5cdH1cblxuXHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUuaGFuZGxlUGFnZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYoZXJyICYmIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1BhZ2luYXRlZFJlc291cmNlLmhhbmRsZVBhZ2UoKScsICdVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgcmVzb3VyY2U6IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgaXRlbXMsIGxpbmtIZWFkZXIsIHJlbFBhcmFtcztcblx0XHR0cnkge1xuXHRcdFx0aXRlbXMgPSB0aGlzLmJvZHlIYW5kbGVyKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdC8qIElmIHdlIGdvdCBhbiBlcnJvciwgdGhlIGZhaWx1cmUgdG8gcGFyc2UgdGhlIGJvZHkgaXMgYWxtb3N0IGNlcnRhaW5seVxuXHRcdFx0ICogZHVlIHRvIHRoYXQsIHNvIGNiIHdpdGggdGhhdCBpbiBwcmVmZXJlbmNlIHRvIHRoZSBwYXJzZSBlcnJvciAqL1xuXHRcdFx0Y2FsbGJhY2soZXJyIHx8IGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKGhlYWRlcnMgJiYgKGxpbmtIZWFkZXIgPSAoaGVhZGVyc1snTGluayddIHx8IGhlYWRlcnNbJ2xpbmsnXSkpKSB7XG5cdFx0XHRyZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBuZXcgSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHRoaXMsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBuZXcgUGFnaW5hdGVkUmVzdWx0KHRoaXMsIGl0ZW1zLCByZWxQYXJhbXMpKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gUGFnaW5hdGVkUmVzdWx0KHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKSB7XG5cdFx0dGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuXHRcdHRoaXMuaXRlbXMgPSBpdGVtcztcblxuXHRcdGlmKHJlbFBhcmFtcykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYoJ2ZpcnN0JyBpbiByZWxQYXJhbXMpIHtcblx0XHRcdFx0dGhpcy5maXJzdCA9IGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0aWYoIWNiICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICdmaXJzdCcsIFtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5nZXQocmVsUGFyYW1zLmZpcnN0LCBjYik7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZignY3VycmVudCcgaW4gcmVsUGFyYW1zKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdFx0aWYoIWNiICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICdjdXJyZW50JywgW10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMuY3VycmVudCwgY2IpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5uZXh0ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0aWYoIWNiICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeShzZWxmLCAnbmV4dCcsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZignbmV4dCcgaW4gcmVsUGFyYW1zKSB7XG5cdFx0XHRcdFx0c2VsZi5nZXQocmVsUGFyYW1zLm5leHQsIGNiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYihudWxsLCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7IHJldHVybiAoJ25leHQnIGluIHJlbFBhcmFtcykgfTtcblx0XHRcdHRoaXMuaXNMYXN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiAhdGhpcy5oYXNOZXh0KCk7IH1cblx0XHR9XG5cdH1cblxuXHQvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXG5cdCAqIHRoZSByZXN0IG9mIGEgbXVsdGlwYWdlIHNldCBvZiByZXN1bHRzIGNhbiBhbHdheXMgYmUgZG9uZSB3aXRoIEdFVCAqL1xuXHRQYWdpbmF0ZWRSZXN1bHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzID0gdGhpcy5yZXNvdXJjZTtcblx0XHRjbGllbnRfcmVzb3VyY2UuZ2V0KHJlcy5yZXN0LCByZXMucGF0aCwgcmVzLmhlYWRlcnMsIHBhcmFtcywgcmVzLmVudmVsb3BlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRyZXMuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcblx0XHRQYWdpbmF0ZWRSZXN1bHQuY2FsbCh0aGlzLCByZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcyk7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0XHR0aGlzLnN1Y2Nlc3MgPSBzdGF0dXNDb2RlIDwgMzAwICYmIHN0YXR1c0NvZGUgPj0gMjAwO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0dGhpcy5lcnJvckNvZGUgPSBlcnIgJiYgZXJyLmNvZGU7XG5cdFx0dGhpcy5lcnJvck1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoSHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBQYWdpbmF0ZWRSZXN1bHQpO1xuXG5cdHJldHVybiBQYWdpbmF0ZWRSZXNvdXJjZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBhZ2luYXRlZHJlc291cmNlID0gKHBhZ2luYXRlZHJlc291cmNlX1BhZ2luYXRlZFJlc291cmNlKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLmpzXG52YXIgZXJyb3JpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3B1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmpzXG5cblxudmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCkge1xuXHRcdHRoaXMuY2hhbm5lbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRldmljZUlkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xpZW50SWQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2hhbm5lbDogdGhpcy5jaGFubmVsLFxuXHRcdFx0ZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZFxuXHRcdH07XG5cdH07XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbUHVzaENoYW5uZWxTdWJzY3JpcHRpb24nO1xuXHRcdGlmKHRoaXMuY2hhbm5lbClcblx0XHRcdHJlc3VsdCArPSAnOyBjaGFubmVsPScgKyB0aGlzLmNoYW5uZWw7XG5cdFx0aWYodGhpcy5kZXZpY2VJZClcblx0XHRcdHJlc3VsdCArPSAnOyBkZXZpY2VJZD0nICsgdGhpcy5kZXZpY2VJZDtcblx0XHRpZih0aGlzLmNsaWVudElkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi50b1JlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XG5cdFx0aWYoZm9ybWF0KSB7XG5cdFx0XHRib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdH1cblxuXHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoYm9keSkpIHtcblx0XHRcdHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKGJvZHkpO1xuXHRcdH1cblx0fTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKG5ldyBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uID0gKHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9wdXNoLmpzXG5cblxuXG5cblxuXG5cblxudmFyIHB1c2hfUHVzaCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIFB1c2gocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5hZG1pbiA9IG5ldyBBZG1pbihyZXN0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIEFkbWluKHJlc3QpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHRcdHRoaXMuZGV2aWNlUmVnaXN0cmF0aW9ucyA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25zKHJlc3QpO1xuXHRcdHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCk7XG5cdH1cblxuXHRBZG1pbi5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKHJlY2lwaWVudCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdDtcblx0XHR2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7cmVjaXBpZW50OiByZWNpcGllbnR9LCBwYXlsb2FkKSxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHkocmVxdWVzdEJvZHksIGZvcm1hdCk7XG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QocmVzdCwgJy9wdXNoL3B1Ymxpc2gnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdH1cblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oZGV2aWNlLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IGRldmljZWRldGFpbHMuZnJvbVZhbHVlcyhkZXZpY2UpLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge307XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3NhdmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keShyZXF1ZXN0Qm9keSwgZm9ybWF0KTtcblx0XHRjbGllbnRfcmVzb3VyY2UucHV0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlLmlkKSwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNnZXQgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0Y2xpZW50X3Jlc291cmNlLmdldChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywge30sIGZhbHNlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRjYWxsYmFjayhlcnIsICFlcnIgJiYgZGV2aWNlZGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpKTtcblx0XHR9KTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gZGV2aWNlZGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdHBhcmFtcyA9IHt9LFxuXHRcdFx0ZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgZGV2aWNlSWQgIT09ICdzdHJpbmcnIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjcmVtb3ZlIG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2VbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG5cdH07XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlV2hlcmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdGNsaWVudF9yZXNvdXJjZVsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdH1cblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbiwgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdDtcblx0XHR2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0cmVxdWVzdEJvZHkgPSBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbiksXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRwYXJhbXMgPSB7fTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5wb3N0KHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRjYWxsYmFjayhlcnIsICFlcnIgJiYgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24uZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24uZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0Y2xpZW50X3Jlc291cmNlWydkZWxldGUnXShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG5cdH07XG5cblx0LyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmUgPSBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmU7XG5cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3RDaGFubmVscyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xpc3RDaGFubmVscycsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCAnL3B1c2gvY2hhbm5lbHMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHZhciBmID0gIXVucGFja2VkICYmIGZvcm1hdDtcblxuXHRcdFx0aWYoZikge1xuXHRcdFx0XHRib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRib2R5W2ldID0gU3RyaW5nKGJvZHlbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvZHk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRyZXR1cm4gUHVzaDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHB1c2ggPSAocHVzaF9QdXNoKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9ldmVudGVtaXR0ZXIuanNcbnZhciBldmVudGVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9wcmVzZW5jZW1lc3NhZ2UuanNcbnZhciBwcmVzZW5jZW1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9wcmVzZW5jZS5qc1xuXG5cblxuXG5cblxuXG52YXIgcHJlc2VuY2VfUHJlc2VuY2UgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRmdW5jdGlvbiBQcmVzZW5jZShjaGFubmVsKSB7XG5cdFx0dGhpcy5jaGFubmVsID0gY2hhbm5lbDtcblx0XHR0aGlzLmJhc2VQYXRoID0gY2hhbm5lbC5iYXNlUGF0aCArICcvcHJlc2VuY2UnO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFByZXNlbmNlLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2UuZ2V0KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHJlc3QgPSB0aGlzLmNoYW5uZWwucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgdGhpcy5iYXNlUGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSk7XG5cdFx0dGhpcy5faGlzdG9yeShwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRQcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdfaGlzdG9yeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsLmNoYW5uZWxPcHRpb25zO1xuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgdGhpcy5iYXNlUGF0aCArICcvaGlzdG9yeScsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0cmV0dXJuIFByZXNlbmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3ByZXNlbmNlID0gKHByZXNlbmNlX1ByZXNlbmNlKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvY3J5cHRvLmpzXG52YXIgdXRpbF9jcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS5qc1xudmFyIHR5cGVzX21lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2NoYW5uZWwuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2hhbm5lbF9DaGFubmVsID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBub29wKCkge31cblx0dmFyIE1TR19JRF9FTlRST1BZX0JZVEVTID0gOTtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ2hhbm5lbChyZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0NoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuXHRcdGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmJhc2VQYXRoID0gJy9jaGFubmVscy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgY2xpZW50X3ByZXNlbmNlKHRoaXMpO1xuXHRcdHRoaXMuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoQ2hhbm5lbCwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZihvcHRpb25zLmNpcGhlcikge1xuXHRcdFx0aWYoIXV0aWxfY3J5cHRvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuXHRcdFx0dmFyIGNpcGhlciA9IHV0aWxfY3J5cHRvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldENpcGhlcihvcHRpb25zLmNpcGhlcik7XG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XG5cdFx0XHRvcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBjaXBoZXIuY2lwaGVyO1xuXHRcdH0gZWxzZSBpZignY2lwaGVyJyBpbiBvcHRpb25zKSB7XG5cdFx0XHQvKiBEb24ndCBkZWFjdGl2YXRlIGFuIGV4aXN0aW5nIGNpcGhlciB1bmxlc3Mgb3B0aW9uc1xuXHRcdFx0ICogaGFzIGEgJ2NpcGhlcicga2V5IHRoYXQncyBmYWxzZXkgKi9cblx0XHRcdG9wdGlvbnMuY2lwaGVyID0gbnVsbDtcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWwucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQ2hhbm5lbC5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdENoYW5uZWwucHJvdG90eXBlLl9oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdGNoYW5uZWwgPSB0aGlzO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSB7XG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckV2ZXJ5KG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0XHRyZXR1cm4gIW1lc3NhZ2UuaWQ7XG5cdFx0fSk7XG5cdH1cblxuXHRDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdGZpcnN0ID0gYXJndW1lbnRzWzBdLFxuXHRcdFx0c2Vjb25kID0gYXJndW1lbnRzWzFdLFxuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbYXJnQ291bnQgLSAxXSxcblx0XHRcdG1lc3NhZ2VzLFxuXHRcdFx0cGFyYW1zLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZih0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IGZpcnN0ID09PSBudWxsKSB7XG5cdFx0XHQvKiAobmFtZSwgZGF0YSwgLi4uKSAqL1xuXHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtuYW1lOiBmaXJzdCwgZGF0YTogc2Vjb25kfSldO1xuXHRcdFx0cGFyYW1zID0gYXJndW1lbnRzWzJdO1xuXHRcdH0gZWxzZSBpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc09iamVjdChmaXJzdCkpIHtcblx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhmaXJzdCldO1xuXHRcdFx0cGFyYW1zID0gYXJndW1lbnRzWzFdO1xuXHRcdH0gZWxzZSBpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KGZpcnN0KSkge1xuXHRcdFx0bWVzc2FnZXMgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXNBcnJheShmaXJzdCk7XG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1RoZSBzaW5nbGUtYXJndW1lbnQgZm9ybSBvZiBwdWJsaXNoKCkgZXhwZWN0cyBhIG1lc3NhZ2Ugb2JqZWN0IG9yIGFuIGFycmF5IG9mIG1lc3NhZ2Ugb2JqZWN0cycsIDQwMDEzLCA0MDApO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnIHx8ICFwYXJhbXMpIHtcblx0XHRcdC8qIE5vIHBhcmFtcyBzdXBwbGllZCAoc28gYWZ0ZXItbWVzc2FnZSBhcmd1bWVudCBpcyBqdXN0IHRoZSBjYWxsYmFjayBvciB1bmRlZmluZWQpICovXG5cdFx0XHRwYXJhbXMgPSB7fTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdG9wdGlvbnMgPSByZXN0Lm9wdGlvbnMsXG5cdFx0XHRmb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gcmVzdC5vcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKG9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgJiYgYWxsRW1wdHlJZHMobWVzc2FnZXMpKSB7XG5cdFx0XHR2YXIgbXNnSWRCYXNlID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucmFuZG9tU3RyaW5nKE1TR19JRF9FTlRST1BZX0JZVEVTKTtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG5cdFx0XHRcdG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2UgKyAnOicgKyBpbmRleC50b1N0cmluZygpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBSU0wxaSAqL1xuXHRcdFx0dmFyIHNpemUgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyksXG5cdFx0XHRcdG1heE1lc3NhZ2VTaXplID0gb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcblx0XHRcdGlmKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArIHNpemUgKyAnIGJ5dGVzOyBsaW1pdCBpcyAnICsgbWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLl9wdWJsaXNoKHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uc2VyaWFsaXplKG1lc3NhZ2VzLCBmb3JtYXQpLCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5fcHVibGlzaCA9IGZ1bmN0aW9uKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QodGhpcy5yZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBjYWxsYmFjayk7XG5cdH07XG5cblx0cmV0dXJuIENoYW5uZWw7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfY2hhbm5lbCA9IChjaGFubmVsX0NoYW5uZWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvc3RhdHMuanNcblxuXG52YXIgc3RhdHNfU3RhdHMgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gTWVzc2FnZUNvdW50KHZhbHVlcykge1xuXHRcdHRoaXMuY291bnQgPSAodmFsdWVzICYmIHZhbHVlcy5jb3VudCkgfHwgMDtcblx0XHR0aGlzLmRhdGEgPSAodmFsdWVzICYmIHZhbHVlcy5kYXRhKSB8fCAwO1xuXHRcdHRoaXMudW5jb21wcmVzc2VkRGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuY29tcHJlc3NlZERhdGEpIHx8IDA7XG5cdFx0dGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0TWVzc2FnZUNvdW50LmNhbGwodGhpcywgdmFsdWVzKTtcblx0XHR0aGlzLmNhdGVnb3J5ID0gdW5kZWZpbmVkO1xuXHRcdGlmICh2YWx1ZXMgJiYgdmFsdWVzLmNhdGVnb3J5KSB7XG5cdFx0XHR0aGlzLmNhdGVnb3J5ID0geyB9O1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZm9ySW5Pd25Ob25OdWxsUHJvcHModmFsdWVzLmNhdGVnb3J5LCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdHNlbGYuY2F0ZWdvcnlbcHJvcF0gPSBuZXcgTWVzc2FnZUNvdW50KHZhbHVlcy5jYXRlZ29yeVtwcm9wXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBSZXNvdXJjZUNvdW50KHZhbHVlcykge1xuXHRcdHRoaXMucGVhayA9ICh2YWx1ZXMgJiYgdmFsdWVzLnBlYWspIHx8IDA7XG5cdFx0dGhpcy5taW4gPSAodmFsdWVzICYmIHZhbHVlcy5taW4pIHx8IDA7XG5cdFx0dGhpcy5tZWFuID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVhbikgfHwgMDtcblx0XHR0aGlzLm9wZW5lZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLm9wZW5lZCkgfHwgMDtcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUmVxdWVzdENvdW50KHZhbHVlcykge1xuXHRcdHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBDb25uZWN0aW9uVHlwZXModmFsdWVzKSB7XG5cdFx0dGhpcy5wbGFpbiA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucGxhaW4pO1xuXHRcdHRoaXMudGxzID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy50bHMpO1xuXHRcdHRoaXMuYWxsID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZVR5cGVzKHZhbHVlcykge1xuXHRcdHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMucHJlc2VuY2UpO1xuXHRcdHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMpIHtcblx0XHR0aGlzLnJlYWx0aW1lID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlYWx0aW1lKTtcblx0XHR0aGlzLnJlc3QgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVzdCk7XG5cdFx0dGhpcy53ZWJob29rID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLndlYmhvb2spO1xuXHRcdHRoaXMuc2hhcmVkUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuc2hhcmVkUXVldWUpO1xuXHRcdHRoaXMuZXh0ZXJuYWxRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5leHRlcm5hbFF1ZXVlKTtcblx0XHR0aGlzLmh0dHBFdmVudCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5odHRwRXZlbnQpO1xuXHRcdHRoaXMucHVzaCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wdXNoKTtcblx0XHR0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZURpcmVjdGlvbnModmFsdWVzKSB7XG5cdFx0dGhpcy5hbGwgICAgICAgICAgID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdFx0dGhpcy5pbmJvdW5kICAgICAgID0gbmV3IE1lc3NhZ2VUcmFmZmljKHZhbHVlcyAmJiB2YWx1ZXMuaW5ib3VuZCk7XG5cdFx0dGhpcy5vdXRib3VuZCAgICAgID0gbmV3IE1lc3NhZ2VUcmFmZmljKHZhbHVlcyAmJiB2YWx1ZXMub3V0Ym91bmQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gWGNoZ01lc3NhZ2VzKHZhbHVlcykge1xuXHRcdHRoaXMuYWxsICAgICAgICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHRcdHRoaXMucHJvZHVjZXJQYWlkICA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLnByb2R1Y2VyUGFpZCk7XG5cdFx0dGhpcy5jb25zdW1lclBhaWQgID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3VtZXJQYWlkKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFB1c2hTdGF0cyh2YWx1ZXMpIHtcblx0XHR0aGlzLm1lc3NhZ2VzID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpIHx8IDA7XG5cdFx0dmFyIG5vdGlmaWNhdGlvbnMgPSB2YWx1ZXMgJiYgdmFsdWVzLm5vdGlmaWNhdGlvbnM7XG5cdFx0dGhpcy5ub3RpZmljYXRpb25zID0ge1xuXHRcdFx0aW52YWxpZDogbm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmludmFsaWQgfHwgMCxcblx0XHRcdGF0dGVtcHRlZDogbm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmF0dGVtcHRlZCB8fCAwLFxuXHRcdFx0c3VjY2Vzc2Z1bDogbm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLnN1Y2Nlc3NmdWwgfHwgMCxcblx0XHRcdGZhaWxlZDogbm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmZhaWxlZCB8fCAwXG5cdFx0fTtcblx0XHR0aGlzLmRpcmVjdFB1Ymxpc2hlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRpcmVjdFB1Ymxpc2hlcykgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb2Nlc3NlZENvdW50KHZhbHVlcykge1xuXHRcdHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuXHRcdHRoaXMuc2tpcHBlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnNraXBwZWQpIHx8IDA7XG5cdFx0dGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5kZWx0YSA9IHVuZGVmaW5lZDtcblx0XHRpZiAodmFsdWVzICYmIHZhbHVlcy5kZWx0YSkge1xuXHRcdFx0dGhpcy5kZWx0YSA9IHsgfTtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZvckluT3duTm9uTnVsbFByb3BzKHZhbHVlcy5kZWx0YSwgZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRzZWxmLmRlbHRhW3Byb3BdID0gbmV3IFByb2Nlc3NlZENvdW50KHZhbHVlcy5kZWx0YVtwcm9wXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBTdGF0cyh2YWx1ZXMpIHtcblx0XHRNZXNzYWdlRGlyZWN0aW9ucy5jYWxsKHRoaXMsIHZhbHVlcyk7XG5cdFx0dGhpcy5wZXJzaXN0ZWQgICAgID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnBlcnNpc3RlZCk7XG5cdFx0dGhpcy5jb25uZWN0aW9ucyAgID0gbmV3IENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmNvbm5lY3Rpb25zKTtcblx0XHR0aGlzLmNoYW5uZWxzICAgICAgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmNoYW5uZWxzKTtcblx0XHR0aGlzLmFwaVJlcXVlc3RzICAgPSBuZXcgUmVxdWVzdENvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYXBpUmVxdWVzdHMpO1xuXHRcdHRoaXMudG9rZW5SZXF1ZXN0cyA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy50b2tlblJlcXVlc3RzKTtcblx0XHR0aGlzLnhjaGdQcm9kdWNlciAgPSBuZXcgWGNoZ01lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMueGNoZ1Byb2R1Y2VyKTtcblx0XHR0aGlzLnhjaGdDb25zdW1lciAgPSBuZXcgWGNoZ01lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMueGNoZ0NvbnN1bWVyKTtcblx0XHR0aGlzLnB1c2ggICAgICAgICAgPSBuZXcgUHVzaFN0YXRzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaFN0YXRzKTtcblx0XHR0aGlzLnByb2Nlc3NlZCAgICAgPSBuZXcgUHJvY2Vzc2VkTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy5wcm9jZXNzZWQpO1xuXHRcdHRoaXMuaW5Qcm9ncmVzcyAgICA9ICh2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MpIHx8IHVuZGVmaW5lZDtcblx0XHR0aGlzLnVuaXQgICAgICAgICAgPSAodmFsdWVzICYmIHZhbHVlcy51bml0KSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pbnRlcnZhbElkICAgID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW50ZXJ2YWxJZCkgfHwgdW5kZWZpbmVkO1xuXHR9XG5cblx0U3RhdHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiBuZXcgU3RhdHModmFsdWVzKTtcblx0fTtcblxuXHRyZXR1cm4gU3RhdHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdGF0cyA9IChzdGF0c19TdGF0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVzdC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJlc3RfUmVzdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgbXNncGFjayA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubXNncGFjaztcblxuXHRmdW5jdGlvbiBSZXN0KG9wdGlvbnMpIHtcblx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBSZXN0KSl7XG5cdFx0XHRyZXR1cm4gbmV3IFJlc3Qob3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Lyogbm9ybWFsaXNlIG9wdGlvbnMgKi9cblx0XHRpZighb3B0aW9ucykge1xuXHRcdFx0dmFyIG1zZyA9ICdubyBvcHRpb25zIHByb3ZpZGVkJztcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHR9XG5cdFx0b3B0aW9ucyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG5cblx0XHRpZihvcHRpb25zLmxvZykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNldExvZyhvcHRpb25zLmxvZy5sZXZlbCwgb3B0aW9ucy5sb2cuaGFuZGxlcik7XG5cdFx0fVxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc3QoKScsICdpbml0aWFsaXplZCB3aXRoIGNsaWVudE9wdGlvbnMgJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3Qob3B0aW9ucykpO1xuXG5cdFx0dGhpcy5vcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdC8qIHByb2Nlc3Mgb3B0aW9ucyAqL1xuXHRcdGlmKG9wdGlvbnMua2V5KSB7XG5cdFx0XHR2YXIga2V5TWF0Y2ggPSBvcHRpb25zLmtleS5tYXRjaCgvXihbXjpcXHNdKyk6KFteOi5cXHNdKykkLyk7XG5cdFx0XHRpZigha2V5TWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdpbnZhbGlkIGtleSBwYXJhbWV0ZXInO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMua2V5TmFtZSA9IGtleU1hdGNoWzFdO1xuXHRcdFx0b3B0aW9ucy5rZXlTZWNyZXQgPSBrZXlNYXRjaFsyXTtcblx0XHR9XG5cblx0XHRpZignY2xpZW50SWQnIGluIG9wdGlvbnMpIHtcblx0XHRcdGlmKCEodHlwZW9mKG9wdGlvbnMuY2xpZW50SWQpID09PSAnc3RyaW5nJyB8fCBvcHRpb25zLmNsaWVudElkID09PSBudWxsKSlcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuXHRcdFx0ZWxzZSBpZihvcHRpb25zLmNsaWVudElkID09PSAnKicpXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJywgNDAwMTIsIDQwMCk7XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVzdCgpJywgJ3N0YXJ0ZWQ7IHZlcnNpb24gPSAnICsgZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubGlic3RyaW5nKTtcblxuXHRcdHRoaXMuYmFzZVVyaSA9IHRoaXMuYXV0aG9yaXR5ID0gZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0SHR0cFNjaGVtZShvcHRpb25zKSArIGhvc3QgKyAnOicgKyBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRQb3J0KG9wdGlvbnMsIGZhbHNlKTsgfTtcblx0XHR0aGlzLl9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuXG5cdFx0dGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gbnVsbDtcblx0XHR0aGlzLmF1dGggPSBuZXcgYXV0aFtcImFcIiAvKiBkZWZhdWx0ICovXSh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMpO1xuXHRcdHRoaXMucHVzaCA9IG5ldyBwdXNoKHRoaXMpO1xuXHR9XG5cblx0UmVzdC5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N0YXRzJywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoKSxcblx0XHRcdGZvcm1hdCA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0O1xuXG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHRoaXMsICcvc3RhdHMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHZhciBzdGF0c1ZhbHVlcyA9ICh1bnBhY2tlZCA/IGJvZHkgOiBKU09OLnBhcnNlKGJvZHkpKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdGF0c1ZhbHVlcy5sZW5ndGg7IGkrKykgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0cy5mcm9tVmFsdWVzKHN0YXRzVmFsdWVzW2ldKTtcblx0XHRcdHJldHVybiBzdGF0c1ZhbHVlcztcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlc3QucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3RpbWUnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycygpO1xuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgdGltZVVyaSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIHNlbGYuYXV0aG9yaXR5KGhvc3QpICsgJy90aW1lJyB9O1xuXHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0KHRoaXMsIHRpbWVVcmksIGhlYWRlcnMsIHBhcmFtcywgZnVuY3Rpb24oZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXVucGFja2VkKSByZXMgPSBKU09OLnBhcnNlKHJlcyk7XG5cdFx0XHR2YXIgdGltZSA9IHJlc1swXTtcblx0XHRcdGlmKCF0aW1lKSB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3IgKHVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBHRVQgL3RpbWUpJyk7XG5cdFx0XHRcdGVyci5zdGF0dXNDb2RlID0gNTAwO1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBjYWxjdWxhdGUgdGltZSBvZmZzZXQgb25seSBvbmNlIGZvciB0aGlzIGRldmljZSBieSBhZGRpbmcgdG8gdGhlIHByb3RvdHlwZSAqL1xuXHRcdFx0c2VsZi5zZXJ2ZXJUaW1lT2Zmc2V0ID0gKHRpbWUgLSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3coKSk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0aW1lKTtcblx0XHR9KTtcblx0fTtcblxuXHRSZXN0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHVzZUJpbmFyeSA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCxcblx0XHRcdGVuY29kZXIgPSB1c2VCaW5hcnkgPyBtc2dwYWNrLmVuY29kZTogSlNPTi5zdHJpbmdpZnksXG5cdFx0XHRkZWNvZGVyID0gdXNlQmluYXJ5ID8gbXNncGFjay5kZWNvZGUgOiBKU09OLnBhcnNlLFxuXHRcdFx0Zm9ybWF0ID0gdXNlQmluYXJ5ID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXHRcdHZhciBoZWFkZXJzID0gbWV0aG9kID09ICdnZXQnID8gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSA6IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3QnLCBbbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnNdKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdGJvZHkgPSBlbmNvZGVyKGJvZHkpO1xuXHRcdH1cblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycykge1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuXHRcdH1cblx0XHRpZihjdXN0b21IZWFkZXJzKSB7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcblx0XHR9XG5cdFx0dmFyIHBhZ2luYXRlZFJlc291cmNlID0gbmV3IHBhZ2luYXRlZHJlc291cmNlKHRoaXMsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihyZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuc3VyZUFycmF5KHVucGFja2VkID8gcmVzYm9keSA6IGRlY29kZXIocmVzYm9keSkpO1xuXHRcdH0sIC8qIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZTogKi8gdHJ1ZSk7XG5cblx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4oaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzLCBtZXRob2QpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbnN1cHBvcnRlZCBtZXRob2QgJyArIG1ldGhvZCwgNDA1MDAsIDQwNSk7XG5cdFx0fVxuXG5cdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4oaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aEJvZHksIG1ldGhvZCkpIHtcblx0XHRcdHBhZ2luYXRlZFJlc291cmNlW21ldGhvZF0ocGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhZ2luYXRlZFJlc291cmNlW21ldGhvZF0ocGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlc3QucHJvdG90eXBlLnNldExvZyA9IGZ1bmN0aW9uKGxvZ09wdGlvbnMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XG5cdH07XG5cblx0ZnVuY3Rpb24gQ2hhbm5lbHMocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5hbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHR9XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHR0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgY2xpZW50X2NoYW5uZWwodGhpcy5yZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFubmVsO1xuXHR9O1xuXG5cdC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuXHQgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy5hbGxbU3RyaW5nKG5hbWUpXTtcblx0fTtcblxuXHRyZXR1cm4gUmVzdDtcbn0pKCk7XG5cbnJlc3RfUmVzdC5Qcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcblx0b3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG5cdHJldHVybiBuZXcgcmVzdF9SZXN0KG9wdGlvbnMpO1xufTtcblxucmVzdF9SZXN0LkNhbGxiYWNrcyA9IHJlc3RfUmVzdDtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3Jlc3QgPSAocmVzdF9SZXN0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2Nvbm5lY3Rpb25tYW5hZ2VyLmpzXG52YXIgY29ubmVjdGlvbm1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS5qc1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb24uanNcblxuXG5cblxuXG5cbnZhciBjb25uZWN0aW9uX0Nvbm5lY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDb25uZWN0aW9uKGFibHksIG9wdGlvbnMpIHtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLmFibHkgPSBhYmx5O1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10oYWJseSwgb3B0aW9ucyk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XG5cdFx0dGhpcy5rZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZWNvdmVyeUtleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQ7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgndXBkYXRlJywgc3RhdGVDaGFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoQ29ubmVjdGlvbiwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbGlzdGVuZXIpIHtcblx0XHRyZXR1cm4gZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10odW5kZWZpbmVkLCBzdGF0ZSkpO1xuXHR9XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmFibHkub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwaW5nJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKG51bGwsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY2xvc2UoKScsICdjb25uZWN0aW9uS2V5ID0gJyArIHRoaXMua2V5KTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjbG9zaW5nJ30pO1xuXHR9O1xuXG5cdHJldHVybiBDb25uZWN0aW9uO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29ubmVjdGlvbiA9IChjb25uZWN0aW9uX0Nvbm5lY3Rpb24pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2UuanNcbnZhciBwcm90b2NvbG1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbmVycm9yLmpzXG52YXIgY29ubmVjdGlvbmVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIuanNcbnZhciB1dGlsX211bHRpY2FzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbHN0YXRlY2hhbmdlLmpzXG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDaGFubmVsU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJlc3VtZWQsIHJlYXNvbikge1xuXHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHR0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuXHRcdGlmKGN1cnJlbnQgPT09ICdhdHRhY2hlZCcpIHRoaXMucmVzdW1lZCA9IHJlc3VtZWQ7XG5cdFx0aWYocmVhc29uKSB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcblx0fVxuXG5cdHJldHVybiBDaGFubmVsU3RhdGVDaGFuZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVsc3RhdGVjaGFuZ2UgPSAoQ2hhbm5lbFN0YXRlQ2hhbmdlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZXByZXNlbmNlLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJlYWx0aW1lcHJlc2VuY2VfUmVhbHRpbWVQcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIG1lbWJlcktleShpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uY2xpZW50SWQgKyAnOicgKyBpdGVtLmNvbm5lY3Rpb25JZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcblx0XHRyZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuXHRcdHZhciByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZTtcblx0XHQvKiBJZiBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgd2UgY2FuJ3QgYXNzdW1lIHRoYXQgd2UncmUgYW4gYW5vbnltb3VzXG5cdFx0ICogY2xpZW50LCBhcyByZWFsdGltZSBtYXkgaW5mb3JtIHVzIG9mIG91ciBjbGllbnRJZCBpbiB0aGUgQ09OTkVDVEVEXG5cdFx0ICogbWVzc2FnZS4gU28gYXNzdW1lIHdlJ3JlIG5vdCBhbm9ueW1vdXMgYW5kIGxlYXZlIGl0IHRvIHJlYWx0aW1lIHRvXG5cdFx0ICogcmV0dXJuIGFuIGVycm9yIGlmIHdlIGFyZSAqL1xuXHRcdHZhciBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG5cdFx0cmV0dXJuICghY2xpZW50SWQgfHwgKGNsaWVudElkID09PSAnKicpKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJztcblx0fVxuXG5cdC8qIENhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IGluIHRoZSBldmVudCBvZiBhbiBlcnJvciAqL1xuXHRmdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuXHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRhY3Rpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyKSBjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdGVsc2UgYWN0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHJlYWx0aW1lY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcihjaGFubmVsLnN0YXRlKSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbCwgb3B0aW9ucykge1xuXHRcdGNsaWVudF9wcmVzZW5jZS5jYWxsKHRoaXMsIGNoYW5uZWwpO1xuXHRcdHRoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0dGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xuXHRcdHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzKTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhSZWFsdGltZVByZXNlbmNlLCBjbGllbnRfcHJlc2VuY2UpO1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gdXBkYXRlIHByZXNlbmNlIGRhdGEnLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSwgJ3VwZGF0ZScsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW50ZXJPclVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFjYWxsYmFjaykge1xuXHRcdFx0aWYgKHR5cGVvZihkYXRhKT09PSdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnX2VudGVyT3JVcGRhdGVDbGllbnQnLCBbY2xpZW50SWQsIGRhdGEsIGFjdGlvbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHRpZighY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuJyArIGFjdGlvbiArICdDbGllbnQoKScsXG5cdFx0ICAnY2hhbm5lbCA9ICcgKyBjaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgKGNsaWVudElkIHx8ICcoaW1wbGljaXQpICcgKyBnZXRDbGllbnRJZCh0aGlzKSkpO1xuXG5cdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uIDogYWN0aW9uLFxuXHRcdFx0ZGF0YSAgIDogZGF0YVxuXHRcdH0pO1xuXHRcdGlmIChjbGllbnRJZCkge1xuXHRcdFx0cHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZShwcmVzZW5jZSwgY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0XHRjaGFubmVsLmF0dGFjaCgpO1xuXHRcdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHRcdHNlbGYucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuXHRcdFx0XHRcdFx0cHJlc2VuY2UgOiBwcmVzZW5jZSxcblx0XHRcdFx0XHRcdGNhbGxiYWNrIDogY2FsbGJhY2tcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gJyArIGFjdGlvbiArICcgcHJlc2VuY2UgY2hhbm5lbCB3aGlsZSBpbiAnICsgY2hhbm5lbC5zdGF0ZSArICcgc3RhdGUnLCA5MDAwMSk7XG5cdFx0XHRcdFx0ZXJyLmNvZGUgPSA5MDAwMTtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWwnLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsZWF2ZUNsaWVudCcsIFtjbGllbnRJZCwgZGF0YV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHRpZighY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKScsICdsZWF2aW5nOyBjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgY2xpZW50ID0gJyArIGNsaWVudElkKTtcblx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb24gOiAnbGVhdmUnLFxuXHRcdFx0ZGF0YSAgIDogZGF0YVxuXHRcdH0pO1xuXHRcdGlmIChjbGllbnRJZCkgeyBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkOyB9XG5cblx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuXHRcdFx0XHRcdHByZXNlbmNlIDogcHJlc2VuY2UsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFja1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHQvKiB3ZSdyZSBub3QgYXR0YWNoZWQ7IHRoZXJlZm9yZSB3ZSBsZXQgYW55IGVudGVyZWQgc3RhdHVzXG5cdFx0XHRcdCAqIHRpbWVvdXQgYnkgaXRzZWxmIGluc3RlYWQgb2YgYXR0YWNoaW5nIGp1c3QgaW4gb3JkZXIgdG8gbGVhdmUgKi9cblx0XHRcdFx0dmFyIGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpJywgOTAwMDEpO1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8qIHRoZXJlIGlzIG5vIGNvbm5lY3Rpb247IHRoZXJlZm9yZSB3ZSBsZXRcblx0XHRcdFx0ICogYW55IGVudGVyZWQgc3RhdHVzIHRpbWVvdXQgYnkgaXRzZWxmICovXG5cdFx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25lcnJvcltcImFcIiAvKiBkZWZhdWx0ICovXS5mYWlsZWQpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigvKiBwYXJhbXMsIGNhbGxiYWNrICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdGlmKGFyZ3MubGVuZ3RoID09IDEgJiYgdHlwZW9mKGFyZ3NbMF0pID09ICdmdW5jdGlvbicpXG5cdFx0XHRhcmdzLnVuc2hpZnQobnVsbCk7XG5cblx0XHR2YXIgcGFyYW1zID0gYXJnc1swXSxcblx0XHRcdGNhbGxiYWNrID0gYXJnc1sxXSxcblx0XHRcdHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcblxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJncyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuXHRcdH1cblxuXHRcdC8qIFNwZWNpYWwtY2FzZSB0aGUgc3VzcGVuZGVkIHN0YXRlOiBjYW4gc3RpbGwgZ2V0IChzdGFsZSkgcHJlc2VuY2Ugc2V0IGlmIHdhaXRGb3JTeW5jIGlzIGZhbHNlICovXG5cdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0aWYod2FpdEZvclN5bmMpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdFx0XHRjb2RlOiA5MTAwNSxcblx0XHRcdFx0XHRtZXNzYWdlOiAnUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZSdcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR3YWl0QXR0YWNoZWQodGhpcy5jaGFubmVsLCBjYWxsYmFjaywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcblx0XHRcdGlmKHdhaXRGb3JTeW5jKSB7XG5cdFx0XHRcdG1lbWJlcnMud2FpdFN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG5cdFx0XHRpZih0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0ZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcblx0XHRcdFx0cGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSwgNDAwMDAsIDQwMCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsaWVudF9wcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zZXRQcmVzZW5jZSA9IGZ1bmN0aW9uKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpJywgJ3JlY2VpdmVkIHByZXNlbmNlIGZvciAnICsgcHJlc2VuY2VTZXQubGVuZ3RoICsgJyBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gJyArIHN5bmNDaGFubmVsU2VyaWFsKTtcblx0XHR2YXIgc3luY0N1cnNvciwgbWF0Y2gsIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycyxcblx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzID0gW10sIGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG5cblx0XHRpZihpc1N5bmMpIHtcblx0XHRcdHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcblx0XHRcdGlmKHN5bmNDaGFubmVsU2VyaWFsICYmIChtYXRjaCA9IHN5bmNDaGFubmVsU2VyaWFsLm1hdGNoKC9eW1xcd1xcLV0rOiguKikkLykpKSB7XG5cdFx0XHRcdHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2VTZXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHByZXNlbmNlU2V0W2ldKTtcblx0XHRcdHN3aXRjaChwcmVzZW5jZS5hY3Rpb24pIHtcblx0XHRcdFx0Y2FzZSAnbGVhdmUnOlxuXHRcdFx0XHRcdGlmKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkICYmICFwcmVzZW5jZS5pc1N5bnRoZXNpemVkKCkpIHtcblx0XHRcdFx0XHRcdG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZW50ZXInOlxuXHRcdFx0XHRjYXNlICdwcmVzZW50Jzpcblx0XHRcdFx0Y2FzZSAndXBkYXRlJzpcblx0XHRcdFx0XHRpZihtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcblx0XHRcdFx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuXHRcdFx0XHRcdFx0bXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKiBpZiB0aGlzIGlzIHRoZSBsYXN0IChvciBvbmx5KSBtZXNzYWdlIGluIGEgc2VxdWVuY2Ugb2Ygc3luYyB1cGRhdGVzLCBlbmQgdGhlIHN5bmMgKi9cblx0XHRpZihpc1N5bmMgJiYgIXN5bmNDdXJzb3IpIHtcblx0XHRcdG1lbWJlcnMuZW5kU3luYygpO1xuXHRcdFx0LyogUlRQNWMyOiByZS1lbnRlciBvdXIgb3duIG1lbWJlcnMgaWYgdGhleSBoYXZlbid0IHNob3duIHVwIGluIHRoZSBzeW5jICovXG5cdFx0XHR0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG5cdFx0XHR0aGlzLmNoYW5uZWwuc2V0SW5Qcm9ncmVzcyhyZWFsdGltZWNoYW5uZWwucHJvZ3Jlc3NPcHMuc3luYywgZmFsc2UpO1xuXHRcdFx0dGhpcy5jaGFubmVsLnN5bmNDaGFubmVsU2VyaWFsID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKiBicm9hZGNhc3QgdG8gbGlzdGVuZXJzICovXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBicm9hZGNhc3RNZXNzYWdlc1tpXTtcblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24oaGFzUHJlc2VuY2UpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgaGFzUHJlc2VuY2UgPSAnICsgaGFzUHJlc2VuY2UpO1xuXG5cdFx0aWYoaGFzUHJlc2VuY2UpIHtcblx0XHRcdHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3ludGhlc2l6ZUxlYXZlcyh0aGlzLm1lbWJlcnMudmFsdWVzKCkpO1xuXHRcdFx0dGhpcy5tZW1iZXJzLmNsZWFyKCk7XG5cdFx0XHR0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG5cdFx0fVxuXG5cdFx0LyogTkIgdGhpcyBtdXN0IGJlIGFmdGVyIHRoZSBfZW5zdXJlTXlNZW1iZXJzUHJlc2VudCBjYWxsLCB3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHBlbmRpbmdQcmVzZW5jZSAqL1xuXHRcdHZhciBwZW5kaW5nUHJlc2VuY2UgPSB0aGlzLnBlbmRpbmdQcmVzZW5jZSxcblx0XHRcdHBlbmRpbmdQcmVzQ291bnQgPSBwZW5kaW5nUHJlc2VuY2UubGVuZ3RoO1xuXG5cdFx0aWYocGVuZGluZ1ByZXNDb3VudCkge1xuXHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0XHRcdHZhciBwcmVzZW5jZUFycmF5ID0gW107XG5cdFx0XHR2YXIgbXVsdGljYXN0ZXIgPSBPYmplY3QodXRpbF9tdWx0aWNhc3RlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoKTtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCcsICdzZW5kaW5nICcgKyBwZW5kaW5nUHJlc0NvdW50ICsgJyBxdWV1ZWQgcHJlc2VuY2UgbWVzc2FnZXMnKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gcGVuZGluZ1ByZXNlbmNlW2ldO1xuXHRcdFx0XHRwcmVzZW5jZUFycmF5LnB1c2goZXZlbnQucHJlc2VuY2UpO1xuXHRcdFx0XHRtdWx0aWNhc3Rlci5wdXNoKGV2ZW50LmNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2VBcnJheSwgbXVsdGljYXN0ZXIpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5hY3RPbkNoYW5uZWxTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG5cdFx0c3dpdGNoKHN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0dGhpcy5fY2xlYXJNeU1lbWJlcnMoKTtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmNsZWFyKCk7XG5cdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdHRoaXMuZmFpbFBlbmRpbmdQcmVzZW5jZShlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZmFpbFBlbmRpbmdQcmVzZW5jZSA9IGZ1bmN0aW9uKGVycikge1xuXHRcdGlmKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmZhaWxQZW5kaW5nUHJlc2VuY2UnLCAnY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2NsZWFyTXlNZW1iZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycyxcblx0XHRcdHJlZW50ZXJDYiA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHR2YXIgbXNnID0gJ1ByZXNlbmNlIGF1dG8tcmUtZW50ZXIgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0dmFyIHdyYXBwZWRFcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgOTEwMDQsIDQwMCk7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgbXNnKTtcblx0XHRcdFx0XHR2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZShzZWxmLmNoYW5uZWwuc3RhdGUsIHNlbGYuY2hhbm5lbC5zdGF0ZSwgdHJ1ZSwgd3JhcHBlZEVycik7XG5cdFx0XHRcdFx0c2VsZi5jaGFubmVsLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRmb3IodmFyIG1lbWJlcktleSBpbiBteU1lbWJlcnMubWFwKSB7XG5cdFx0XHRpZighKG1lbWJlcktleSBpbiBtZW1iZXJzLm1hcCkpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCcpO1xuXHRcdFx0XHR0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCAnZW50ZXInLCByZWVudGVyQ2IpO1xuXHRcdFx0XHRkZWxldGUgbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fc3ludGhlc2l6ZUxlYXZlcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG5cdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRhY3Rpb246ICdsZWF2ZScsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuXHRcdFx0XHRkYXRhOiBpdGVtLmRhdGEsXG5cdFx0XHRcdGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuXHRcdFx0XHR0aW1lc3RhbXA6IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpXG5cdFx0XHR9KTtcblx0XHRcdHN1YnNjcmlwdGlvbnMuZW1pdCgnbGVhdmUnLCBwcmVzZW5jZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyogRGVwcmVjYXRlZCAqL1xuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdwcmVzZW5jZS5vbicsICdwcmVzZW5jZS5zdWJzY3JpYmUnKTtcblx0XHR0aGlzLnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdC8qIERlcHJlY2F0ZWQgKi9cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9mZicsICdwcmVzZW5jZS51bnN1YnNjcmliZScpO1xuXHRcdHRoaXMudW5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuXHRcdHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocmVhbHRpbWVjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuXHRcdGNoYW5uZWwuYXR0YWNoKGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XG5cdFx0dmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG5cdH07XG5cblx0ZnVuY3Rpb24gUHJlc2VuY2VNYXAocHJlc2VuY2UpIHtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG5cdFx0dGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMuc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUHJlc2VuY2VNYXAsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXRDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBrZXkgaW4gbWFwKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1hcFtrZXldO1xuXHRcdFx0aWYoaXRlbS5jbGllbnRJZCA9PSBjbGllbnRJZCAmJiBpdGVtLmFjdGlvbiAhPSAnYWJzZW50Jylcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsXG5cdFx0XHRjbGllbnRJZCA9IHBhcmFtcyAmJiBwYXJhbXMuY2xpZW50SWQsXG5cdFx0XHRjb25uZWN0aW9uSWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbm5lY3Rpb25JZCxcblx0XHRcdHJlc3VsdCA9IFtdO1xuXG5cdFx0Zm9yKHZhciBrZXkgaW4gbWFwKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1hcFtrZXldO1xuXHRcdFx0aWYoaXRlbS5hY3Rpb24gPT09ICdhYnNlbnQnKSBjb250aW51ZTtcblx0XHRcdGlmKGNsaWVudElkICYmIGNsaWVudElkICE9IGl0ZW0uY2xpZW50SWQpIGNvbnRpbnVlO1xuXHRcdFx0aWYoY29ubmVjdGlvbklkICYmIGNvbm5lY3Rpb25JZCAhPSBpdGVtLmNvbm5lY3Rpb25JZCkgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRmdW5jdGlvbiBuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmcpIHtcblx0XHQvKiBSVFAyYjE6IGlmIGVpdGhlciBpcyBzeW50aGVzaXNlZCwgY29tcGFyZSBieSB0aW1lc3RhbXAgKi9cblx0XHRpZihpdGVtLmlzU3ludGhlc2l6ZWQoKSB8fCBleGlzdGluZy5pc1N5bnRoZXNpemVkKCkpIHtcblx0XHRcdHJldHVybiBpdGVtLnRpbWVzdGFtcCA+IGV4aXN0aW5nLnRpbWVzdGFtcDtcblx0XHR9XG5cblx0XHQvKiBSVFAyYjIgKi9cblx0XHR2YXIgaXRlbU9yZGVyaW5ncyA9IGl0ZW0ucGFyc2VJZCgpLFxuXHRcdFx0ZXhpc3RpbmdPcmRlcmluZ3MgPSBleGlzdGluZy5wYXJzZUlkKCk7XG5cdFx0aWYoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuXHRcdFx0cmV0dXJuIGl0ZW1PcmRlcmluZ3MuaW5kZXggPiBleGlzdGluZ09yZGVyaW5ncy5pbmRleDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuXHRcdH1cblx0fVxuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYoaXRlbS5hY3Rpb24gPT09ICdlbnRlcicgfHwgaXRlbS5hY3Rpb24gPT09ICd1cGRhdGUnKSB7XG5cdFx0XHRpdGVtID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoaXRlbSk7XG5cdFx0XHRpdGVtLmFjdGlvbiA9ICdwcmVzZW50Jztcblx0XHR9XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSBtZW1iZXJLZXkoaXRlbSk7XG5cdFx0Lyogd2UndmUgc2VlbiB0aGlzIG1lbWJlciwgc28gZG8gbm90IHJlbW92ZSBpdCBhdCB0aGUgZW5kIG9mIHN5bmMgKi9cblx0XHRpZih0aGlzLnJlc2lkdWFsTWVtYmVycylcblx0XHRcdGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xuXG5cdFx0LyogY29tcGFyZSB0aGUgdGltZXN0YW1wIG9mIHRoZSBuZXcgaXRlbSB3aXRoIGFueSBleGlzdGluZyBtZW1iZXIgKG9yIEFCU0VOVCB3aXRuZXNzKSAqL1xuXHRcdHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcblx0XHRpZihleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdG1hcFtrZXldID0gaXRlbTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gbWVtYmVyS2V5KGl0ZW0pO1xuXHRcdHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcblxuXHRcdGlmKGV4aXN0aW5nSXRlbSAmJiAhbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiBSVFAyZiAqL1xuXHRcdGlmKHRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcblx0XHRcdGl0ZW0gPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhpdGVtKTtcblx0XHRcdGl0ZW0uYWN0aW9uID0gJ2Fic2VudCc7XG5cdFx0XHRtYXBba2V5XSA9IGl0ZW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBtYXBba2V5XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuc3RhcnRTeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAuc3RhcnRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcblx0XHQvKiB3ZSBtaWdodCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2hpbGUgYSBzeW5jIGlzIGluIHByb2dyZXNzICovXG5cdFx0aWYoIXRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMucmVzaWR1YWxNZW1iZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weShtYXApO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHRydWUpO1xuXHRcdH1cblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZW5kU3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLmVuZFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuXHRcdGlmKHN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHQvKiB3ZSBjYW4gbm93IHN0cmlwIG91dCB0aGUgQUJTRU5UIG1lbWJlcnMsIGFzIHdlIGhhdmVcblx0XHRcdCAqIHJlY2VpdmVkIGFsbCBvZiB0aGUgb3V0LW9mLW9yZGVyIHN5bmMgbWVzc2FnZXMgKi9cblx0XHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIG1hcCkge1xuXHRcdFx0XHR2YXIgZW50cnkgPSBtYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0aWYoZW50cnkuYWN0aW9uID09PSAnYWJzZW50Jykge1xuXHRcdFx0XHRcdGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0LyogYW55IG1lbWJlcnMgdGhhdCB3ZXJlIHByZXNlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzeW5jLFxuXHRcdFx0ICogYW5kIGhhdmUgbm90IGJlZW4gc2VlbiBpbiBzeW5jLCBjYW4gYmUgcmVtb3ZlZCwgYW5kIGxlYXZlIGV2ZW50cyBlbWl0dGVkICovXG5cdFx0XHR0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XG5cdFx0XHRmb3IodmFyIG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuXHRcdFx0XHRkZWxldGUgbWFwW21lbWJlcktleV07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cblx0XHRcdC8qIGZpbmlzaCwgbm90aWZ5aW5nIGFueSB3YWl0ZXJzICovXG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuXHRcdH1cblx0XHR0aGlzLmVtaXQoJ3N5bmMnKTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUud2FpdFN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHZhciBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAud2FpdFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuXHRcdGlmKCFzeW5jSW5Qcm9ncmVzcykge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5vbmNlKCdzeW5jJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuXHRcdHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKGluUHJvZ3Jlc3MpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdQcmVzZW5jZU1hcC5zZXRJblByb2dyZXNzKCknLCAnaW5Qcm9ncmVzcyA9ICcgKyBpblByb2dyZXNzKTtcblx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcblx0XHR0aGlzLnByZXNlbmNlLnN5bmNDb21wbGV0ZSA9ICFpblByb2dyZXNzO1xuXHR9O1xuXG5cdHJldHVybiBSZWFsdGltZVByZXNlbmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcmVhbHRpbWVwcmVzZW5jZSA9IChyZWFsdGltZXByZXNlbmNlX1JlYWx0aW1lUHJlc2VuY2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lY2hhbm5lbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJlYWx0aW1lY2hhbm5lbF9SZWFsdGltZUNoYW5uZWwgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkFjdGlvbjtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgc3RhdGVjaGFuZ2VPcCA9ICdzdGF0ZWNoYW5nZSc7XG5cdHZhciBzeW5jT3AgPSAnc3luYyc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFJlYWx0aW1lQ2hhbm5lbChyZWFsdGltZSwgbmFtZSwgb3B0aW9ucykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG5cdFx0Y2xpZW50X2NoYW5uZWwuY2FsbCh0aGlzLCByZWFsdGltZSwgbmFtZSwgb3B0aW9ucyk7XG5cdFx0dGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgcmVhbHRpbWVwcmVzZW5jZSh0aGlzLCByZWFsdGltZS5vcHRpb25zKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHR0aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cdFx0dGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnByb3BlcnRpZXMgPSB7XG5cdFx0XHRhdHRhY2hTZXJpYWw6IHVuZGVmaW5lZFxuXHRcdH07XG5cdFx0dGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xuXHRcdHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gbnVsbDtcblx0XHR0aGlzLl9tb2RlID0gbnVsbDtcblx0XHQvKiBUZW1wb3Jhcnk7IG9ubHkgdXNlZCBmb3IgdGhlIGNoZWNrQ2hhbm5lbHNPblJlc3VtZSBvcHRpb24gKi9cblx0XHR0aGlzLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9IGZhbHNlO1xuXHRcdHRoaXMuX2F0dGFjaFJlc3VtZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2RlY29kaW5nQ29udGV4dCA9IHtcblx0XHRcdGNoYW5uZWxPcHRpb25zOiB0aGlzLmNoYW5uZWxPcHRpb25zLFxuXHRcdFx0cGx1Z2luczogcmVhbHRpbWUub3B0aW9ucy5wbHVnaW5zIHx8IHsgfSxcblx0XHRcdGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB1bmRlZmluZWRcblx0XHR9O1xuXHRcdHRoaXMuX2xhc3RQYXlsb2FkID0ge1xuXHRcdFx0bWVzc2FnZUlkOiBudWxsLFxuXHRcdFx0cHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDogbnVsbCxcblx0XHRcdGRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3M6IG51bGxcblx0XHR9O1xuXHRcdC8qIE9ubHkgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGlzIGFuZCB0aGUgcHVibGljIGV2ZW50IGVtaXR0ZXIgaXMgdGhhdCB0aGlzIGVtaXRzIGFuXG5cdFx0ICogdXBkYXRlIGV2ZW50IGZvciBhbGwgQVRUQUNIRURzLCB3aGV0aGVyIHJlc3VtZWQgb3Igbm90ICovXG5cdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUmVhbHRpbWVDaGFubmVsLCBjbGllbnRfY2hhbm5lbCk7XG5cblx0UmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdFx0Y29kZTogOTAwMDEsXG5cdFx0XHRtZXNzYWdlOiAnQ2hhbm5lbCBvcGVyYXRpb24gZmFpbGVkIGFzIGNoYW5uZWwgc3RhdGUgaXMgJyArIHN0YXRlXG5cdFx0fTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvZ3Jlc3NPcHMgPSB7XG5cdFx0c3RhdGVjaGFuZ2U6IHN0YXRlY2hhbmdlT3AsXG5cdFx0c3luYzogc3luY09wXG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MgPSBmdW5jdGlvbihhcmdzKSB7XG5cdFx0LyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdFx0aWYodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGFyZ3MudW5zaGlmdChudWxsKTtcblx0XHR9XG5cdFx0aWYoYXJnc1thcmdzLmxlbmd0aCAtIDFdID09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXJncy5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyZ3M7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzZXRPcHRpb25zJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpJywgJ1NldCBvcHRpb25zIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIGVyciA9IHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0aWYoZXJyKSB7XG5cdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjbGllbnRfY2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdGlmICh0aGlzLl9kZWNvZGluZ0NvbnRleHQpXG5cdFx0XHR0aGlzLl9kZWNvZGluZ0NvbnRleHQuY2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuXHRcdGlmKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMpKSB7XG5cdFx0XHQvKiBUaGlzIGRvZXMgbm90IGp1c3QgZG8gX2F0dGFjaCh0cnVlLCBudWxsLCBjYWxsYmFjaykgYmVjYXVzZSB0aGF0IHdvdWxkIHB1dCB1c1xuXHRcdFx0ICogaW50byB0aGUgJ2F0dGFjaGluZycgc3RhdGUgdW50aWwgd2UgcmVjZWl2ZSB0aGUgbmV3IGF0dGFjaGVkLCB3aGljaCBpc1xuXHRcdFx0ICogY29uY2VwdHVhbGx5IGluY29ycmVjdDogd2UgYXJlIHN0aWxsIGF0dGFjaGVkLCB3ZSBqdXN0IGhhdmUgYSBwZW5kaW5nIHJlcXVlc3QgdG9cblx0XHRcdCAqIGNoYW5nZSBzb21lIGNoYW5uZWwgcGFyYW1zLiBQZXIgUlRMMTcgZ29pbmcgaW50byB0aGUgYXR0YWNoaW5nIHN0YXRlIHdvdWxkIG1lYW5cblx0XHRcdCAqIHJlamVjdGluZyBtZXNzYWdlcyB1bnRpbCB3ZSBoYXZlIGNvbmZpcm1hdGlvbiB0aGF0IHRoZSBvcHRpb25zIGhhdmUgY2hhbmdlZCxcblx0XHRcdCAqIHdoaWNoIHdvdWxkIHVubmVjZXNzYXJpbHkgbG9zZSBtZXNzYWdlIGNvbnRpbnVpdHkuICovXG5cdFx0XHR0aGlzLmF0dGFjaEltcGwoKTtcblx0XHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0XHRjYXNlICd1cGRhdGUnOlxuXHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRcdGNhbGxiYWNrKG51bGwpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24pO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYob3B0aW9ucyAmJiAncGFyYW1zJyBpbiBvcHRpb25zICYmICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc09iamVjdChvcHRpb25zLnBhcmFtcykpIHtcblx0XHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdvcHRpb25zLnBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdCcsIDQwMDAwLCA0MDApO1xuXHRcdH1cblx0XHRpZihvcHRpb25zICYmICdtb2RlcycgaW4gb3B0aW9ucyl7XG5cdFx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShvcHRpb25zLm1vZGVzKSl7XG5cdFx0XHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdvcHRpb25zLm1vZGVzIG11c3QgYmUgYW4gYXJyYXknLCA0MDAwMCwgNDAwKTtcblx0XHRcdH1cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm1vZGVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dmFyIGN1cnJlbnRNb2RlID0gb3B0aW9ucy5tb2Rlc1tpXTtcblx0XHRcdFx0aWYoIWN1cnJlbnRNb2RlIHx8IHR5cGVvZiBjdXJyZW50TW9kZSAhPT0gJ3N0cmluZycgfHwgIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5jaGFubmVsTW9kZXMsIFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UuY2FsbChjdXJyZW50TW9kZSkpKXtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnSW52YWxpZCBjaGFubmVsIG1vZGU6ICcgKyBjdXJyZW50TW9kZSwgNDAwMDAsIDQwMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpICYmIChvcHRpb25zLnBhcmFtcyB8fCBvcHRpb25zLm1vZGVzKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0bWVzc2FnZXMgPSBhcmd1bWVudHNbMF0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3VtZW50c1thcmdDb3VudCAtIDFdO1xuXG5cdFx0aWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0KythcmdDb3VudDtcblx0XHR9XG5cdFx0aWYoIXRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoYXJnQ291bnQgPT0gMikge1xuXHRcdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3QobWVzc2FnZXMpKVxuXHRcdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMobWVzc2FnZXMpXTtcblx0XHRcdGVsc2UgaWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShtZXNzYWdlcykpXG5cdFx0XHRcdG1lc3NhZ2VzID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzQXJyYXkobWVzc2FnZXMpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtuYW1lOiBhcmd1bWVudHNbMF0sIGRhdGE6IGFyZ3VtZW50c1sxXX0pXTtcblx0XHR9XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0bWF4TWVzc2FnZVNpemUgPSB0aGlzLnJlYWx0aW1lLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG5cdFx0dHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIFJTTDFpICovXG5cdFx0XHR2YXIgc2l6ZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKTtcblx0XHRcdGlmKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArIHNpemUgKyAnIGJ5dGVzOyBsaW1pdCBpcyAnICsgbWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5fcHVibGlzaChtZXNzYWdlcywgY2FsbGJhY2spO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbihtZXNzYWdlcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ21lc3NhZ2UgY291bnQgPSAnICsgbWVzc2FnZXMubGVuZ3RoKTtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXHRcdHN3aXRjaChzdGF0ZSkge1xuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcihzdGF0ZSkpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ3NlbmRpbmcgbWVzc2FnZTsgY2hhbm5lbCBzdGF0ZSBpcyAnICsgc3RhdGUpO1xuXHRcdFx0XHR2YXIgbXNnID0gbmV3IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHRcdFx0XHRtc2cuYWN0aW9uID0gYWN0aW9ucy5NRVNTQUdFO1xuXHRcdFx0XHRtc2cuY2hhbm5lbCA9IHRoaXMubmFtZTtcblx0XHRcdFx0bXNnLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG5cdFx0XHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5vbkV2ZW50KCknLCAncmVjZWl2ZWQgbWVzc2FnZScpO1xuXHRcdHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcblx0XHRcdHN1YnNjcmlwdGlvbnMuZW1pdChtZXNzYWdlLm5hbWUsIG1lc3NhZ2UpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZsYWdzLCBjYWxsYmFjaykge1xuXHRcdGlmKHR5cGVvZihmbGFncykgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0gZmxhZ3M7XG5cdFx0XHRmbGFncyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2F0dGFjaCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwuYXR0YWNoKCknLCAnQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGZsYWdzKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnY2hhbm5lbC5hdHRhY2goKSB3aXRoIGZsYWdzJywgJ2NoYW5uZWwuc2V0T3B0aW9ucygpIHdpdGggY2hhbm5lbE9wdGlvbnMucGFyYW1zJyk7XG5cdFx0XHQvKiBJZiBmbGFncyByZXF1ZXN0ZWQsIGFsd2F5cyBkbyBhIHJlLWF0dGFjaC4gVE9ETyBvbmx5IGRvIHRoaXMgaWZcblx0XHRcdCAqIGN1cnJlbnQgbW9kZSBkaWZmZXJzIGZyb20gcmVxdWVzdGVkIG1vZGUgKi9cblx0XHRcdHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gZmxhZ3M7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2F0dGFjaChmYWxzZSwgbnVsbCwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uKGZvcmNlUmVhdHRhY2gsIGF0dGFjaFJlYXNvbiwgY2FsbGJhY2spIHtcblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwuX2F0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0aWYoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnN0YXRlICE9PSAnYXR0YWNoaW5nJyB8fCBmb3JjZVJlYXR0YWNoKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgYXR0YWNoUmVhc29uKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdHN3aXRjaCh0aGlzLmV2ZW50KSB7XG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHwgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaEltcGwgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuYXR0YWNoSW1wbCgpJywgJ3NlbmRpbmcgQVRUQUNIIG1lc3NhZ2UnKTtcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XG5cdFx0dmFyIGF0dGFjaE1zZyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuQVRUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUsIHBhcmFtczogdGhpcy5jaGFubmVsT3B0aW9ucy5wYXJhbXN9KTtcblx0XHRpZih0aGlzLl9yZXF1ZXN0ZWRGbGFncykge1xuXHRcdFx0YXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh0aGlzLl9yZXF1ZXN0ZWRGbGFncyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcblx0XHRcdGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuXHRcdH1cblx0XHRpZih0aGlzLl9hdHRhY2hSZXN1bWUpIHtcblx0XHRcdGF0dGFjaE1zZy5zZXRGbGFnKCdBVFRBQ0hfUkVTVU1FJyk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcblx0XHRcdGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcblx0XHR9XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2csIG5vb3ApO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdkZXRhY2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBkZXRhY2g7IGNoYW5uZWwgc3RhdGUgPSBmYWlsZWQnLCA5MDAwMSwgNDAwKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2RldGFjaGluZycpO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkgfHwgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdEZXRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBhdHRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2hJbXBsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuZGV0YWNoKCknLCAnc2VuZGluZyBERVRBQ0ggbWVzc2FnZScpO1xuXHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCB0cnVlKTtcblx0XHR2YXIgbXNnID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5ERVRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZX0pO1xuXHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCAoY2FsbGJhY2sgfHwgbm9vcCkpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3NbMl07XG5cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzdWJzY3JpYmUnLCBbZXZlbnQsIGxpc3RlbmVyXSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcignZmFpbGVkJykpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcblxuXHRcdHJldHVybiB0aGlzLmF0dGFjaChjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogY2hlY2sgcHJlY29uZGl0aW9ucyAqL1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwiVW5hYmxlIHRvIHN5bmMgdG8gY2hhbm5lbDsgbm90IGF0dGFjaGVkXCIsIDQwMDAwKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0fVxuXHRcdHZhciBjb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0aWYoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XG5cdFx0fVxuXG5cdFx0Lyogc2VuZCBzeW5jIHJlcXVlc3QgKi9cblx0XHR2YXIgc3luY01lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLlNZTkMsIGNoYW5uZWw6IHRoaXMubmFtZX0pO1xuXHRcdGlmKHRoaXMuc3luY0NoYW5uZWxTZXJpYWwpIHtcblx0XHRcdHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xuXHRcdH1cblx0XHRjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24obXNnLCBjYWxsYmFjaykge1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VuZChtc2csIHRoaXMucmVhbHRpbWUub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kUHJlc2VuY2UgPSBmdW5jdGlvbihwcmVzZW5jZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgbXNnID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uOiBhY3Rpb25zLlBSRVNFTkNFLFxuXHRcdFx0Y2hhbm5lbDogdGhpcy5uYW1lLFxuXHRcdFx0cHJlc2VuY2U6ICh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KHByZXNlbmNlKSA/XG5cdFx0XHRcdHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzQXJyYXkocHJlc2VuY2UpIDpcblx0XHRcdFx0W3ByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHByZXNlbmNlKV0pXG5cdFx0fSk7XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHR2YXIgc3luY0NoYW5uZWxTZXJpYWwsIGlzU3luYyA9IGZhbHNlO1xuXHRcdHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xuXHRcdGNhc2UgYWN0aW9ucy5BVFRBQ0hFRDpcblx0XHRcdHRoaXMuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gdHJ1ZTtcblx0XHRcdHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG5cdFx0XHR0aGlzLl9tb2RlID0gbWVzc2FnZS5nZXRNb2RlKCk7XG5cdFx0XHR0aGlzLnBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVzRnJvbUZsYWdzID0gbWVzc2FnZS5kZWNvZGVNb2Rlc0Zyb21GbGFncygpO1xuXHRcdFx0dGhpcy5tb2RlcyA9IChtb2Rlc0Zyb21GbGFncyAmJiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykpIHx8IHVuZGVmaW5lZDtcblx0XHRcdHZhciByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKCdSRVNVTUVEJyk7XG5cdFx0XHR2YXIgaGFzUHJlc2VuY2UgPSBtZXNzYWdlLmhhc0ZsYWcoJ0hBU19QUkVTRU5DRScpO1xuXHRcdFx0aWYodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHQvKiBhdHRhY2hlZCBvcGVyYXRpb25zIHRvIGNoYW5nZSBvcHRpb25zIHNldCB0aGUgaW5wcm9ncmVzcyBtdXRleCwgYnV0IGxlYXZlXG5cdFx0XHRcdCAqIGNoYW5uZWwgaW4gdGhlIGF0dGFjaGVkIHN0YXRlICovXG5cdFx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCBmYWxzZSk7XG5cdFx0XHRcdGlmKCFyZXN1bWVkKSB7XG5cdFx0XHRcdFx0LyogT24gYSBsb3NzIG9mIGNvbnRpbnVpdHksIHRoZSBwcmVzZW5jZSBzZXQgbmVlZHMgdG8gYmUgcmUtc3luY2VkICovXG5cdFx0XHRcdFx0dGhpcy5wcmVzZW5jZS5vbkF0dGFjaGVkKGhhc1ByZXNlbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZSh0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLCByZXN1bWVkLCBtZXNzYWdlLmVycm9yKTtcblx0XHRcdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcblx0XHRcdFx0aWYoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcblx0XHRcdFx0LyogUlRMNWk6IHJlLXNlbmQgREVUQUNIIGFuZCByZW1haW4gaW4gdGhlICdkZXRhY2hpbmcnIHN0YXRlICovXG5cdFx0XHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuREVUQUNIRUQ6XG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvciA/IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBkZXRhY2hlZCcsIDkwMDAxLCA0MDQpO1xuXHRcdFx0aWYodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnLCBlcnIpO1xuXHRcdFx0fSBlbHNlIGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSB7XG5cdFx0XHRcdC8qIE9ubHkgcmV0cnkgaW1tZWRpYXRlbHkgaWYgd2Ugd2VyZSBwcmV2aW91c2x5IGF0dGFjaGVkLiBJZiB3ZSB3ZXJlXG5cdFx0XHRcdCAqIGF0dGFjaGluZywgZ28gaW50byBzdXNwZW5kZWQsIGZhaWwgbWVzc2FnZXMsIGFuZCB3YWl0IGEgZmV3IHNlY29uZHNcblx0XHRcdFx0ICogYmVmb3JlIHJldHJ5aW5nICovXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgZXJyKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLlNZTkM6XG5cdFx0XHQvKiBzeW5jcyBjYW4gaGF2ZSBjaGFubmVsU2VyaWFscywgYnV0IG1pZ2h0IG5vdCBpZiB0aGUgc3luYyBpcyBvbmUgcGFnZSBsb25nICovXG5cdFx0XHRpc1N5bmMgPSB0cnVlO1xuXHRcdFx0c3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuXHRcdFx0Lyogc3luY3MgY2FuIGhhcHBlbiBvbiBjaGFubmVscyB3aXRoIG5vIHByZXNlbmNlIGRhdGEgYXMgcGFydCBvZiBjb25uZWN0aW9uXG5cdFx0XHQgKiByZXN1bWluZywgaW4gd2hpY2ggY2FzZSBwcm90b2NvbCBtZXNzYWdlIGhhcyBubyBwcmVzZW5jZSBwcm9wZXJ0eSAqL1xuXHRcdFx0aWYoIW1lc3NhZ2UucHJlc2VuY2UpIGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcblx0XHRcdHZhciBwcmVzZW5jZSA9IG1lc3NhZ2UucHJlc2VuY2UsXG5cdFx0XHRcdGlkID0gbWVzc2FnZS5pZCxcblx0XHRcdFx0Y29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgcHJlc2VuY2VNc2cgPSBwcmVzZW5jZVtpXTtcblx0XHRcdFx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlKHByZXNlbmNlTXNnLCBvcHRpb25zKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZCkgcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cudGltZXN0YW1wKSBwcmVzZW5jZU1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy5pZCkgcHJlc2VuY2VNc2cuaWQgPSBpZCArICc6JyArIGk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXNlbmNlLnNldFByZXNlbmNlKHByZXNlbmNlLCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLk1FU1NBR0U6XG5cblx0XHRcdC8vUlRMMTdcblx0XHRcdGlmKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcyxcblx0XHRcdFx0Zmlyc3RNZXNzYWdlID0gbWVzc2FnZXNbMF0sXG5cdFx0XHRcdGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdGlkID0gbWVzc2FnZS5pZCxcblx0XHRcdFx0Y29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG5cdFx0XHRpZihmaXJzdE1lc3NhZ2UuZXh0cmFzICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdEZWx0YSBtZXNzYWdlIGRlY29kZSBmYWlsdXJlIC0gcHJldmlvdXMgbWVzc2FnZSBub3QgYXZhaWxhYmxlIGZvciBtZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgb24gdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIi4nO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBtc2cpO1xuXHRcdFx0XHR0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAwMTgsIDQwMCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBtc2cgPSBtZXNzYWdlc1tpXTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZShtc2csIHRoaXMuX2RlY29kaW5nQ29udGV4dCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvKiBkZWNyeXB0IGZhaWxlZCAuLiB0aGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSBoYXZlIHRoZSB3cm9uZyBrZXkgKi9cblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdHN3aXRjaChlLmNvZGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgNDAwMTg6XG5cdFx0XHRcdFx0XHRcdC8qIGRlY29kZSBmYWlsdXJlICovXG5cdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRjYXNlIDQwMDE5OlxuXHRcdFx0XHRcdFx0XHQvKiBObyB2Y2RpZmYgcGx1Z2luIHBhc3NlZCBpbiAtIG5vIHBvaW50IHJlY292ZXJpbmcsIGdpdmUgdXAgKi9cblx0XHRcdFx0XHRcdGNhc2UgNDAwMjE6XG5cdFx0XHRcdFx0XHRcdC8qIEJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWx0YXMsIHNpbWlsYXJseSBubyBwb2ludCByZWNvdmVyaW5nICovXG5cdFx0XHRcdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFtc2cuY29ubmVjdGlvbklkKSBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdFx0XHRpZighbXNnLnRpbWVzdGFtcCkgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblx0XHRcdFx0aWYoIW1zZy5pZCkgbXNnLmlkID0gaWQgKyAnOicgKyBpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG5cdFx0XHR0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuXHRcdFx0dGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLkVSUk9SOlxuXHRcdFx0LyogdGhlcmUgd2FzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciAqL1xuXHRcdFx0dmFyIGVyciA9IG1lc3NhZ2UuZXJyb3I7XG5cdFx0XHRpZihlcnIgJiYgZXJyLmNvZGUgPT0gODAwMTYpIHtcblx0XHRcdFx0LyogYXR0YWNoL2RldGFjaCBvcGVyYXRpb24gYXR0ZW1wdGVkIG9uIHN1cGVyc2VkZWQgdHJhbnNwb3J0IGhhbmRsZSAqL1xuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhlcnIpKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdGYXRhbCBwcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIGFjdGlvbiAoJyArIG1lc3NhZ2UuYWN0aW9uICsgJyknKTtcblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWJvcnQoY29ubmVjdGlvbmVycm9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnVua25vd25DaGFubmVsRXJyKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkgPSBmdW5jdGlvbihyZWFzb24pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLicpO1xuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0XHR0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbkF0dGFjaGVkJywgJ2FjdGl2YXRpbmcgY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLm5hbWUpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uLCByZXN1bWVkLCBoYXNQcmVzZW5jZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIGN1cnJlbnQgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSArICcsIG5vdGlmeWluZyBzdGF0ZSAnICsgc3RhdGUpO1xuXHRcdHRoaXMuY2xlYXJTdGF0ZVRpbWVyKCk7XG5cblx0XHRpZihzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcblx0XHRpZihzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcblx0XHR9XG5cdFx0aWYocmVhc29uKSB7XG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gcmVhc29uO1xuXHRcdH1cblx0XHR2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZSh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgcmVhc29uKTtcblx0XHR2YXIgbG9nTGV2ZWwgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyBsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SIDogbG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUjtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ0xldmVsLCAnQ2hhbm5lbCBzdGF0ZSBmb3IgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCInLCBzdGF0ZSArIChyZWFzb24gPyAoJzsgcmVhc29uOiAnICsgcmVhc29uKSA6ICcnKSk7XG5cblx0XHQvKiBOb3RlOiB3ZSBkb24ndCBzZXQgaW5Qcm9ncmVzcyBmb3IgcGVuZGluZyBzdGF0ZXMgdW50aWwgdGhlIHJlcXVlc3QgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3MgKi9cblx0XHRpZihzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0dGhpcy5vbkF0dGFjaGVkKCk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3luY09wLCBoYXNQcmVzZW5jZSk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2RldGFjaGVkJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN5bmNPcCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdGlmKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2RldGFjaGluZycgfHwgc3RhdGUgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcblx0XHR0aGlzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnJlcXVlc3RTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHN0YXRlKTtcblx0XHR0aGlzLm5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24pO1xuXHRcdC8qIHNlbmQgdGhlIGV2ZW50IGFuZCBhd2FpdCByZXNwb25zZSAqL1xuXHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNoZWNrUGVuZGluZ1N0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogaWYgY2FuJ3Qgc2VuZCBldmVudHMsIGRvIG5vdGhpbmcgKi9cblx0XHR2YXIgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG5cdFx0LyogQWxsb3cgYXR0YWNoIG1lc3NhZ2VzIHRvIHF1ZXVlIHVwIHdoZW4gc3luY2hyb25pemluZywgc2luY2UgdGhpcyB3aWxsIGJlXG5cdFx0ICogdGhlIHN0YXRlIHdlJ2xsIGJlIGluIHdoZW4gdXBncmFkZSB0cmFuc3BvcnQuYWN0aXZlIHRyaWdnZXJzIGEgY2hlY2twZW5kaW5nc3RhdGUgKi9cblx0XHRpZighKGNtU3RhdGUuc2VuZEV2ZW50cyB8fCBjbVN0YXRlLmZvcmNlUXVldWVFdmVudHMpKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnc2VuZEV2ZW50cyBpcyBmYWxzZTsgc3RhdGUgaXMgJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHRoaXMuc3RhdGUpO1xuXHRcdC8qIE9ubHkgc3RhcnQgdGhlIHN0YXRlIHRpbWVyIHJ1bm5pbmcgd2hlbiBhY3R1YWxseSBzZW5kaW5nIHRoZSBldmVudCAqL1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuXHRcdFx0XHR0aGlzLmF0dGFjaEltcGwoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuXHRcdFx0XHR0aGlzLmRldGFjaEltcGwoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdC8qIHJlc3VtZSBhbnkgc3luYyBvcGVyYXRpb24gdGhhdCB3YXMgaW4gcHJvZ3Jlc3MgKi9cblx0XHRcdFx0dGhpcy5zeW5jKCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS50aW1lb3V0UGVuZGluZ1N0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZighdGhpcy5zdGF0ZVRpbWVyKSB7XG5cdFx0XHR0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nJywgJ3RpbWVyIGV4cGlyZWQnKTtcblx0XHRcdFx0c2VsZi5zdGF0ZVRpbWVyID0gbnVsbDtcblx0XHRcdFx0c2VsZi50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9LCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXJTdGF0ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0YXRlVGltZXIgPSB0aGlzLnN0YXRlVGltZXI7XG5cdFx0aWYoc3RhdGVUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuXHRcdFx0dGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSByZXR1cm47XG5cblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogSWYgY29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkLCBqdXN0IGxlYXZlIGluIHN1c3BlbmRlZCwgYSByZWF0dGFjaFxuXHRcdFx0ICogd2lsbCBiZSB0cmlnZ2VyZWQgb25jZSBpdCBjb25uZWN0cyBhZ2FpbiAqL1xuXHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgc2VsZi5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRcdHNlbGYucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkJywgJ2F0dGVtcHRpbmcgYSBuZXcgYXR0YWNoJyk7XG5cdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMuY2hhbm5lbFJldHJ5VGltZW91dCk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcblx0XHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24ob3BlcmF0aW9uLCB2YWx1ZSkge1xuXHRcdHRoaXMucmVzdC5jaGFubmVscy5zZXRJblByb2dyZXNzKHRoaXMsIG9wZXJhdGlvbiwgdmFsdWUpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuXHRcdFx0aWYodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDQwMDAwLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcInVudGlsQXR0YWNoIHdhcyBzcGVjaWZpZWQgYW5kIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGJ1dCBhdHRhY2hTZXJpYWwgaXMgbm90IGRlZmluZWRcIiwgNDAwMDAsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuXHRcdFx0cGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcblx0XHR9XG5cblx0XHRjbGllbnRfY2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBsaXN0ZW5lcikge1xuXHRcdHJldHVybiBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlLCBsaXN0ZW5lcik7XG5cdH1cblxuXHQvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmdldFJlbGVhc2VFcnIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcyA9IHRoaXMuc3RhdGU7XG5cdFx0aWYocyA9PT0gJ2luaXRpYWxpemVkJyB8fCBzID09PSAnZGV0YWNoZWQnIHx8IHMgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgJyArIHMsIDkwMDAxLCA0MDApO1xuXHR9XG5cblx0cmV0dXJuIFJlYWx0aW1lQ2hhbm5lbDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlYWx0aW1lY2hhbm5lbCA9IChyZWFsdGltZWNoYW5uZWxfUmVhbHRpbWVDaGFubmVsKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9lcnJvcnJlcG9ydGVyLmpzXG52YXIgZXJyb3JyZXBvcnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lLmpzXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZWFsdGltZV9SZWFsdGltZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBSZWFsdGltZShvcHRpb25zKSB7XG5cdFx0aWYoISh0aGlzIGluc3RhbmNlb2YgUmVhbHRpbWUpKXtcblx0XHRcdHJldHVybiBuZXcgUmVhbHRpbWUob3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWUoKScsICcnKTtcblx0XHRjbGllbnRfcmVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdFx0dGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyh0aGlzKTtcblx0XHRpZihvcHRpb25zLmF1dG9Db25uZWN0ICE9PSBmYWxzZSlcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lLCBjbGllbnRfcmVzdCk7XG5cblx0UmVhbHRpbWUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZS5jb25uZWN0KCknLCAnJyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcblx0fTtcblxuXHRSZWFsdGltZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZS5jbG9zZSgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIENoYW5uZWxzKHJlYWx0aW1lKSB7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuXHRcdHRoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR0aGlzLmluUHJvZ3Jlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRyZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLm9uVHJhbnNwb3J0QWN0aXZlKCk7XG5cdFx0fSk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoQ2hhbm5lbHMsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcblx0XHR2YXIgY2hhbm5lbE5hbWUgPSBtc2cuY2hhbm5lbDtcblx0XHRpZihjaGFubmVsTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgdW5zcGVjaWZpZWQgY2hhbm5lbCwgYWN0aW9uID0gJyArIG1zZy5hY3Rpb24pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQ2hhbm5lbHMub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGV2ZW50IGZvciBub24tZXhpc3RlbnQgY2hhbm5lbDogJyArIGNoYW5uZWxOYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y2hhbm5lbC5vbk1lc3NhZ2UobXNnKTtcblx0fTtcblxuXHQvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcblx0ICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHVzZSBpblByb2dyZXNzIGFzIGluUHJvZ3Jlc3MgaXMgb25seSBjaGFubmVscyB3aGljaCBoYXZlIGFscmVhZHkgbWFkZVxuXHQqIGF0IGxlYXN0IG9uZSBhdHRlbXB0IHRvIGF0dGFjaC9kZXRhY2ggKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsTmFtZSBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoaW5nJyB8fCBjaGFubmVsLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuXHRcdFx0XHRjaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9IGVsc2UgaWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcblx0XHRcdC8qIE5CIHRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGZvciBtZXJlbHkgYXR0YWNoaW5nIGNoYW5uZWxzLCBhcyB0aGV5IHdpbGxcblx0XHRcdCAqIGJlIHJlYXR0YWNoZWQgYW55d2F5IHRocm91Z2ggdGhlIG9uVHJhbnNwb3J0QWN0aXZlIGNoZWNrUGVuZGluZ1N0YXRlICovXG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGNoYW5uZWwucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnLCByZWFzb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUucmVzZXRBdHRhY2hlZE1zZ0luZGljYXRvcnMgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0Y2hhbm5lbC5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzID0gZnVuY3Rpb24oY29ubmVjdGlvbklkKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcgJiYgY2hhbm5lbC5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnMzBzIGFmdGVyIGEgcmVzdW1lLCBmb3VuZCBjaGFubmVsIHdoaWNoIGhhcyBub3QgcmVjZWl2ZWQgYW4gYXR0YWNoZWQ7IGNoYW5uZWxJZCA9ICcgKyBjaGFubmVsSWQgKyAnOyBjb25uZWN0aW9uSWQgPSAnICsgY29ubmVjdGlvbklkO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5jaGVja0F0dGFjaGVkTXNnSW5kaWNhdG9ycygpJywgbXNnKTtcblx0XHRcdFx0ZXJyb3JyZXBvcnRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAnY2hhbm5lbC1uby1hdHRhY2hlZC1hZnRlci1yZXN1bWUnKTtcblx0XHRcdFx0Y2hhbm5lbC5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0LyogQ29ubmVjdGlvbiBpbnRlcnJ1cHRpb25zIChpZSB3aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgbm8gbG9uZ2VyIHF1ZXVlXG5cdCAqIGV2ZW50cykgaW1wbHkgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzIGZvciBhbnkgY2hhbm5lbCB3aGljaCBpcyBlaXRoZXJcblx0ICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUucHJvcG9nYXRlQ29ubmVjdGlvbkludGVycnVwdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG5cdFx0dmFyIGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlID0ge1xuXHRcdFx0J2Nsb3NpbmcnICA6ICdkZXRhY2hlZCcsXG5cdFx0XHQnY2xvc2VkJyAgIDogJ2RldGFjaGVkJyxcblx0XHRcdCdmYWlsZWQnICAgOiAnZmFpbGVkJyxcblx0XHRcdCdzdXNwZW5kZWQnOiAnc3VzcGVuZGVkJ1xuXHRcdH07XG5cdFx0dmFyIGZyb21DaGFubmVsU3RhdGVzID0gWydhdHRhY2hpbmcnLCAnYXR0YWNoZWQnLCAnZGV0YWNoaW5nJywgJ3N1c3BlbmRlZCddO1xuXHRcdHZhciB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XG5cblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4oZnJvbUNoYW5uZWxTdGF0ZXMsIGNoYW5uZWwuc3RhdGUpKSB7XG5cdFx0XHRcdCBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRuYW1lID0gU3RyaW5nKG5hbWUpO1xuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG5cdFx0aWYoIWNoYW5uZWwpIHtcblx0XHRcdGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXSA9IG5ldyByZWFsdGltZWNoYW5uZWwodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH0gZWxzZSBpZihjaGFubmVsT3B0aW9ucykge1xuXHRcdFx0aWYgKGNoYW5uZWwuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwiQ2hhbm5lbHMuZ2V0KCkgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGNoYW5uZWwgb3B0aW9ucyB0aGF0IHdvdWxkIGNhdXNlIHRoZSBjaGFubmVsIHRvIHJlYXR0YWNoLiBQbGVhc2UsIHVzZSBSZWFsdGltZUNoYW5uZWwuc2V0T3B0aW9ucygpIGluc3RlYWQuXCIsIDQwMDAwLCA0MDApO1xuXHRcdFx0fVxuXHRcdFx0Y2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNoYW5uZWw7XG5cdH07XG5cblx0LyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXG5cdCAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgcmVsZWFzZUVyciA9IGNoYW5uZWwuZ2V0UmVsZWFzZUVycigpO1xuXHRcdGlmKHJlbGVhc2VFcnIpIHtcblx0XHRcdHRocm93IHJlbGVhc2VFcnI7XG5cdFx0fVxuXHRcdGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcblx0XHRkZWxldGUgdGhpcy5pblByb2dyZXNzW25hbWVdO1xuXHR9O1xuXG5cdC8qIFJlY29yZHMgb3BlcmF0aW9ucyBjdXJyZW50bHkgcGVuZGluZyBvbiBhIHRyYW5zcG9ydDsgdXNlZCBieSBjb25uZWN0aW9uTWFuYWdlciB0byBkZWNpZGUgd2hlblxuXHQgKiBpdCdzIHNhZmUgdG8gdXBncmFkZS4gTm90ZSB0aGF0IGEgY2hhbm5lbCBtaWdodCBiZSBpbiB0aGUgYXR0YWNoaW5nIHN0YXRlIHdpdGhvdXQgYW55IHBlbmRpbmdcblx0ICogb3BlcmF0aW9ucyAoZWcgaWYgYXR0YWNoZWQgd2hpbGUgdGhlIGNvbm5lY3Rpb24gc3RhdGUgaXMgY29ubmVjdGluZykgLSBzdWNoIGEgY2hhbm5lbCBtdXN0IG5vdFxuXHQgKiBob2xkIHVwIGFuIHVwZ3JhZGUsIHNvIGlzIG5vdCBjb25zaWRlcmVkIGluUHJvZ3Jlc3MuXG5cdCAqIE9wZXJhdGlvbiBpcyBjdXJyZW50bHkgb25lIG9mIGVpdGhlciAnc3RhdGVjaGFuZ2UnIG9yICdzeW5jJyAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKGNoYW5uZWwsIG9wZXJhdGlvbiwgaW5Qcm9ncmVzcykge1xuXHRcdHRoaXMuaW5Qcm9ncmVzc1tjaGFubmVsLm5hbWVdID0gdGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV0gfHwge307XG5cdFx0dGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV1bb3BlcmF0aW9uXSA9IGluUHJvZ3Jlc3M7XG5cdFx0aWYoIWluUHJvZ3Jlc3MgJiYgdGhpcy5oYXNOb3BlbmRpbmcoKSkge1xuXHRcdFx0dGhpcy5lbWl0KCdub3BlbmRpbmcnKTtcblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uY2VOb3BlbmRpbmcgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdGlmKHRoaXMuaGFzTm9wZW5kaW5nKCkpIHtcblx0XHRcdGxpc3RlbmVyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub25jZSgnbm9wZW5kaW5nJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5oYXNOb3BlbmRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRXZlcnkodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udmFsdWVzQXJyYXkodGhpcy5pblByb2dyZXNzLCB0cnVlKSwgZnVuY3Rpb24ob3BlcmF0aW9ucykge1xuXHRcdFx0cmV0dXJuICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb250YWluc1ZhbHVlKG9wZXJhdGlvbnMsIHRydWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBSZWFsdGltZTtcbn0pKCk7XG5cbnJlYWx0aW1lX1JlYWx0aW1lLlByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuXHRvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcblx0cmV0dXJuIG5ldyByZWFsdGltZV9SZWFsdGltZShvcHRpb25zKTtcbn07XG5cbnJlYWx0aW1lX1JlYWx0aW1lLkNhbGxiYWNrcyA9IHJlYWx0aW1lX1JlYWx0aW1lO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVhbHRpbWUgPSAocmVhbHRpbWVfUmVhbHRpbWUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9tc2dwYWNrLmpzXG52YXIgdXRpbF9tc2dwYWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9pbmRleC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsaWVudF9yZXN0LlV0aWxzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuQ3J5cHRvID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5EZWZhdWx0cyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5SZXNvdXJjZSA9IGNsaWVudF9yZXNvdXJjZTtcbmNsaWVudF9yZXN0Lk1lc3NhZ2UgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG5jbGllbnRfcmVhbHRpbWUuVXRpbHMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkNyeXB0byA9IHV0aWxfY3J5cHRvW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkRlZmF1bHRzID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuTWVzc2FnZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsaWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIFJlc3Q6IGNsaWVudF9yZXN0LFxuICBSZWFsdGltZTogY2xpZW50X3JlYWx0aW1lLFxuICBtc2dwYWNrOiB1dGlsX21zZ3BhY2tbXCJhXCIgLyogZGVmYXVsdCAqL11cbn0pO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyogUGxlYXNlIG5vdGUgdGhhdCB0aGUgZmlsZSBpbXBvcnRlZCBiZWxvdyBpcyBvbmx5IGdlbmVyYXRlZCBhZnRlciBydW5uaW5nIFxuICogdGhlIGJ1aWxkIHRhc2suICovXG52YXIgQWJseSA9IHJlcXVpcmUoJy4vYnJvd3Nlci9zdGF0aWMvYWJseS1ub2RlJyk7XG5cbnZhciBSZXN0UHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYmx5LlJlc3QocHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSk7XG59XG5PYmplY3QuYXNzaWduKFJlc3RQcm9taXNlLCBBYmx5LlJlc3QpO1xuXG52YXIgUmVhbHRpbWVQcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFibHkuUmVhbHRpbWUocHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSk7XG59XG5PYmplY3QuYXNzaWduKFJlYWx0aW1lUHJvbWlzZSwgQWJseS5SZWFsdGltZSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBSZXN0OiBSZXN0UHJvbWlzZSxcbiAgUmVhbHRpbWU6IFJlYWx0aW1lUHJvbWlzZVxufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzJdIS4vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzJdIS4vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzJdIS4vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuY2hhdENvbXBvbmVudHNfY2hhdEhvbGRlcl9fMkUxQVgge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfY2hhdFRleHRfXzNNUkVzIHtcXHJcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG4gIGdyaWQtZ2FwOiAxZW07XFxyXFxuICBnYXA6IDFlbTtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2Zvcm1fXzNyRklLIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxMDBweDtcXHJcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfdGV4dGFyZWFfXzJVdUx5IHtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlcjogMDtcXHJcXG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbixcXHJcXG4gICAgVWJ1bnR1LCBDYW50YXJlbGwsIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsIHNhbnMtc2VyaWY7XFxyXFxuICBmb250LXNpemU6IDEuMmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TSB7XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc2l6ZTogMS40ZW07XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIHJpZ2h0IHRvcCwgZnJvbSgjMzYzNzk1KSwgdG8oIzAwNWM5NykpO1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU06aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChcXHJcXG4gICAgbGluZWFyLFxcclxcbiAgICBsZWZ0IHRvcCwgcmlnaHQgdG9wLFxcclxcbiAgICBmcm9tKHJnYmEoNTQsIDU1LCAxNDksIDEpKSxcXHJcXG4gICAgY29sb3Itc3RvcCg2MiUsIHJnYmEoMCwgOTIsIDE1MSwgMSkpLFxcclxcbiAgICB0byhyZ2JhKDAsIDEyNSwgMjA1LCAxKSlcXHJcXG4gICk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxyXFxuICAgIDkwZGVnLFxcclxcbiAgICByZ2JhKDU0LCA1NSwgMTQ5LCAxKSAwJSxcXHJcXG4gICAgcmdiYSgwLCA5MiwgMTUxLCAxKSA2MiUsXFxyXFxuICAgIHJnYmEoMCwgMTI1LCAyMDUsIDEpIDEwMCVcXHJcXG4gICk7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNOmRpc2FibGVkLFxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNOmhvdmVyOmRpc2FibGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBmcm9tKCMzNjM3OTUpLCB0bygjMDA1Yzk3KSk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbiAgb3BhY2l0eTogMC41O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfbWVzc2FnZV9fMWRub0Ige1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZjVmODtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAtd2Via2l0LWZsZXgtZ3JvdzogMDtcXHJcXG4gICAgICAgICAgZmxleC1ncm93OiAwO1xcclxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvY2hhdHJvb20vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGFBQWE7RUFDYiw2QkFBNkI7QUFDL0I7O0FBRUE7RUFDRSxxQkFBYTtFQUFiLGFBQWE7RUFDYiw4QkFBc0I7VUFBdEIsc0JBQXNCO0VBQ3RCLCtCQUF1QjtVQUF2Qix1QkFBdUI7RUFDdkIsYUFBUTtFQUFSLFFBQVE7RUFDUixZQUFZO0VBQ1osa0RBQWtEO0VBQ2xELGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGFBQWE7RUFDYixnQ0FBZ0M7RUFDaEMsMEJBQTBCO0FBQzVCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLFNBQVM7RUFDVDt3RUFDc0U7RUFDdEUsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsU0FBUztFQUNULFlBQVk7RUFDWixpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLHFGQUF1RDtFQUF2RCx1REFBdUQ7QUFDekQ7O0FBRUE7RUFDRTs7Ozs7O0dBS0M7RUFMRDs7Ozs7R0FLQztBQUNIOztBQUVBOztFQUVFLHFGQUF1RDtFQUF2RCx1REFBdUQ7RUFDdkQsWUFBWTtBQUNkOztBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLFlBQVk7RUFDWixtQkFBbUI7RUFDbkIsb0JBQVk7VUFBWixZQUFZO0VBQ1osNEJBQTRCO0FBQzlCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jaGF0SG9sZGVyIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmciAxMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRUZXh0IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxyXFxuICBnYXA6IDFlbTtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLmZvcm0ge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDEwMHB4O1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7XFxyXFxufVxcclxcblxcclxcbi50ZXh0YXJlYSB7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sXFxyXFxuICAgIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcclxcbiAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbiB7XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc2l6ZTogMS40ZW07XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgOTBkZWcsXFxyXFxuICAgIHJnYmEoNTQsIDU1LCAxNDksIDEpIDAlLFxcclxcbiAgICByZ2JhKDAsIDkyLCAxNTEsIDEpIDYyJSxcXHJcXG4gICAgcmdiYSgwLCAxMjUsIDIwNSwgMSkgMTAwJVxcclxcbiAgKTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbjpkaXNhYmxlZCxcXHJcXG4uYnV0dG9uOmhvdmVyOmRpc2FibGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxuICBvcGFjaXR5OiAwLjU7XFxyXFxufVxcclxcblxcclxcbi5tZXNzYWdlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWY1Zjg7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgZmxleC1ncm93OiAwO1xcclxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY2hhdEhvbGRlclwiOiBcImNoYXRDb21wb25lbnRzX2NoYXRIb2xkZXJfXzJFMUFYXCIsXG5cdFwiY2hhdFRleHRcIjogXCJjaGF0Q29tcG9uZW50c19jaGF0VGV4dF9fM01SRXNcIixcblx0XCJmb3JtXCI6IFwiY2hhdENvbXBvbmVudHNfZm9ybV9fM3JGSUtcIixcblx0XCJ0ZXh0YXJlYVwiOiBcImNoYXRDb21wb25lbnRzX3RleHRhcmVhX18yVXVMeVwiLFxuXHRcImJ1dHRvblwiOiBcImNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU1cIixcblx0XCJtZXNzYWdlXCI6IFwiY2hhdENvbXBvbmVudHNfbWVzc2FnZV9fMWRub0JcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iXSwibmFtZXMiOlsiQWJseSIsInVzZUVmZmVjdCIsImFibHkiLCJSZWFsdGltZSIsIlByb21pc2UiLCJhdXRoVXJsIiwidXNlQ2hhbm5lbCIsImNoYW5uZWxOYW1lIiwiY2FsbGJhY2tPbk1lc3NhZ2UiLCJjaGFubmVsIiwiY2hhbm5lbHMiLCJnZXQiLCJvbk1vdW50Iiwic3Vic2NyaWJlIiwibXNnIiwib25Vbk1vdW50IiwidW5zdWJzY3JpYmUiLCJ1c2VFZmZlY3RIb29rIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInN0eWxlcyIsIkNoYXRDb21wb25lbnQiLCJpbnB1dEJveCIsIm1lc3NhZ2VFbmQiLCJtZXNzYWdlVGV4dCIsInNldE1lc3NhZ2VUZXh0IiwicmVjZWl2ZWRNZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwibWVzc2FnZVRleHRJc0VtcHR5IiwidHJpbSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJoaXN0b3J5Iiwic2xpY2UiLCJzZW5kQ2hhdE1lc3NhZ2UiLCJwdWJsaXNoIiwibmFtZSIsImRhdGEiLCJmb2N1cyIsImhhbmRsZUZvcm1TdWJtaXNzaW9uIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUtleVByZXNzIiwiY2hhckNvZGUiLCJtZXNzYWdlcyIsIm1hcCIsImluZGV4IiwiYXV0aG9yIiwiY29ubmVjdGlvbklkIiwiY29ubmVjdGlvbiIsImlkIiwibWlsbGlzZWNvbmRzIiwiRGF0ZSIsInRpbWVTdGFtcCIsInRvRGF0ZVN0cmluZyIsInNjcm9sbEludG9WaWV3IiwiYmVoYXZpb3VyIiwiY2hhdEhvbGRlciIsImNoYXRUZXh0IiwiZWxlbWVudCIsImZvcm0iLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJ0ZXh0YXJlYSIsImJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=